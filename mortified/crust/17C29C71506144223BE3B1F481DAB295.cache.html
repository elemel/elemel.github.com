<html>
<head><meta charset="UTF-8" /><script>
var $gwt_version = "2.5.0";
var $wnd = parent;
var $doc = $wnd.document;
var $moduleName, $moduleBase;
var $strongName = '17C29C71506144223BE3B1F481DAB295';
var $stats = $wnd.__gwtStatsEvent ? function(a) {return $wnd.__gwtStatsEvent(a);} : null,
$sessionId = $wnd.__gwtStatsSessionId ? $wnd.__gwtStatsSessionId : null;
$stats && $stats({moduleName:'crust',sessionId:$sessionId,subSystem:'startup',evtGroup:'moduleStartup',millis:(new Date()).getTime(),type:'moduleEvalStart'});
</script></head>
<body>
<script><!--
var _, P0_longLit = {l:0, m:0, h:0}, seedTable = {}, Q$Object = 0, Q$String = 1, Q$Sound$LoadState = 2, Q$SoundController$MimeTypeSupport = 3, Q$SoundType = 4, Q$Context2d$Repetition = 5, Q$Style$HasCssName = 6, Q$Style$Overflow = 7, Q$Style$Position = 8, Q$Style$Unit = 9, Q$Style$Visibility = 10, Q$HasAttachHandlers = 11, Q$HasHandlers = 12, Q$LongLibBase$LongEmul = 13, Q$EventListener = 14, Q$HasVisibility = 15, Q$IsWidget = 16, Q$UIObject = 17, Q$Widget = 18, Q$UmbrellaException = 19, Q$Serializable = 20, Q$CharSequence = 21, Q$Comparable = 22, Q$Enum = 23, Q$Exception = 24, Q$Float = 25, Q$Integer = 26, Q$Number = 27, Q$Object_$1 = 28, Q$RuntimeException = 29, Q$StackTraceElement = 30, Q$Throwable = 31, Q$ByteBuffer = 32, Q$FloatBuffer = 33, Q$IntBuffer = 34, Q$ShortBuffer = 35, Q$List = 36, Q$Map = 37, Q$Map$Entry = 38, Q$Set = 39, Q$AABB = 40, Q$Collision$ClipVertex = 41, Q$Distance$SimplexVertex = 42, Q$Manifold$ManifoldType = 43, Q$ManifoldPoint = 44, Q$TimeOfImpact$TOIOutputState = 45, Q$Type = 46, Q$DynamicTreeNode = 47, Q$Pair = 48, Q$ShapeType = 49, Q$Mat22 = 50, Q$Vec2 = 51, Q$Vec3 = 52, Q$Body = 53, Q$BodyType = 54, Q$Position = 55, Q$Velocity = 56, Q$CircleContact = 57, Q$Contact = 58, Q$ContactConstraint = 59, Q$ContactConstraintPoint = 60, Q$ContactRegister = 61, Q$ContactRegister_$1 = 62, Q$PolygonAndCircleContact = 63, Q$PolygonContact = 64, Q$TOIConstraint = 65, Q$Joint = 66, Q$AbstractLayer$Flag = 67, Q$Events$Input = 68, Q$Events$Input$Impl = 69, Q$Events$Position = 70, Q$Events$Position$Impl = 71, Q$Key = 72, Q$Log$Level = 73, Q$Touch$Event = 74, Q$Touch$Event$Impl = 75, Q$HasArrayBufferView = 76, Q$HtmlGL20$VertexAttribArrayState = 77, Q$HtmlGL20$WebGLObjectType = 78, Q$AbstractDimension = 79, Q$AbstractPoint = 80, Q$AbstractRectangle = 81, Q$AbstractVector = 82, CM$ = {};
function newSeed(id){
  return new seedTable[id];
}

function defineSeed(id, superSeed, castableTypeMap){
  var seed = seedTable[id];
  if (seed && !seed.___clazz$) {
    _ = seed.prototype;
  }
   else {
    !seed && (seed = seedTable[id] = function(){
    }
    );
    _ = seed.prototype = superSeed < 0?{}:newSeed(superSeed);
    _.castableTypeMap$ = castableTypeMap;
  }
  for (var i = 3; i < arguments.length; ++i) {
    arguments[i].prototype = _;
  }
  if (seed.___clazz$) {
    _.___clazz$ = seed.___clazz$;
    seed.___clazz$ = null;
  }
}

function makeCastMap(a){
  var result = {};
  for (var i = 0, c = a.length; i < c; ++i) {
    result[a[i]] = 1;
  }
  return result;
}

function nullMethod(){
}

defineSeed(1, -1, CM$);
_.equals$ = function equals(other){
  return this === other;
}
;
_.getClass$ = function getClass_0(){
  return this.___clazz$;
}
;
_.hashCode$ = function hashCode_0(){
  return getHashCode(this);
}
;
_.toString$ = function toString_0(){
  return this.___clazz$.typeName + '@' + toPowerOfTwoString(this.hashCode$());
}
;
_.toString = function(){
  return this.toString$();
}
;
_.typeMarker$ = nullMethod;
function $clinit_AbstractSound(){
  $clinit_AbstractSound = nullMethod;
  INITIAL_LOAD_STATE = ($clinit_Sound$LoadState() , LOAD_STATE_UNINITIALIZED);
}

function $addEventHandler(this$static, handler){
  $add_0(this$static.soundHandlerCollection, handler);
  this$static.loadState != INITIAL_LOAD_STATE && $onSoundLoadStateChange(handler, new SoundLoadStateChangeEvent_0(this$static));
}

function $setLoadState(this$static, loadState){
  if (loadState != this$static.loadState) {
    this$static.loadState = loadState;
    loadState != INITIAL_LOAD_STATE && $fireOnSoundLoadStateChange(this$static.soundHandlerCollection, this$static);
  }
}

function AbstractSound_0(url){
  $clinit_AbstractSound();
  this.soundHandlerCollection = new SoundHandlerCollection_0;
  this.loadState = INITIAL_LOAD_STATE;
  this.mimeType = 'audio/mpeg';
  this.url = url;
  this.streaming = false;
  this.crossOrigin = false;
}

defineSeed(3, 1, {});
_.toString$ = function toString_1(){
  return this.getSoundType() + '("' + this.mimeType + '", "' + this.url + '", ' + (this.streaming?'streaming':'not streaming') + ', ' + (this.crossOrigin?'cross origin':'same origin') + ')';
}
;
_.crossOrigin = false;
_.mimeType = null;
_.streaming = false;
_.url = null;
var INITIAL_LOAD_STATE;
function $clinit_FlashSound(){
  $clinit_FlashSound = nullMethod;
  $clinit_AbstractSound();
  soundList = new ArrayList_0;
}

function $playbackCompleted(this$static){
  $fireOnPlaybackComplete(this$static.soundHandlerCollection, this$static);
}

function $registerSound(this$static){
  if (!this$static.soundRegistered) {
    $registerSound_0(this$static.voicesMovie, this$static);
    this$static.soundRegistered = true;
  }
}

function $soundLoaded(this$static){
  $setLoadState(this$static, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY));
  this$static.volume_0 != 100 && $setVolume(this$static.voicesMovie, this$static.soundNumber, this$static.volume_0);
  this$static.looping && $setLooping(this$static.voicesMovie, this$static.soundNumber, this$static.looping);
}

function FlashSound_0(url, voicesMovie){
  $clinit_FlashSound();
  AbstractSound_0.call(this, url);
  this.voicesMovie = voicesMovie;
  this.soundNumber = soundList.size;
  $add_0(soundList, this);
  $registerSound(this);
}

defineSeed(4, 3, {}, FlashSound_0);
_.getSoundType = function getSoundType(){
  return $clinit_SoundType() , FLASH;
}
;
_.play_0 = function play(){
  $registerSound(this);
  if (this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY)) {
    return $playSound(this.voicesMovie, this.soundNumber);
  }
  return false;
}
;
_.setLooping_0 = function setLooping(looping){
  this.looping = looping;
  this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY) && $setLooping(this.voicesMovie, this.soundNumber, looping);
}
;
_.setVolume_0 = function setVolume(volume){
  this.volume_0 = volume;
  this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY) && $setVolume(this.voicesMovie, this.soundNumber, volume);
}
;
_.looping = false;
_.soundNumber = 0;
_.soundRegistered = false;
_.voicesMovie = null;
_.volume_0 = 100;
var soundList;
function FlashSound$1_0(val$index){
  this.val$index = val$index;
}

defineSeed(5, 1, {}, FlashSound$1_0);
_.execute = function execute(){
  $playbackCompleted($get(($clinit_FlashSound() , soundList), this.val$index));
}
;
_.val$index = 0;
function FlashSound$2_0(val$index){
  this.val$index = val$index;
}

defineSeed(6, 1, {}, FlashSound$2_0);
_.execute = function execute_0(){
  $soundLoaded($get(($clinit_FlashSound() , soundList), this.val$index));
}
;
_.val$index = 0;
function $createAudioElement(this$static){
  var elem;
  !!this$static.endedRegistration && $removeHandler(this$static.endedRegistration.real);
  !!this$static.audio && $removeFromParent(this$static.audio);
  this$static.audio = createIfSupported();
  elem = this$static.audio.element;
  this$static.endedRegistration = $addBitlessDomHandler(this$static.audio, this$static.endedHandler, ($clinit_EndedEvent() , $clinit_EndedEvent() , TYPE));
  $add_2(($clinit_RootPanel() , get_2()), this$static.audio);
  this$static.crossOrigin && (elem.setAttribute('crossOrigin', 'anonymous') , undefined);
  $setSrc(elem, this$static.url);
}

function Html5Sound_0(url){
  $clinit_AbstractSound();
  var mimeTypeSupport;
  AbstractSound_0.call(this, url);
  this.endedHandler = new Html5Sound$1_0(this);
  $createAudioElement(this);
  mimeTypeSupport = getMimeTypeSupport();
  switch (mimeTypeSupport.ordinal) {
    case 2:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_MAYBE_READY));
      break;
    case 0:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
      break;
    case 3:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORT_NOT_KNOWN));
      throw new IllegalArgumentException_1('unexpected MIME type support ' + mimeTypeSupport);
    default:throw new IllegalArgumentException_1('unknown MIME type support ' + mimeTypeSupport);
  }
}

function getMimeTypeSupport(){
  var canPlayType;
  $clinit_AbstractSound();
  var support;
  if (!isSupported()) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED;
  }
  support = (canPlayType = createIfSupported().element.canPlayType('audio/mpeg') , canPlayType == 'no'?'':canPlayType);
  if ($equals('probably', support)) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY;
  }
  if ($equals('maybe', support)) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY;
  }
  return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_UNKNOWN;
}

defineSeed(7, 3, {}, Html5Sound_0);
_.getSoundType = function getSoundType_0(){
  return $clinit_SoundType() , HTML5;
}
;
_.play_0 = function play_0(){
  var $e0, elem;
  elem = this.audio.element;
  elem.pause();
  try {
    elem.currentTime = 0;
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (!instanceOf($e0, Q$Exception))
      throw $e0;
  }
  elem.currentTime != 0 && $createAudioElement(this);
  elem.play();
  return true;
}
;
_.setLooping_0 = function setLooping_0(looping){
  $setBooleanAttr(this.audio.element, looping);
}
;
_.setVolume_0 = function setVolume_0(volume){
  $setVolume_1(this.audio.element, volume / 100);
}
;
_.audio = null;
_.endedRegistration = null;
function Html5Sound$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(8, 1, {}, Html5Sound$1_0);
_.this$0 = null;
function NativeSound_0(url, soundControllerElement){
  var elem, m_0;
  $clinit_AbstractSound();
  var mimeTypeSupport;
  AbstractSound_0.call(this, url);
  this.soundControllerElement = soundControllerElement;
  elem = $createElement(url);
  $setVolume_0(elem, 0);
  $play(soundControllerElement, elem);
  this.element = $createElement(url);
  mimeTypeSupport = (m_0 = navigator.mimeTypes['audio/mpeg'] , m_0 != null && m_0.enabledPlugin != null?($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY):($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED));
  switch (mimeTypeSupport.ordinal) {
    case 2:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_MAYBE_READY));
      break;
    case 0:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
      break;
    case 3:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORT_NOT_KNOWN));
      break;
    case 1:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_NOT_READY));
      break;
    default:throw new IllegalArgumentException_1('unknown MIME type support ' + mimeTypeSupport);
  }
}

defineSeed(9, 3, {}, NativeSound_0);
_.getSoundType = function getSoundType_1(){
  return $clinit_SoundType() , NATIVE;
}
;
_.play_0 = function play_1(){
  return $play(this.soundControllerElement, this.element);
}
;
_.setLooping_0 = function setLooping_1(looping){
  this.element.setAttribute('loop', 'infinite');
}
;
_.setVolume_0 = function setVolume_1(volume){
  $setVolume_0(this.element, volume);
}
;
_.element = null;
_.soundControllerElement = null;
function Enum_0(name_0, ordinal){
  this.name_0 = name_0;
  this.ordinal = ordinal;
}

defineSeed(11, 1, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum]));
_.compareTo$ = function compareTo(other){
  return this.ordinal - other.ordinal;
}
;
_.equals$ = function equals_0(other){
  return this === other;
}
;
_.hashCode$ = function hashCode_1(){
  return getHashCode(this);
}
;
_.toString$ = function toString_2(){
  return this.name_0;
}
;
_.name_0 = null;
_.ordinal = 0;
function $clinit_Sound$LoadState(){
  $clinit_Sound$LoadState = nullMethod;
  LOAD_STATE_NOT_SUPPORTED = new Sound$LoadState_0('LOAD_STATE_NOT_SUPPORTED', 0);
  LOAD_STATE_SUPPORT_NOT_KNOWN = new Sound$LoadState_0('LOAD_STATE_SUPPORT_NOT_KNOWN', 1);
  LOAD_STATE_SUPPORTED_AND_READY = new Sound$LoadState_0('LOAD_STATE_SUPPORTED_AND_READY', 2);
  LOAD_STATE_SUPPORTED_MAYBE_READY = new Sound$LoadState_0('LOAD_STATE_SUPPORTED_MAYBE_READY', 3);
  LOAD_STATE_SUPPORTED_NOT_READY = new Sound$LoadState_0('LOAD_STATE_SUPPORTED_NOT_READY', 4);
  LOAD_STATE_UNINITIALIZED = new Sound$LoadState_0('LOAD_STATE_UNINITIALIZED', 5);
  $VALUES = initValues(_3Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Sound$LoadState, [LOAD_STATE_NOT_SUPPORTED, LOAD_STATE_SUPPORT_NOT_KNOWN, LOAD_STATE_SUPPORTED_AND_READY, LOAD_STATE_SUPPORTED_MAYBE_READY, LOAD_STATE_SUPPORTED_NOT_READY, LOAD_STATE_UNINITIALIZED]);
}

function Sound$LoadState_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values(){
  $clinit_Sound$LoadState();
  return $VALUES;
}

defineSeed(10, 11, makeCastMap([Q$Sound$LoadState, Q$Serializable, Q$Comparable, Q$Enum]), Sound$LoadState_0);
var $VALUES, LOAD_STATE_NOT_SUPPORTED, LOAD_STATE_SUPPORTED_AND_READY, LOAD_STATE_SUPPORTED_MAYBE_READY, LOAD_STATE_SUPPORTED_NOT_READY, LOAD_STATE_SUPPORT_NOT_KNOWN, LOAD_STATE_UNINITIALIZED;
function $clinit_SoundController(){
  $clinit_SoundController = nullMethod;
  $wnd.$GWT_VOICES_VERSION = '3.2.0';
}

function $createSound(this$static, url){
  var sound;
  sound = $createSoundImpl(this$static, url);
  sound.setVolume_0(100);
  return sound;
}

function $createSoundImpl(this$static, url){
  var c, c$array, c$index, c$max, sound;
  sound = null;
  for (c$array = this$static.preferredSoundTypes , c$index = 0 , c$max = c$array.length; c$index < c$max; ++c$index) {
    c = c$array[c$index];
    switch (c.ordinal) {
      case 1:
        sound = $createSoundImplHtml5(url);
        break;
      case 0:
        sound = $createSoundImplFlash(this$static, url);
        break;
      case 2:
        sound = $createSoundImplWebAudio(url);
        break;
      case 3:
        sound = $createSoundImplWebAudio(url);
    }
    if (sound) {
      return sound;
    }
  }
  sound = $createSoundImplWebAudio(url);
  if (sound) {
    return sound;
  }
  sound = $createSoundImplFlash(this$static, url);
  if (sound) {
    return sound;
  }
  sound = $createSoundImplHtml5(url);
  if (sound) {
    return sound;
  }
  sound = new NativeSound_0(url, this$static.soundContainer);
  return sound;
}

function $createSoundImplFlash(this$static, url){
  var mimeTypeSupport, sound, vm;
  if (url.indexOf('data:') == 0) {
    return null;
  }
  $clinit_FlashMovie();
  if (impl_0.impl.getMajorVersion() >= 9) {
    vm = $getVoicesMovie(this$static);
    mimeTypeSupport = $getMimeTypeSupport(vm);
    if (mimeTypeSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) || mimeTypeSupport == MIME_TYPE_SUPPORT_NOT_READY) {
      sound = new FlashSound_0(url, vm);
      return sound;
    }
  }
  return null;
}

function $createSoundImplHtml5(url){
  if (getMimeTypeSupport() == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)) {
    return new Html5Sound_0(url);
  }
  return null;
}

function $createSoundImplWebAudio(url){
  if (getMimeTypeSupport_0() == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)) {
    return new WebAudioSound_0(url);
  }
  return null;
}

function $getVoicesMovie(this$static){
  if (!this$static.voicesWrapper) {
    this$static.voicesWrapper = new VoicesMovie_0('gwtVoices' + uniqueId++, this$static.gwtVoicesSwfBaseUrl);
    $appendChild(this$static.soundContainer, ($clinit_PotentialElement() , $resolve(this$static.voicesWrapper.element)));
  }
  return this$static.voicesWrapper;
}

function $setPreferredSoundTypes(this$static, soundTypes){
  var s$index, s$max;
  for (s$index = 0 , s$max = soundTypes.length; s$index < s$max; ++s$index) {
  }
  this$static.preferredSoundTypes = soundTypes;
}

function SoundController_0(){
  var s, i, gwtVoices, style;
  $clinit_SoundController();
  this.soundContainer = $doc.createElement('div');
  this.gwtVoicesSwfBaseUrl = (s = $doc.location.href , i = s.indexOf('#') , i != -1 && (s = s.substring(0, i)) , i = s.indexOf('?') , i != -1 && (s = s.substring(0, i)) , i = s.lastIndexOf('/') , i != -1 && (s = s.substring(0, i)) , s.length > 0?s + '/':'') + $moduleName + '/';
  gwtVoices = (ensureParameterMap() , $get_6(paramMap, 'gwt-voices'));
  $equals(($clinit_SoundType() , FLASH).queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [FLASH])):$equals(HTML5.queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [HTML5])):$equals(WEB_AUDIO.queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [WEB_AUDIO])):$equals(NATIVE.queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [NATIVE])):$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [WEB_AUDIO, FLASH, HTML5]));
  $appendChild(getBodyElement(), this.soundContainer);
  style = this.soundContainer.style;
  style['position'] = ($clinit_Style$Position() , 'absolute');
  style['overflow'] = ($clinit_Style$Overflow() , 'hidden');
  style['left'] = -500 + ($clinit_Style$Unit() , 'px');
  style['top'] = '-500px';
  style['width'] = '0px';
  style['height'] = '0px';
}

defineSeed(12, 1, {}, SoundController_0);
_.preferredSoundTypes = null;
_.voicesWrapper = null;
function $clinit_SoundController$MimeTypeSupport(){
  $clinit_SoundController$MimeTypeSupport = nullMethod;
  MIME_TYPE_NOT_SUPPORTED = new SoundController$MimeTypeSupport_0('MIME_TYPE_NOT_SUPPORTED', 0);
  MIME_TYPE_SUPPORT_NOT_READY = new SoundController$MimeTypeSupport_0('MIME_TYPE_SUPPORT_NOT_READY', 1);
  MIME_TYPE_SUPPORT_READY = new SoundController$MimeTypeSupport_0('MIME_TYPE_SUPPORT_READY', 2);
  MIME_TYPE_SUPPORT_UNKNOWN = new SoundController$MimeTypeSupport_0('MIME_TYPE_SUPPORT_UNKNOWN', 3);
  $VALUES_0 = initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundController$MimeTypeSupport, [MIME_TYPE_NOT_SUPPORTED, MIME_TYPE_SUPPORT_NOT_READY, MIME_TYPE_SUPPORT_READY, MIME_TYPE_SUPPORT_UNKNOWN]);
}

function SoundController$MimeTypeSupport_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_0(){
  $clinit_SoundController$MimeTypeSupport();
  return $VALUES_0;
}

defineSeed(13, 11, makeCastMap([Q$SoundController$MimeTypeSupport, Q$Serializable, Q$Comparable, Q$Enum]), SoundController$MimeTypeSupport_0);
var $VALUES_0, MIME_TYPE_NOT_SUPPORTED, MIME_TYPE_SUPPORT_NOT_READY, MIME_TYPE_SUPPORT_READY, MIME_TYPE_SUPPORT_UNKNOWN;
function $clinit_SoundType(){
  $clinit_SoundType = nullMethod;
  FLASH = new SoundType_0('FLASH', 0, 'flash');
  HTML5 = new SoundType_0('HTML5', 1, 'html5');
  NATIVE = new SoundType_0('NATIVE', 2, 'native');
  WEB_AUDIO = new SoundType_0('WEB_AUDIO', 3, 'webaudio');
  $VALUES_1 = initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [FLASH, HTML5, NATIVE, WEB_AUDIO]);
}

function SoundType_0(enum$name, enum$ordinal, queryParameterValue){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.queryParameterValue = queryParameterValue;
}

function values_1(){
  $clinit_SoundType();
  return $VALUES_1;
}

defineSeed(14, 11, makeCastMap([Q$SoundType, Q$Serializable, Q$Comparable, Q$Enum]), SoundType_0);
_.queryParameterValue = null;
var $VALUES_1, FLASH, HTML5, NATIVE, WEB_AUDIO;
function $clinit_WebAudioSound(){
  $clinit_WebAudioSound = nullMethod;
  $clinit_AbstractSound();
  audioContext = createAudioContext();
}

function $createVoice(this$static, url){
  var context = audioContext;
  var request = new $wnd.XMLHttpRequest;
  request.open('GET', url, true);
  request.responseType = 'arraybuffer';
  var self_0 = this$static;
  request.onload = function(){
    try {
      self_0.buffer_0 = context.createBuffer(request.response, false);
      self_0.soundLoaded_0();
    }
     catch (e) {
      self_0.soundLoadFailed();
    }
  }
  ;
  request.send();
}

function WebAudioSound_0(url){
  $clinit_WebAudioSound();
  var $e0, mimeTypeSupport;
  AbstractSound_0.call(this, url);
  try {
    $createVoice(this, url);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
    }
     else 
      throw $e0;
  }
  mimeTypeSupport = getMimeTypeSupport_0();
  switch (mimeTypeSupport.ordinal) {
    case 1:
    case 2:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_NOT_READY));
      break;
    case 0:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
      break;
    case 3:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORT_NOT_KNOWN));
      break;
    default:throw new IllegalArgumentException_1('unknown MIME type support ' + mimeTypeSupport);
  }
}

function createAudioContext(){
  try {
    return new AudioContext;
  }
   catch (ignore) {
  }
  try {
    return new webkitAudioContext;
  }
   catch (ignore) {
  }
  return null;
}

function getMimeTypeSupport_0(){
  $clinit_WebAudioSound();
  if (!audioContext) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED;
  }
  return getMimeTypeSupport();
}

defineSeed(15, 3, {}, WebAudioSound_0);
_.getSoundType = function getSoundType_2(){
  return $clinit_SoundType() , WEB_AUDIO;
}
;
_.plackbackCompleted = function plackbackCompleted(){
  $fireOnPlaybackComplete(this.soundHandlerCollection, this);
}
;
_.play_0 = function play_2(){
  var buffer = this.buffer_0;
  if (buffer == null) {
    return false;
  }
  this.stop_0();
  var context = audioContext;
  var voice = context.createBufferSource();
  this.voice = voice;
  this.looping && (voice.loop = true);
  var node = voice;
  var volume = this.volume_0;
  if (volume != 100) {
    var gainNode = context.createGainNode();
    gainNode.gain.value = volume / 100;
    node.connect(gainNode);
    node = gainNode;
  }
  node.connect(context.destination);
  voice.buffer = buffer;
  voice.noteOn(context.currentTime);
  if (!voice.loop) {
    var self_0 = this;
    setTimeout(function(){
      self_0.plackbackCompleted();
    }
    , voice.buffer.duration * 1000);
  }
  return true;
}
;
_.setLooping_0 = function setLooping_2(looping){
  this.looping = looping;
}
;
_.setVolume_0 = function setVolume_2(volume){
  this.volume_0 = volume;
}
;
_.soundLoadFailed = function soundLoadFailed(){
  $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
}
;
_.soundLoaded_0 = function soundLoaded(){
  $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY));
}
;
_.stop_0 = function stop_0(){
  var context = audioContext;
  var voice = this.voice;
  if (voice == null) {
    return;
  }
  voice.noteOff(context.currentTime);
  this.voice = null;
}
;
_.buffer_0 = null;
_.looping = false;
_.voice = null;
_.volume_0 = 0;
var audioContext = null;
defineSeed(17, 1, {});
_.source = null;
function PlaybackCompleteEvent_0(source){
  this.source = source;
}

defineSeed(16, 17, {}, PlaybackCompleteEvent_0);
_.toString$ = function toString_3(){
  var sound;
  sound = this.source;
  return getSimpleName(Lcom_allen_1sauer_gwt_voices_client_handler_PlaybackCompleteEvent_2_classLit) + ': ' + sound;
}
;
function $advanceToFind(iter, o){
  var t;
  while (iter.hasNext()) {
    t = iter.next_0();
    if (o == null?t == null:equals__devirtual$(o, t)) {
      return iter;
    }
  }
  return null;
}

function $toString(this$static){
  var comma, iter, sb, value;
  sb = new StringBuffer_0;
  comma = null;
  sb.impl.string += '[';
  iter = this$static.iterator();
  while (iter.hasNext()) {
    comma != null?($append_3(sb.impl, comma) , sb):(comma = ', ');
    value = iter.next_0();
    $append_3(sb.impl, value === this$static?'(this Collection)':'' + value);
  }
  sb.impl.string += ']';
  return sb.impl.string;
}

defineSeed(21, 1, {});
_.add = function add(o){
  throw new UnsupportedOperationException_1('Add not supported on this collection');
}
;
_.contains_0 = function contains(o){
  var iter;
  iter = $advanceToFind(this.iterator(), o);
  return !!iter;
}
;
_.isEmpty = function isEmpty(){
  return this.size_0() == 0;
}
;
_.remove = function remove_0(o){
  var iter;
  iter = $advanceToFind(this.iterator(), o);
  if (iter) {
    iter.remove_2();
    return true;
  }
   else {
    return false;
  }
}
;
_.toString$ = function toString_4(){
  return $toString(this);
}
;
function checkIndex(index, size){
  (index < 0 || index >= size) && indexOutOfBounds(index, size);
}

function indexOutOfBounds(index, size){
  throw new IndexOutOfBoundsException_1('Index: ' + index + ', Size: ' + size);
}

defineSeed(20, 21, makeCastMap([Q$List]));
_.add_0 = function add_0(index, element){
  throw new UnsupportedOperationException_1('Add not supported on this list');
}
;
_.add = function add_1(obj){
  this.add_0(this.size_0(), obj);
  return true;
}
;
_.equals$ = function equals_1(o){
  var elem, elemOther, iter, iterOther, other;
  if (o === this) {
    return true;
  }
  if (!instanceOf(o, Q$List)) {
    return false;
  }
  other = o;
  if (this.size_0() != other.size_0()) {
    return false;
  }
  iter = this.iterator();
  iterOther = other.iterator();
  while (iter.i < iter.this$0_0.size_0()) {
    elem = $next_2(iter);
    elemOther = $next_2(iterOther);
    if (!(elem == null?elemOther == null:equals__devirtual$(elem, elemOther))) {
      return false;
    }
  }
  return true;
}
;
_.hashCode$ = function hashCode_2(){
  var iter, k, obj;
  k = 1;
  iter = this.iterator();
  while (iter.i < iter.this$0_0.size_0()) {
    obj = $next_2(iter);
    k = 31 * k + (obj == null?0:hashCode__devirtual$(obj));
    k = ~~k;
  }
  return k;
}
;
_.iterator = function iterator_0(){
  return new AbstractList$IteratorImpl_0(this);
}
;
_.listIterator = function listIterator(){
  return new AbstractList$ListIteratorImpl_0(this, 0);
}
;
_.listIterator_0 = function listIterator_0(from){
  return new AbstractList$ListIteratorImpl_0(this, from);
}
;
_.remove_0 = function remove_1(index){
  throw new UnsupportedOperationException_1('Remove not supported on this list');
}
;
function $add(this$static, index, o){
  (index < 0 || index > this$static.size) && indexOutOfBounds(index, this$static.size);
  splice_0(this$static.array, index, 0, o);
  ++this$static.size;
}

function $add_0(this$static, o){
  setCheck(this$static.array, this$static.size++, o);
  return true;
}

function $get(this$static, index){
  checkIndex(index, this$static.size);
  return this$static.array[index];
}

function $indexOf(this$static, o, index){
  for (; index < this$static.size; ++index) {
    if (equalsWithNullCheck(o, this$static.array[index])) {
      return index;
    }
  }
  return -1;
}

function $remove(this$static, index){
  var previous;
  previous = (checkIndex(index, this$static.size) , this$static.array[index]);
  splice(this$static.array, index, 1);
  --this$static.size;
  return previous;
}

function $remove_0(this$static, o){
  var i;
  i = $indexOf(this$static, o, 0);
  if (i == -1) {
    return false;
  }
  $remove(this$static, i);
  return true;
}

function ArrayList_0(){
  this.array = initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Object, 0, 0);
}

function splice(array, index, deleteCount){
  array.splice(index, deleteCount);
}

function splice_0(array, index, deleteCount, value){
  array.splice(index, deleteCount, value);
}

defineSeed(19, 20, makeCastMap([Q$Serializable, Q$List]), ArrayList_0);
_.add_0 = function add_2(index, o){
  $add(this, index, o);
}
;
_.add = function add_3(o){
  return $add_0(this, o);
}
;
_.contains_0 = function contains_0(o){
  return $indexOf(this, o, 0) != -1;
}
;
_.get = function get(index){
  return $get(this, index);
}
;
_.isEmpty = function isEmpty_0(){
  return this.size == 0;
}
;
_.remove_0 = function remove_2(index){
  return $remove(this, index);
}
;
_.remove = function remove_3(o){
  return $remove_0(this, o);
}
;
_.size_0 = function size_0(){
  return this.size;
}
;
_.size = 0;
function $fireOnPlaybackComplete(this$static, sender){
  var handler, handler$iterator;
  new PlaybackCompleteEvent_0(sender);
  for (handler$iterator = new AbstractList$IteratorImpl_0(this$static); handler$iterator.i < handler$iterator.this$0_0.size_0();) {
    handler = $next_2(handler$iterator);
    handler.this$0.playing = false;
  }
}

function $fireOnSoundLoadStateChange(this$static, sender){
  var event_0, handler, handler$iterator;
  event_0 = new SoundLoadStateChangeEvent_0(sender);
  for (handler$iterator = new AbstractList$IteratorImpl_0(this$static); handler$iterator.i < handler$iterator.this$0_0.size_0();) {
    handler = $next_2(handler$iterator);
    $onSoundLoadStateChange(handler, event_0);
  }
}

function SoundHandlerCollection_0(){
  ArrayList_0.call(this);
}

defineSeed(18, 19, makeCastMap([Q$Serializable, Q$List]), SoundHandlerCollection_0);
function SoundLoadStateChangeEvent_0(source){
  this.source = source;
  this.loadState = source.loadState;
}

defineSeed(22, 17, {}, SoundLoadStateChangeEvent_0);
_.toString$ = function toString_5(){
  var sound;
  sound = this.source;
  return getSimpleName(Lcom_allen_1sauer_gwt_voices_client_handler_SoundLoadStateChangeEvent_2_classLit) + ': ' + sound + '; ' + this.loadState.name_0;
}
;
_.loadState = null;
--></script>
<script><!--
function $clinit_FlashMovie(){
  $clinit_FlashMovie = nullMethod;
  impl_0 = new FlashMovieImplPlayN_0;
}

defineSeed(23, 1, {});
_.element = null;
var impl_0 = null;
function $clinit_VoicesMovie(){
  $clinit_VoicesMovie = nullMethod;
  $clinit_FlashMovie();
  FLASH_SUPPORTED_MIME_TYPES = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['audio/mpeg', 'audio/mpeg; codecs=MP3']);
}

function $callCreateSound(this$static, id, soundURL, checkPolicyFile){
  var elem = this$static.element;
  elem.createSound(id, soundURL, checkPolicyFile);
}

function $getMimeTypeSupport(this$static){
  switch (this$static.flashSupport.ordinal) {
    case 2:
    case 1:
      return contains_1(FLASH_SUPPORTED_MIME_TYPES)?($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY):($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED);
    case 3:
    case 0:
      return this$static.flashSupport;
    default:throw new RuntimeException_1('Unhandled flash support value ' + this$static.flashSupport);
  }
}

function $installFlashCallbackHooks(this$static, id_0){
  $doc.VoicesMovie === undefined && ($doc.VoicesMovie = {});
  var self_0 = this$static;
  $doc.VoicesMovie[id_0] = {};
  $doc.VoicesMovie[id_0].ready = function(){
    self_0.movieReady();
  }
  ;
  $doc.VoicesMovie[id_0].soundLoaded = function(id){
    $clinit_FlashSound();
    $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new FlashSound$2_0(id));
    return true;
  }
  ;
  $doc.VoicesMovie[id_0].playbackCompleted = function(id){
    $clinit_FlashSound();
    $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new FlashSound$1_0(id));
  }
  ;
  $doc.VoicesMovie[id_0].log = function(text){
    self_0.debug('FLASH[' + id_0 + ']: ' + text);
  }
  ;
}

function $movieUnsupported(this$static){
  var flashSound, flashSound$iterator;
  for (flashSound$iterator = new AbstractList$IteratorImpl_0(this$static.unitializedSoundList); flashSound$iterator.i < flashSound$iterator.this$0_0.size_0();) {
    flashSound = $next_2(flashSound$iterator);
    $setLoadState(flashSound, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
  }
}

function $playSound(this$static, id){
  var elem;
  if (this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)) {
    return elem = this$static.element , elem.playSound(id);
  }
  return false;
}

function $registerSound_0(this$static, flashSound){
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)?$callCreateSound(this$static, flashSound.soundNumber, flashSound.url, flashSound.crossOrigin):$add_0(this$static.unitializedSoundList, flashSound);
}

function $setLooping(this$static, id, looping){
  var elem;
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) && (elem = this$static.element , elem.setLooping(id, looping?2147483647:0) , undefined);
}

function $setVolume(this$static, id, volume){
  var elem;
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) && (elem = this$static.element , elem.setVolume(id, volume / 100) , undefined);
}

function VoicesMovie_0(id, gwtVoicesSwfBaseUrl){
  $clinit_VoicesMovie();
  this.element = $createElementMaybeSetURL(impl_0, id, gwtVoicesSwfBaseUrl + 'gwt-voices.swf');
  this.flashSupport = ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_UNKNOWN);
  this.unitializedSoundList = new ArrayList_0;
  $installFlashCallbackHooks(this, id);
  if (impl_0.impl.getMajorVersion() >= 9) {
    this.flashSupport = MIME_TYPE_SUPPORT_NOT_READY;
  }
   else {
    this.flashSupport = MIME_TYPE_NOT_SUPPORTED;
    $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new VoicesMovie$1_0(this));
  }
}

defineSeed(24, 23, {}, VoicesMovie_0);
_.debug = function debug(text){
}
;
_.movieReady = function movieReady(){
  var flashSound, iterator;
  this.flashSupport = ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY);
  for (iterator = new AbstractList$IteratorImpl_0(this.unitializedSoundList); iterator.i < iterator.this$0_0.size_0();) {
    flashSound = $next_2(iterator);
    $callCreateSound(this, flashSound.soundNumber, flashSound.url, flashSound.crossOrigin);
    $remove_8(iterator);
  }
}
;
var FLASH_SUPPORTED_MIME_TYPES;
function VoicesMovie$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(25, 1, {}, VoicesMovie$1_0);
_.execute = function execute_1(){
  $movieUnsupported(this.this$0);
}
;
_.this$0 = null;
defineSeed(26, 1, {});
_.getMajorVersion = function getMajorVersion(){
  var versionString;
  versionString = this.getVersionString();
  return versionString == null?0:__parseAndValidateInt($replaceFirst(versionString, ',.*', ''));
}
;
_.getVersionString = function getVersionString(){
  var rawVersionString;
  rawVersionString = this.getRawVersionString();
  return rawVersionString == null?null:$replaceFirst($replaceAll(rawVersionString, '\\D*(\\d+)', '$1,'), ',$', '');
}
;
function FlashMovieImplIE6_0(){
}

defineSeed(27, 26, {}, FlashMovieImplIE6_0);
_.createElementMaybeSetURL = function createElementMaybeSetURL(id, url){
  var elem = $doc.createElement('object');
  elem.tabIndex = -1;
  elem.id = id;
  elem.classid = 'clsid:d27cdb6e-ae6d-11cf-96b8-444553540000';
  elem.codebase = 'http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0';
  elem.FlashVars = 'id=' + id;
  elem.Movie = url;
  return elem;
}
;
_.getRawVersionString = function getRawVersionString(){
  try {
    return (new ActiveXObject('ShockwaveFlash.ShockwaveFlash')).GetVariable('$version');
  }
   catch (e) {
    return null;
  }
}
;
function $createElementMaybeSetURL(this$static, id, url){
  return this$static.impl.createElementMaybeSetURL(id, url);
}

function FlashMovieImplPlayN_0(){
  $wnd.navigator.userAgent.indexOf('MSIE') != -1?(this.impl = new FlashMovieImplIE6_0):(this.impl = new FlashMovieImplSafari_0);
  $debug(platform_1.log_0, 'CHOSE: ' + this.impl.___clazz$.typeName);
}

defineSeed(28, 26, {}, FlashMovieImplPlayN_0);
_.createElementMaybeSetURL = function createElementMaybeSetURL_0(id, url){
  return this.impl.createElementMaybeSetURL(id, url);
}
;
_.getMajorVersion = function getMajorVersion_0(){
  return this.impl.getMajorVersion();
}
;
_.getRawVersionString = function getRawVersionString_0(){
  return this.impl.getRawVersionString();
}
;
_.getVersionString = function getVersionString_0(){
  return this.impl.getVersionString();
}
;
_.impl = null;
defineSeed(30, 26, {});
_.createElementMaybeSetURL = function createElementMaybeSetURL_1(id, url){
  var elem = $doc.createElement('object');
  elem.setAttribute('id', id);
  elem.setAttribute('type', 'application/x-shockwave-flash');
  elem.setAttribute('data', url);
  var param = $doc.createElement('param');
  param.setAttribute('name', 'FlashVars');
  param.setAttribute('value', 'id=' + id);
  elem.appendChild(param);
  return elem;
}
;
_.getRawVersionString = function getRawVersionString_1(){
  var p = navigator.plugins['Shockwave Flash'];
  return p == null?null:p.description;
}
;
function FlashMovieImplSafari_0(){
}

defineSeed(29, 30, {}, FlashMovieImplSafari_0);
function $createElement(url){
  var elem = $doc.createElement('object');
  elem.setAttribute('data', url);
  elem.setAttribute('autostart', 'true');
  return elem;
}

function $setVolume_0(elem, volume){
  elem.setAttribute('volume', '' + volume);
}

function $play(soundControllerElement, elem){
  var parent_0 = elem.parentNode;
  parent_0 != null && parent_0.removeChild(elem);
  soundControllerElement.appendChild(elem);
  return true;
}

var uniqueId = 1000;
function contains_1(arr){
  var element, element$index, element$max;
  for (element$index = 0 , element$max = arr.length; element$index < element$max; ++element$index) {
    element = arr[element$index];
    if ($equals(element, 'audio/mpeg')) {
      return true;
    }
  }
  return false;
}

function getSimpleName(clazz){
  var name_0;
  name_0 = clazz.typeName;
  return $substring(name_0, $lastIndexOf(name_0, fromCodePoint(46)) + 1);
}

function equals__devirtual$(this$static, other){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.equals$(other):maybeJsoInvocation === other;
}

function getClass__devirtual$(this$static){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.___clazz$:Lcom_google_gwt_core_client_JavaScriptObject_2_classLit;
}

function hashCode__devirtual$(this$static){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.hashCode$():getHashCode(maybeJsoInvocation);
}

function toString__devirtual$(this$static){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.toString$():maybeJsoInvocation.toString?maybeJsoInvocation.toString():'[JavaScriptObject]';
}

function $clearRect(this$static, x, y, w, h_0){
  this$static.clearRect(x, y, w, h_0);
}

function $createPattern(this$static, image, repetition){
  return this$static.createPattern(image, repetition);
}

function $drawImage(this$static, image, dx, dy){
  this$static.drawImage(image, dx, dy);
}

function $drawImage_0(this$static, image, sx, sy, sw, sh, dx, dy, dw, dh){
  this$static.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
}

function $lineTo(this$static, x, y){
  this$static.lineTo(x, y);
}

function $moveTo(this$static, x, y){
  this$static.moveTo(x, y);
}

function $scale(this$static, x, y){
  this$static.scale(x, y);
}

function $setFillStyleWeb(this$static, fillStyle){
  this$static.fillStyle = fillStyle;
}

function $setLineWidth(this$static, lineWidth){
  this$static.lineWidth = lineWidth;
}

function $setStrokeStyleWeb(this$static, strokeStyle){
  this$static.strokeStyle = strokeStyle;
}

function $transform(this$static, m11, m12, m21, m22, dx, dy){
  this$static.transform(m11, m12, m21, m22, dx, dy);
}

function $translate(this$static, x, y){
  this$static.translate(x, y);
}

function $clinit_Context2d$Repetition(){
  $clinit_Context2d$Repetition = nullMethod;
  NO_REPEAT = new Context2d$Repetition_0('NO_REPEAT', 0, 'no-repeat');
  REPEAT = new Context2d$Repetition_0('REPEAT', 1, 'repeat');
  REPEAT_X = new Context2d$Repetition_0('REPEAT_X', 2, 'repeat-x');
  REPEAT_Y = new Context2d$Repetition_0('REPEAT_Y', 3, 'repeat-y');
  $VALUES_2 = initValues(_3Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Context2d$Repetition, [NO_REPEAT, REPEAT, REPEAT_X, REPEAT_Y]);
}

function Context2d$Repetition_0(enum$name, enum$ordinal, value){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.value_0 = value;
}

function values_2(){
  $clinit_Context2d$Repetition();
  return $VALUES_2;
}

defineSeed(40, 11, makeCastMap([Q$Context2d$Repetition, Q$Serializable, Q$Comparable, Q$Enum]), Context2d$Repetition_0);
_.value_0 = null;
var $VALUES_2, NO_REPEAT, REPEAT, REPEAT_X, REPEAT_Y;
function currentTimeMillis(){
  return (new Date).getTime();
}

function setUncaughtExceptionHandler(handler){
  sUncaughtExceptionHandler = handler;
}

var sUncaughtExceptionHandler = null;
function $printStackTrace(this$static){
  var causeMessage, currentCause, msg;
  msg = new StringBuffer_0;
  currentCause = this$static;
  while (currentCause) {
    causeMessage = currentCause.getMessage();
    currentCause != this$static && (msg.impl.string += 'Caused by: ' , msg);
    $append_5(msg, currentCause.___clazz$.typeName);
    msg.impl.string += ': ';
    $append_3(msg.impl, causeMessage == null?'(No exception detail)':causeMessage);
    msg.impl.string += '\n';
    currentCause = currentCause.cause;
  }
}

function $setStackTrace(stackTrace){
  var c, copy, i;
  copy = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$StackTraceElement, stackTrace.length, 0);
  for (i = 0 , c = stackTrace.length; i < c; ++i) {
    if (!stackTrace[i]) {
      throw new NullPointerException_0;
    }
    copy[i] = stackTrace[i];
  }
}

function $toString_0(this$static){
  var className, msg;
  className = this$static.___clazz$.typeName;
  msg = this$static.getMessage();
  return msg != null?className + ': ' + msg:className;
}

function Throwable_0(message, cause){
  $fillInStackTrace($clinit_StackTraceCreator$CollectorChrome());
  this.cause = cause;
  this.detailMessage = message;
}

defineSeed(47, 1, makeCastMap([Q$Serializable, Q$Throwable]));
_.getMessage = function getMessage(){
  return this.detailMessage;
}
;
_.toString$ = function toString_6(){
  return $toString_0(this);
}
;
_.cause = null;
_.detailMessage = null;
defineSeed(46, 47, makeCastMap([Q$Serializable, Q$Exception, Q$Throwable]));
function RuntimeException_0(){
  $fillInStackTrace($clinit_StackTraceCreator$CollectorChrome());
}

function RuntimeException_1(message){
  $fillInStackTrace($clinit_StackTraceCreator$CollectorChrome());
  this.detailMessage = message;
}

function RuntimeException_2(message, cause){
  Throwable_0.call(this, message, cause);
}

function RuntimeException_3(cause){
  $fillInStackTrace($clinit_StackTraceCreator$CollectorChrome());
  this.detailMessage = !cause?null:$toString_0(cause);
  this.cause = cause;
}

defineSeed(45, 46, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), RuntimeException_1, RuntimeException_3);
function JavaScriptException_0(e){
  RuntimeException_0.call(this);
  this.e = e;
  this.description_0 = '';
  $createStackTrace(new StackTraceCreator$CollectorChromeNoSourceMap_0, this);
}

function getExceptionDescription(e){
  return instanceOfJso(e)?e == null?null:e.message:e + '';
}

function getExceptionName(e){
  return e == null?'null':instanceOfJso(e)?e == null?null:e.name:instanceOf(e, Q$String)?'String':getClass__devirtual$(e).typeName;
}

function getExceptionProperties(e){
  return instanceOfJso(e)?$getProperties(($clinit_StackTraceCreator$CollectorChrome() , e)):'';
}

defineSeed(44, 45, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), JavaScriptException_0);
_.getMessage = function getMessage_0(){
  this.message_0 == null && (this.name_0 = getExceptionName(this.e) , this.description_0 = this.description_0 + ': ' + getExceptionDescription(this.e) , this.message_0 = '(' + this.name_0 + ') ' + getExceptionProperties(this.e) + this.description_0 , undefined);
  return this.message_0;
}
;
_.description_0 = '';
_.e = null;
_.message_0 = null;
_.name_0 = null;
function $push(this$static, value){
  this$static[this$static.length] = value;
}

function $push_0(this$static, value){
  this$static[this$static.length] = value;
}

function $push_1(this$static, value){
  this$static[this$static.length] = value;
}

defineSeed(53, 1, {});
function apply(jsFunction, thisObj, arguments_0){
  return jsFunction.apply(thisObj, arguments_0);
  var __0;
}

function enter(){
  var now;
  if (entryDepth != 0) {
    now = currentTimeMillis();
    if (now - watchdogEntryDepthLastScheduled > 2000) {
      watchdogEntryDepthLastScheduled = now;
      watchdogEntryDepthTimerId = watchdogEntryDepthSchedule();
    }
  }
  if (entryDepth++ == 0) {
    $flushEntryCommands(($clinit_SchedulerImpl() , INSTANCE));
    return true;
  }
  return false;
}

function entry_0(jsFunction){
  return function(){
    try {
      return entry0(jsFunction, this, arguments);
    }
     catch (e) {
      throw e;
    }
  }
  ;
}

function entry0(jsFunction, thisObj, arguments_0){
  var $e0, initialEntry, t;
  initialEntry = enter();
  try {
    if (sUncaughtExceptionHandler) {
      try {
        return apply(jsFunction, thisObj, arguments_0);
      }
       catch ($e0) {
        $e0 = caught_0($e0);
        if (instanceOf($e0, Q$Throwable)) {
          t = $e0;
          $error_0(($clinit_HtmlPlatform() , log_0), 'Uncaught Exception: ', t);
          return undefined;
        }
         else 
          throw $e0;
      }
    }
     else {
      return apply(jsFunction, thisObj, arguments_0);
    }
  }
   finally {
    exit(initialEntry);
  }
}

function exit(initialEntry){
  initialEntry && $flushFinallyCommands(($clinit_SchedulerImpl() , INSTANCE));
  --entryDepth;
  if (initialEntry) {
    if (watchdogEntryDepthTimerId != -1) {
      watchdogEntryDepthCancel(watchdogEntryDepthTimerId);
      watchdogEntryDepthTimerId = -1;
    }
  }
}

function getHashCode(o){
  return o.$H || (o.$H = ++sNextHashId);
}

function watchdogEntryDepthCancel(timerId){
  $wnd.clearTimeout(timerId);
}

function watchdogEntryDepthSchedule(){
  return $wnd.setTimeout(function(){
    entryDepth != 0 && (entryDepth = 0);
    watchdogEntryDepthTimerId = -1;
  }
  , 10);
}

var entryDepth = 0, sNextHashId = 0, watchdogEntryDepthLastScheduled = 0, watchdogEntryDepthTimerId = -1;
function $clinit_SchedulerImpl(){
  $clinit_SchedulerImpl = nullMethod;
  INSTANCE = new SchedulerImpl_0;
}

function $flushEntryCommands(this$static){
  var oldQueue, rescheduled;
  if (this$static.entryCommands) {
    rescheduled = null;
    do {
      oldQueue = this$static.entryCommands;
      this$static.entryCommands = null;
      rescheduled = runScheduledTasks(oldQueue, rescheduled);
    }
     while (this$static.entryCommands);
    this$static.entryCommands = rescheduled;
  }
}

function $flushFinallyCommands(this$static){
  var oldQueue, rescheduled;
  if (this$static.finallyCommands) {
    rescheduled = null;
    do {
      oldQueue = this$static.finallyCommands;
      this$static.finallyCommands = null;
      rescheduled = runScheduledTasks(oldQueue, rescheduled);
    }
     while (this$static.finallyCommands);
    this$static.finallyCommands = rescheduled;
  }
}

function $flushPostEventPumpCommands(this$static){
  var oldDeferred;
  if (this$static.deferredCommands) {
    oldDeferred = this$static.deferredCommands;
    this$static.deferredCommands = null;
    !this$static.incrementalCommands && (this$static.incrementalCommands = []);
    runScheduledTasks(oldDeferred, this$static.incrementalCommands);
  }
  !!this$static.incrementalCommands && (this$static.incrementalCommands = runRepeatingTasks(this$static.incrementalCommands));
}

function $isWorkQueued(this$static){
  return !!this$static.deferredCommands || !!this$static.incrementalCommands;
}

function $maybeSchedulePostEventPumpCommands(this$static){
  if (!this$static.shouldBeRunning) {
    this$static.shouldBeRunning = true;
    !this$static.flusher && (this$static.flusher = new SchedulerImpl$Flusher_0(this$static));
    scheduleFixedDelayImpl(this$static.flusher, 1);
    !this$static.rescue && (this$static.rescue = new SchedulerImpl$Rescuer_0(this$static));
    scheduleFixedDelayImpl(this$static.rescue, 50);
  }
}

function $scheduleDeferred(this$static, cmd){
  this$static.deferredCommands = push(this$static.deferredCommands, [cmd, false]);
  $maybeSchedulePostEventPumpCommands(this$static);
}

function SchedulerImpl_0(){
}

function execute_2(cmd){
  return cmd.execute_0();
}

function push(queue, task){
  !queue && (queue = []);
  $push(queue, task);
  return queue;
}

function runRepeatingTasks(tasks){
  var canceledSomeTasks, i, length_0, newTasks, start, t;
  length_0 = tasks.length;
  if (length_0 == 0) {
    return null;
  }
  canceledSomeTasks = false;
  start = currentTimeMillis();
  while (currentTimeMillis() - start < 100) {
    for (i = 0; i < length_0; ++i) {
      t = tasks[i];
      if (!t) {
        continue;
      }
      if (!t[0].execute_0()) {
        tasks[i] = null;
        canceledSomeTasks = true;
      }
    }
  }
  if (canceledSomeTasks) {
    newTasks = [];
    for (i = 0; i < length_0; ++i) {
      !!tasks[i] && (newTasks[newTasks.length] = tasks[i] , undefined);
    }
    return newTasks.length == 0?null:newTasks;
  }
   else {
    return tasks;
  }
}

function runScheduledTasks(tasks, rescheduled){
  var $e0, e, i, j, t;
  for (i = 0 , j = tasks.length; i < j; ++i) {
    t = tasks[i];
    try {
      t[1]?t[0].execute_0() && (rescheduled = push(rescheduled, t)):t[0].execute();
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$Throwable)) {
        e = $e0;
        !!sUncaughtExceptionHandler && $error_0(($clinit_HtmlPlatform() , log_0), 'Uncaught Exception: ', e);
      }
       else 
        throw $e0;
    }
  }
  return rescheduled;
}

function scheduleFixedDelayImpl(cmd, delayMs){
  $clinit_SchedulerImpl();
  $wnd.setTimeout(function(){
    var ret = $entry(execute_2)(cmd);
    ret && $wnd.setTimeout(arguments.callee, delayMs);
  }
  , delayMs);
}

defineSeed(55, 53, {}, SchedulerImpl_0);
_.deferredCommands = null;
_.entryCommands = null;
_.finallyCommands = null;
_.flushRunning = false;
_.flusher = null;
_.incrementalCommands = null;
_.rescue = null;
_.shouldBeRunning = false;
var INSTANCE;
function SchedulerImpl$Flusher_0(this$0){
  this.this$0 = this$0;
}

defineSeed(56, 1, {}, SchedulerImpl$Flusher_0);
_.execute_0 = function execute_3(){
  this.this$0.flushRunning = true;
  $flushPostEventPumpCommands(this.this$0);
  this.this$0.flushRunning = false;
  return this.this$0.shouldBeRunning = $isWorkQueued(this.this$0);
}
;
_.this$0 = null;
function SchedulerImpl$Rescuer_0(this$0){
  this.this$0 = this$0;
}

defineSeed(57, 1, {}, SchedulerImpl$Rescuer_0);
_.execute_0 = function execute_4(){
  this.this$0.flushRunning && scheduleFixedDelayImpl(this.this$0.flusher, 1);
  return this.this$0.shouldBeRunning;
}
;
_.this$0 = null;
function extractNameFromToString(fnToString){
  var index, start, toReturn;
  toReturn = '';
  fnToString = $trim(fnToString);
  index = fnToString.indexOf('(');
  start = fnToString.indexOf('function') == 0?8:0;
  if (index == -1) {
    index = $indexOf_1(fnToString, fromCodePoint(64));
    start = fnToString.indexOf('function ') == 0?9:0;
  }
  index != -1 && (toReturn = $trim(fnToString.substr(start, index - start)));
  return toReturn.length > 0?toReturn:'anonymous';
}

function parseInt_0(number){
  return parseInt(number) || -1;
}

function splice_1(arr, length_0){
  arr.length >= length_0 && arr.splice(0, length_0);
  return arr;
}

function $getProperties(e){
  var result = '';
  try {
    for (var prop in e) {
      if (prop != 'name' && prop != 'message' && prop != 'toString') {
        try {
          result += '\n ' + prop + ': ' + e[prop];
        }
         catch (ignored) {
        }
      }
    }
  }
   catch (ignored) {
  }
  return result;
}

function $makeException(){
  try {
    null.a();
  }
   catch (e) {
    return e;
  }
}

function StackTraceCreator$Collector_0(){
}

defineSeed(60, 1, {}, StackTraceCreator$Collector_0);
_.collect = function collect(){
  var seen = {};
  var toReturn = [];
  var callee = arguments.callee.caller.caller;
  while (callee) {
    var name_0 = this.extractName(callee.toString());
    toReturn.push(name_0);
    var keyName = ':' + name_0;
    var withThisName = seen[keyName];
    if (withThisName) {
      var i, j;
      for (i = 0 , j = withThisName.length; i < j; i++) {
        if (withThisName[i] === callee) {
          return toReturn;
        }
      }
    }
    (withThisName || (seen[keyName] = [])).push(callee);
    callee = callee.caller;
  }
  return toReturn;
}
;
_.extractName = function extractName(fnToString){
  return extractNameFromToString(fnToString);
}
;
_.inferFrom = function inferFrom(e){
  return [];
}
;
function $inferFrom(this$static, e){
  var i, j, stack;
  stack = e && e.stack?e.stack.split('\n'):[];
  for (i = 0 , j = stack.length; i < j; ++i) {
    stack[i] = this$static.extractName(stack[i]);
  }
  return stack;
}

defineSeed(62, 60, {});
_.collect = function collect_0(){
  return splice_1(this.inferFrom($makeException()), this.toSplice());
}
;
_.inferFrom = function inferFrom_0(e){
  return $inferFrom(this, e);
}
;
_.toSplice = function toSplice(){
  return 2;
}
;
function $clinit_StackTraceCreator$CollectorChrome(){
  $clinit_StackTraceCreator$CollectorChrome = nullMethod;
  Error.stackTraceLimit = 128;
}

function $collect(this$static){
  var res;
  res = splice_1($inferFrom_0(this$static, $makeException()), 3);
  res.length == 0 && (res = splice_1((new StackTraceCreator$Collector_0).collect(), 1));
  return res;
}

function $createStackTrace(this$static, e){
  var stack;
  stack = $inferFrom_0(this$static, instanceOfJso(e.e)?e.e:null);
  $parseStackTrace(stack);
}

function $fillInStackTrace(){
  var stack;
  stack = $collect(new StackTraceCreator$CollectorChromeNoSourceMap_0);
  $parseStackTrace(stack);
}

function $inferFrom_0(this$static, e){
  var stack;
  stack = $inferFrom(this$static, e);
  return stack.length == 0?(new StackTraceCreator$Collector_0).inferFrom(e):splice_1(stack, 1);
}

function $parseStackTrace(stack){
  var col, endFileUrl, fileName, i, j, lastColon, location_0, stackElements, stackTrace;
  stackTrace = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$StackTraceElement, stack.length, 0);
  for (i = 0 , j = stackTrace.length; i < j; ++i) {
    stackElements = $split(stack[i], '@@', 0);
    col = -1;
    fileName = 'Unknown';
    if (stackElements.length == 2 && stackElements[1] != null) {
      location_0 = stackElements[1];
      lastColon = $lastIndexOf(location_0, fromCodePoint(58));
      endFileUrl = $lastIndexOf_0(location_0, fromCodePoint(58), lastColon - 1);
      fileName = location_0.substr(0, endFileUrl - 0);
      if (lastColon != -1 && endFileUrl != -1) {
        parseInt_0(location_0.substr(endFileUrl + 1, lastColon - (endFileUrl + 1)));
        col = parseInt_0($substring(location_0, lastColon + 1));
      }
    }
    stackTrace[i] = new StackTraceElement_0(stackElements[0], fileName + '@' + col);
  }
  $setStackTrace(stackTrace);
}

defineSeed(61, 62, {});
_.collect = function collect_1(){
  return $collect(this);
}
;
_.extractName = function extractName_0(fnToString){
  var closeParen, index, location_0, toReturn;
  if (fnToString.length == 0) {
    return 'anonymous';
  }
  toReturn = $trim(fnToString);
  toReturn.indexOf('at ') == 0 && (toReturn = $substring(toReturn, 3));
  index = toReturn.indexOf('[');
  index != -1 && (toReturn = $trim(toReturn.substr(0, index - 0)) + $trim($substring(toReturn, toReturn.indexOf(']', index) + 1)));
  index = toReturn.indexOf('(');
  if (index == -1) {
    location_0 = toReturn;
    toReturn = '';
  }
   else {
    closeParen = toReturn.indexOf(')', index);
    location_0 = toReturn.substr(index + 1, closeParen - (index + 1));
    toReturn = $trim(toReturn.substr(0, index - 0));
  }
  index = $indexOf_1(toReturn, fromCodePoint(46));
  index != -1 && (toReturn = $substring(toReturn, index + 1));
  return (toReturn.length > 0?toReturn:'anonymous') + '@@' + location_0;
}
;
_.inferFrom = function inferFrom_1(e){
  return $inferFrom_0(this, e);
}
;
_.toSplice = function toSplice_0(){
  return 3;
}
;
function StackTraceCreator$CollectorChromeNoSourceMap_0(){
  $clinit_StackTraceCreator$CollectorChrome();
}

defineSeed(63, 61, {}, StackTraceCreator$CollectorChromeNoSourceMap_0);
defineSeed(64, 1, {});
function $append(this$static, x){
  this$static.string += x;
}

function $append_0(this$static, x){
  this$static.string += x;
}

function $append_1(this$static, x){
  this$static.string += x;
}

function $append_2(this$static, x){
  this$static.string += x;
}

function $append_3(this$static, x){
  this$static.string += x;
}

function $appendNonNull(this$static, x){
  this$static.string += x;
}

function $replace(this$static, start, end){
  this$static.string = $substring_0(this$static.string, 0, start) + '' + $substring(this$static.string, end);
}

function StringBufferImplAppend_0(){
}

defineSeed(65, 64, {}, StringBufferImplAppend_0);
_.string = '';
function $appendChild(this$static, newChild){
  return this$static.appendChild(newChild);
}

function $getChild(this$static, index){
  return this$static.childNodes[index];
}

function $insertBefore(this$static, newChild, refChild){
  return this$static.insertBefore(newChild, refChild);
}

function $removeChild(this$static, oldChild){
  return this$static.removeChild(oldChild);
}

function $setBooleanAttr(this$static, value){
  value?(this$static.setAttribute('loop', '') , undefined):(this$static.removeAttribute('loop') , undefined);
}

function $setSrc(this$static, url){
  this$static.src = url;
}

function $setVolume_1(this$static, volume){
  this$static.volume = volume;
}

function $setHeight(this$static, height){
  this$static.height = height;
}

function $setWidth(this$static, width){
  this$static.width = width;
}

function $eventGetButton(evt){
  var button = evt.button;
  if (button == 1) {
    return 4;
  }
   else if (button == 2) {
    return 2;
  }
  return 1;
}

function $isOrHasChild(parent_0, child){
  return parent_0.contains(child);
}

function $getAbsoluteLeft(elem){
  var rect;
  rect = getBoundingClientRect(elem);
  return rect?rect.left + $getScrollLeft(elem.ownerDocument.body):getAbsoluteLeftUsingOffsets(elem);
}

function $getAbsoluteTop(elem){
  var rect;
  rect = getBoundingClientRect(elem);
  return rect?rect.top + (elem.ownerDocument.body.scrollTop || 0):getAbsoluteTopUsingOffsets(elem);
}

function $getScrollLeft(elem){
  if (elem.ownerDocument.defaultView.getComputedStyle(elem, '').direction == 'rtl') {
    return (elem.scrollLeft || 0) - ((elem.scrollWidth || 0) - elem.clientWidth);
  }
  return elem.scrollLeft || 0;
}

function $getTabIndex(elem){
  return typeof elem.tabIndex != 'undefined'?elem.tabIndex:-1;
}

--></script>
<script><!--
function getAbsoluteLeftUsingOffsets(elem){
  if (elem.offsetLeft == null) {
    return 0;
  }
  var left = 0;
  var doc = elem.ownerDocument;
  var curr = elem.parentNode;
  if (curr) {
    while (curr.offsetParent) {
      left -= curr.scrollLeft;
      doc.defaultView.getComputedStyle(curr, '').getPropertyValue('direction') == 'rtl' && (left += curr.scrollWidth - curr.clientWidth);
      curr = curr.parentNode;
    }
  }
  while (elem) {
    left += elem.offsetLeft;
    if (doc.defaultView.getComputedStyle(elem, '')['position'] == 'fixed') {
      left += doc.body.scrollLeft;
      return left;
    }
    var parent_0 = elem.offsetParent;
    parent_0 && $wnd.devicePixelRatio && (left += parseInt(doc.defaultView.getComputedStyle(parent_0, '').getPropertyValue('border-left-width')));
    if (parent_0 && parent_0.tagName == 'BODY' && elem.style.position == 'absolute') {
      break;
    }
    elem = parent_0;
  }
  return left;
}

function getAbsoluteTopUsingOffsets(elem){
  if (elem.offsetTop == null) {
    return 0;
  }
  var top_0 = 0;
  var doc = elem.ownerDocument;
  var curr = elem.parentNode;
  if (curr) {
    while (curr.offsetParent) {
      top_0 -= curr.scrollTop;
      curr = curr.parentNode;
    }
  }
  while (elem) {
    top_0 += elem.offsetTop;
    if (doc.defaultView.getComputedStyle(elem, '')['position'] == 'fixed') {
      top_0 += doc.body.scrollTop;
      return top_0;
    }
    var parent_0 = elem.offsetParent;
    parent_0 && $wnd.devicePixelRatio && (top_0 += parseInt(doc.defaultView.getComputedStyle(parent_0, '').getPropertyValue('border-top-width')));
    if (parent_0 && parent_0.tagName == 'BODY' && elem.style.position == 'absolute') {
      break;
    }
    elem = parent_0;
  }
  return top_0;
}

function getBoundingClientRect(element){
  return element.getBoundingClientRect && element.getBoundingClientRect();
}

function $clinit_Style$Overflow(){
  $clinit_Style$Overflow = nullMethod;
  VISIBLE = new Style$Overflow$1_0;
  HIDDEN = new Style$Overflow$2_0;
  SCROLL = new Style$Overflow$3_0;
  AUTO = new Style$Overflow$4_0;
  $VALUES_3 = initValues(_3Lcom_google_gwt_dom_client_Style$Overflow_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Overflow, [VISIBLE, HIDDEN, SCROLL, AUTO]);
}

function values_3(){
  $clinit_Style$Overflow();
  return $VALUES_3;
}

defineSeed(83, 11, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_3, AUTO, HIDDEN, SCROLL, VISIBLE;
function Style$Overflow$1_0(){
  Enum_0.call(this, 'VISIBLE', 0);
}

defineSeed(84, 83, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$1_0);
function Style$Overflow$2_0(){
  Enum_0.call(this, 'HIDDEN', 1);
}

defineSeed(85, 83, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$2_0);
function Style$Overflow$3_0(){
  Enum_0.call(this, 'SCROLL', 2);
}

defineSeed(86, 83, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$3_0);
function Style$Overflow$4_0(){
  Enum_0.call(this, 'AUTO', 3);
}

defineSeed(87, 83, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$4_0);
function $clinit_Style$Position(){
  $clinit_Style$Position = nullMethod;
  STATIC = new Style$Position$1_0;
  RELATIVE = new Style$Position$2_0;
  ABSOLUTE = new Style$Position$3_0;
  FIXED = new Style$Position$4_0;
  $VALUES_4 = initValues(_3Lcom_google_gwt_dom_client_Style$Position_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Position, [STATIC, RELATIVE, ABSOLUTE, FIXED]);
}

function values_4(){
  $clinit_Style$Position();
  return $VALUES_4;
}

defineSeed(88, 11, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_4, ABSOLUTE, FIXED, RELATIVE, STATIC;
function Style$Position$1_0(){
  Enum_0.call(this, 'STATIC', 0);
}

defineSeed(89, 88, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$1_0);
function Style$Position$2_0(){
  Enum_0.call(this, 'RELATIVE', 1);
}

defineSeed(90, 88, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$2_0);
function Style$Position$3_0(){
  Enum_0.call(this, 'ABSOLUTE', 2);
}

defineSeed(91, 88, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$3_0);
function Style$Position$4_0(){
  Enum_0.call(this, 'FIXED', 3);
}

defineSeed(92, 88, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$4_0);
function $clinit_Style$Unit(){
  $clinit_Style$Unit = nullMethod;
  PX = new Style$Unit$1_0;
  PCT = new Style$Unit$2_0;
  EM = new Style$Unit$3_0;
  EX = new Style$Unit$4_0;
  PT = new Style$Unit$5_0;
  PC = new Style$Unit$6_0;
  IN = new Style$Unit$7_0;
  CM = new Style$Unit$8_0;
  MM = new Style$Unit$9_0;
  $VALUES_5 = initValues(_3Lcom_google_gwt_dom_client_Style$Unit_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Unit, [PX, PCT, EM, EX, PT, PC, IN, CM, MM]);
}

function values_5(){
  $clinit_Style$Unit();
  return $VALUES_5;
}

defineSeed(93, 11, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_5, CM, EM, EX, IN, MM, PC, PCT, PT, PX;
function Style$Unit$1_0(){
  Enum_0.call(this, 'PX', 0);
}

defineSeed(94, 93, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$1_0);
function Style$Unit$2_0(){
  Enum_0.call(this, 'PCT', 1);
}

defineSeed(95, 93, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$2_0);
function Style$Unit$3_0(){
  Enum_0.call(this, 'EM', 2);
}

defineSeed(96, 93, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$3_0);
function Style$Unit$4_0(){
  Enum_0.call(this, 'EX', 3);
}

defineSeed(97, 93, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$4_0);
function Style$Unit$5_0(){
  Enum_0.call(this, 'PT', 4);
}

defineSeed(98, 93, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$5_0);
function Style$Unit$6_0(){
  Enum_0.call(this, 'PC', 5);
}

defineSeed(99, 93, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$6_0);
function Style$Unit$7_0(){
  Enum_0.call(this, 'IN', 6);
}

defineSeed(100, 93, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$7_0);
function Style$Unit$8_0(){
  Enum_0.call(this, 'CM', 7);
}

defineSeed(101, 93, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$8_0);
function Style$Unit$9_0(){
  Enum_0.call(this, 'MM', 8);
}

defineSeed(102, 93, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$9_0);
function $clinit_Style$Visibility(){
  $clinit_Style$Visibility = nullMethod;
  VISIBLE_0 = new Style$Visibility$1_0;
  HIDDEN_0 = new Style$Visibility$2_0;
  $VALUES_6 = initValues(_3Lcom_google_gwt_dom_client_Style$Visibility_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Visibility, [VISIBLE_0, HIDDEN_0]);
}

function values_6(){
  $clinit_Style$Visibility();
  return $VALUES_6;
}

defineSeed(103, 11, makeCastMap([Q$Style$HasCssName, Q$Style$Visibility, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_6, HIDDEN_0, VISIBLE_0;
function Style$Visibility$1_0(){
  Enum_0.call(this, 'VISIBLE', 0);
}

defineSeed(104, 103, makeCastMap([Q$Style$HasCssName, Q$Style$Visibility, Q$Serializable, Q$Comparable, Q$Enum]), Style$Visibility$1_0);
function Style$Visibility$2_0(){
  Enum_0.call(this, 'HIDDEN', 1);
}

defineSeed(105, 103, makeCastMap([Q$Style$HasCssName, Q$Style$Visibility, Q$Serializable, Q$Comparable, Q$Enum]), Style$Visibility$2_0);
function $getRelativeX(this$static, target){
  return this$static.clientX - $getAbsoluteLeft(target) + $getScrollLeft(target) + $getScrollLeft(target.ownerDocument.body);
}

function $getRelativeY(this$static, target){
  return this$static.clientY - $getAbsoluteTop(target) + (target.scrollTop || 0) + (target.ownerDocument.body.scrollTop || 0);
}

defineSeed(109, 1, {});
_.toString$ = function toString_7(){
  return 'An event type';
}
;
_.source = null;
function $overrideSource(this$static, source){
  this$static.source = source;
}

defineSeed(108, 109, {});
_.dead = false;
function $setNativeEvent(this$static, nativeEvent){
  this$static.nativeEvent = nativeEvent;
}

function $setRelativeElement(this$static, relativeElem){
  this$static.relativeElem = relativeElem;
}

function fireNativeEvent(nativeEvent, handlerSource, relativeElem){
  var currentNative, currentRelativeElem, typeKey;
  if (registered) {
    typeKey = $unsafeGet(registered, nativeEvent.type);
    if (typeKey) {
      currentNative = typeKey.flyweight.nativeEvent;
      currentRelativeElem = typeKey.flyweight.relativeElem;
      $setNativeEvent(typeKey.flyweight, nativeEvent);
      $setRelativeElement(typeKey.flyweight, relativeElem);
      $fireEvent_0(handlerSource, typeKey.flyweight);
      $setNativeEvent(typeKey.flyweight, currentNative);
      $setRelativeElement(typeKey.flyweight, currentRelativeElem);
    }
  }
}

defineSeed(107, 108, {});
_.getAssociatedType = function getAssociatedType(){
  return $clinit_EndedEvent() , TYPE;
}
;
_.nativeEvent = null;
_.relativeElem = null;
var registered = null;
defineSeed(112, 1, {});
_.hashCode$ = function hashCode_3(){
  return this.index_0;
}
;
_.toString$ = function toString_8(){
  return 'Event type';
}
;
_.index_0 = 0;
var nextHashCode = 0;
function GwtEvent$Type_0(){
  this.index_0 = ++nextHashCode;
}

defineSeed(111, 112, {}, GwtEvent$Type_0);
function DomEvent$Type_0(flyweight){
  GwtEvent$Type_0.call(this);
  this.flyweight = flyweight;
  !registered && (registered = new PrivateMap_0);
  registered.map['ended'] = this;
  this.name_0 = 'ended';
}

defineSeed(110, 111, {}, DomEvent$Type_0);
_.flyweight = null;
_.name_0 = null;
function $clinit_EndedEvent(){
  $clinit_EndedEvent = nullMethod;
  TYPE = new DomEvent$Type_0(new EndedEvent_0);
}

function EndedEvent_0(){
}

defineSeed(113, 107, {}, EndedEvent_0);
_.dispatch = function dispatch(handler){
  $fireOnPlaybackComplete(handler.this$0.soundHandlerCollection, handler.this$0);
}
;
var TYPE;
function $unsafeGet(this$static, key){
  return this$static.map[key];
}

function PrivateMap_0(){
  this.map = {};
}

defineSeed(114, 1, {}, PrivateMap_0);
_.map = null;
function CloseEvent_0(){
}

function fire(source){
  var event_0;
  if (TYPE_0) {
    event_0 = new CloseEvent_0;
    $fireEvent(source, event_0);
  }
}

defineSeed(116, 108, {}, CloseEvent_0);
_.dispatch = function dispatch_0(handler){
  detachWidgets();
}
;
_.getAssociatedType = function getAssociatedType_0(){
  return TYPE_0;
}
;
var TYPE_0 = null;
function $addHandler(this$static, type, handler){
  return new LegacyHandlerWrapper_0($doAdd(this$static.eventBus, type, handler));
}

function $fireEvent(this$static, event_0){
  var $e0, e, oldSource;
  !event_0.dead || (event_0.dead = false , event_0.source = null);
  oldSource = event_0.source;
  $overrideSource(event_0, this$static.source);
  try {
    $doFire(this$static.eventBus, event_0);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$UmbrellaException)) {
      e = $e0;
      throw new UmbrellaException_2(e.causes);
    }
     else 
      throw $e0;
  }
   finally {
    oldSource == null?(event_0.dead = true , event_0.source = null):(event_0.source = oldSource);
  }
}

function HandlerManager_0(source){
  this.eventBus = new HandlerManager$Bus_0;
  this.source = source;
}

defineSeed(117, 1, makeCastMap([Q$HasHandlers]), HandlerManager_0);
_.eventBus = null;
_.source = null;
defineSeed(120, 1, {});
function $defer(this$static, command){
  !this$static.deferredDeltas && (this$static.deferredDeltas = new ArrayList_0);
  $add_0(this$static.deferredDeltas, command);
}

function $doAdd(this$static, type, handler){
  if (!type) {
    throw new NullPointerException_1('Cannot add a handler with a null type');
  }
  if (!handler) {
    throw new NullPointerException_1('Cannot add a null handler');
  }
  this$static.firingDepth > 0?$defer(this$static, new SimpleEventBus$2_0(this$static, type, handler)):$doAddNow(this$static, type, null, handler);
  return new SimpleEventBus$1_0(this$static, type, handler);
}

function $doAddNow(this$static, type, source, handler){
  var l_0;
  l_0 = $ensureHandlerList(this$static, type, source);
  l_0.add(handler);
}

function $doFire(this$static, event_0){
  var $e0, causes, e, handler, handlers, it;
  if (!event_0) {
    throw new NullPointerException_1('Cannot fire null event');
  }
  try {
    ++this$static.firingDepth;
    handlers = $getDispatchList(this$static, event_0.getAssociatedType());
    causes = null;
    it = this$static.isReverseOrder?handlers.listIterator_0(handlers.size_0()):handlers.listIterator();
    while (this$static.isReverseOrder?it.i > 0:it.i < it.this$0_0.size_0()) {
      handler = this$static.isReverseOrder?$previous(it):$next_2(it);
      try {
        event_0.dispatch(handler);
      }
       catch ($e0) {
        $e0 = caught_0($e0);
        if (instanceOf($e0, Q$Throwable)) {
          e = $e0;
          !causes && (causes = new HashSet_0);
          $add_4(causes, e);
        }
         else 
          throw $e0;
      }
    }
    if (causes) {
      throw new UmbrellaException_1(causes);
    }
  }
   finally {
    --this$static.firingDepth;
    this$static.firingDepth == 0 && $handleQueuedAddsAndRemoves(this$static);
  }
}

function $doRemoveNow(this$static, type, source, handler){
  var l_0, removed, sourceMap;
  l_0 = $getHandlerList(this$static, type, source);
  removed = l_0.remove(handler);
  removed && l_0.isEmpty() && (sourceMap = $get_6(this$static.map, type) , sourceMap.remove_1(source) , sourceMap.isEmpty() && $remove_6(this$static.map, type) , undefined);
}

function $ensureHandlerList(this$static, type, source){
  var handlers, sourceMap;
  sourceMap = $get_6(this$static.map, type);
  if (!sourceMap) {
    sourceMap = new HashMap_0;
    $put_2(this$static.map, type, sourceMap);
  }
  handlers = sourceMap.get_0(source);
  if (!handlers) {
    handlers = new ArrayList_0;
    sourceMap.put(source, handlers);
  }
  return handlers;
}

function $getDispatchList(this$static, type){
  var directHandlers;
  directHandlers = $getHandlerList(this$static, type, null);
  return directHandlers;
}

function $getHandlerList(this$static, type, source){
  var handlers, sourceMap;
  sourceMap = $get_6(this$static.map, type);
  if (!sourceMap) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
  handlers = sourceMap.get_0(source);
  if (!handlers) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
  return handlers;
}

function $handleQueuedAddsAndRemoves(this$static){
  var c, c$iterator;
  if (this$static.deferredDeltas) {
    try {
      for (c$iterator = new AbstractList$IteratorImpl_0(this$static.deferredDeltas); c$iterator.i < c$iterator.this$0_0.size_0();) {
        c = $next_2(c$iterator);
        c.execute();
      }
    }
     finally {
      this$static.deferredDeltas = null;
    }
  }
}

defineSeed(119, 120, {});
_.deferredDeltas = null;
_.firingDepth = 0;
_.isReverseOrder = false;
function $doRemove(this$static, type, source, handler){
  this$static.firingDepth > 0?$defer(this$static, new SimpleEventBus$3_0(this$static, type, source, handler)):$doRemoveNow(this$static, type, source, handler);
}

function HandlerManager$Bus_0(){
  this.map = new HashMap_0;
  this.isReverseOrder = false;
}

defineSeed(118, 119, {}, HandlerManager$Bus_0);
function LegacyHandlerWrapper_0(real){
  this.real = real;
}

defineSeed(121, 1, {}, LegacyHandlerWrapper_0);
_.real = null;
function UmbrellaException_1(causes){
  RuntimeException_2.call(this, makeMessage(causes), makeCause(causes));
  this.causes = causes;
}

function makeCause(causes){
  var iterator;
  iterator = causes.iterator();
  if (!iterator.hasNext()) {
    return null;
  }
  return iterator.next_0();
}

function makeMessage(causes){
  var b, count, first, t, t$iterator;
  count = causes.size_0();
  if (count == 0) {
    return null;
  }
  b = new StringBuilder_1(count == 1?'Exception caught: ':count + ' exceptions caught: ');
  first = true;
  for (t$iterator = causes.iterator(); t$iterator.hasNext();) {
    t = t$iterator.next_0();
    first?(first = false):(b.impl.string += '; ' , b);
    $append_11(b, t.getMessage());
  }
  return b.impl.string;
}

defineSeed(123, 45, makeCastMap([Q$UmbrellaException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), UmbrellaException_1);
_.causes = null;
function UmbrellaException_2(causes){
  UmbrellaException_1.call(this, causes);
}

defineSeed(122, 123, makeCastMap([Q$UmbrellaException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), UmbrellaException_2);
function throwIfNull(value){
  if (null == value) {
    throw new NullPointerException_1('encodedURLComponent cannot be null');
  }
}

function Array_0(){
}

function createFromSeed(seedType, length_0){
  var array = new Array(length_0);
  if (seedType == 3) {
    for (var i = 0; i < length_0; ++i) {
      var value = new Object;
      value.l = value.m = value.h = 0;
      array[i] = value;
    }
  }
   else if (seedType > 0) {
    var value = [null, 0, false][seedType];
    for (var i = 0; i < length_0; ++i) {
      array[i] = value;
    }
  }
  return array;
}

function initDim(arrayClass, castableTypeMap, queryId, length_0, seedType){
  var result;
  result = createFromSeed(seedType, length_0);
  initValues(arrayClass, castableTypeMap, queryId, result);
  return result;
}

function initDims(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, count, seedType){
  return initDims_0(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, 0, count, seedType);
}

function initDims_0(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, index, count, seedType){
  var i, isLastDim, length_0, result;
  length_0 = dimExprs[index];
  isLastDim = index == count - 1;
  result = createFromSeed(isLastDim?seedType:0, length_0);
  initValues(arrayClasses[index], castableTypeMapExprs[index], queryIdExprs[index], result);
  if (!isLastDim) {
    ++index;
    for (i = 0; i < length_0; ++i) {
      result[i] = initDims_0(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, index, count, seedType);
    }
  }
  return result;
}

function initValues(arrayClass, castableTypeMap, queryId, array){
  $clinit_Array$ExpandoWrapper();
  wrapArray(array, expandoNames_0, expandoValues_0);
  array.___clazz$ = arrayClass;
  array.castableTypeMap$ = castableTypeMap;
  array.queryId$ = queryId;
  return array;
}

function setCheck(array, index, value){
  if (value != null) {
    if (array.queryId$ > 0 && !canCastUnsafe(value, array.queryId$)) {
      throw new ArrayStoreException_0;
    }
     else if (array.queryId$ == -1 && (value.typeMarker$ == nullMethod || canCast(value, 1))) {
      throw new ArrayStoreException_0;
    }
     else if (array.queryId$ < -1 && !(value.typeMarker$ != nullMethod && !canCast(value, 1)) && !canCastUnsafe(value, -array.queryId$)) {
      throw new ArrayStoreException_0;
    }
  }
  return array[index] = value;
}

defineSeed(126, 1, {}, Array_0);
_.queryId$ = 0;
function $clinit_Array$ExpandoWrapper(){
  $clinit_Array$ExpandoWrapper = nullMethod;
  expandoNames_0 = [];
  expandoValues_0 = [];
  initExpandos(new Array_0, expandoNames_0, expandoValues_0);
}

function initExpandos(protoType, expandoNames, expandoValues){
  var i = 0, value;
  for (var name_0 in protoType) {
    if (value = protoType[name_0]) {
      expandoNames[i] = name_0;
      expandoValues[i] = value;
      ++i;
    }
  }
}

function wrapArray(array, expandoNames, expandoValues){
  $clinit_Array$ExpandoWrapper();
  for (var i = 0, c = expandoNames.length; i < c; ++i) {
    array[expandoNames[i]] = expandoValues[i];
  }
}

var expandoNames_0, expandoValues_0;
function canCast(src, dstId){
  return src.castableTypeMap$ && !!src.castableTypeMap$[dstId];
}

function canCastUnsafe(src, dstId){
  return src.castableTypeMap$ && src.castableTypeMap$[dstId];
}

function instanceOf(src, dstId){
  return src != null && canCast(src, dstId);
}

function instanceOfJso(src){
  return src != null && src.typeMarker$ != nullMethod && !canCast(src, 1);
}

function isJavaObject(src){
  return src.typeMarker$ == nullMethod || canCast(src, 1);
}

function maskUndefined(src){
  return src == null?null:src;
}

function round_int(x){
  return ~~Math.max(Math.min(x, 2147483647), -2147483648);
}

function init(){
  !!$stats && onModuleStart('com.google.gwt.useragent.client.UserAgentAsserter');
  !!$stats && onModuleStart('com.google.gwt.user.client.DocumentModeAsserter');
  $onModuleLoad();
  !!$stats && onModuleStart('se.elemel.crust.html.CrustGameHtml');
  setUncaughtExceptionHandler(new HtmlGame$1_0);
  $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new HtmlGame$2_0);
}

function caught_0(e){
  if (instanceOf(e, Q$Throwable)) {
    return e;
  }
  return new JavaScriptException_0(e);
}

function create(value){
  var a0, a1, a2;
  a0 = value & 4194303;
  a1 = ~~value >> 22 & 4194303;
  a2 = value < 0?1048575:0;
  return create0(a0, a1, a2);
}

function create0(l_0, m_0, h_0){
  return _ = new LongLibBase$LongEmul_0 , _.l = l_0 , _.m = m_0 , _.h = h_0 , _;
}

function and(a, b){
  return create0(a.l & b.l, a.m & b.m, a.h & b.h);
}

function eq(a, b){
  return a.l == b.l && a.m == b.m && a.h == b.h;
}

function fromInt(value){
  var rebase, result;
  if (value > -129 && value < 128) {
    rebase = value + 128;
    boxedValues == null && (boxedValues = initDim(_3Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$LongLibBase$LongEmul, 256, 0));
    result = boxedValues[rebase];
    !result && (result = boxedValues[rebase] = create(value));
    return result;
  }
  return create(value);
}

function neq(a, b){
  return a.l != b.l || a.m != b.m || a.h != b.h;
}

function or(a, b){
  return create0(a.l | b.l, a.m | b.m, a.h | b.h);
}

var boxedValues = null;
function LongLibBase$LongEmul_0(){
}

defineSeed(134, 1, makeCastMap([Q$LongLibBase$LongEmul]), LongLibBase$LongEmul_0);
function onModuleStart(mainClassName){
  return $stats({moduleName:$moduleName, sessionId:$sessionId, subSystem:'startup', evtGroup:'moduleStartup', millis:(new Date).getTime(), type:'onModuleLoadStart', className:mainClassName});
}

function $sinkBitlessEvent(this$static, eventTypeName){
  sinkBitlessEvent(this$static.element, eventTypeName);
}

defineSeed(142, 1, makeCastMap([Q$HasVisibility, Q$UIObject]));
_.toString$ = function toString_9(){
  if (!this.element) {
    return '(null handle)';
  }
  return this.element.outerHTML;
}
;
_.element = null;
function $addBitlessDomHandler(this$static, handler, type){
  $sinkBitlessEvent(this$static, type.name_0);
  return $addHandler(!this$static.handlerManager?(this$static.handlerManager = new HandlerManager_0(this$static)):this$static.handlerManager, type, handler);
}

function $fireEvent_0(this$static, event_0){
  !!this$static.handlerManager && $fireEvent(this$static.handlerManager, event_0);
}

function $onAttach(this$static){
  var bitsToAdd;
  if (this$static.attached) {
    throw new IllegalStateException_1("Should only call onAttach when the widget is detached from the browser's document");
  }
  this$static.attached = true;
  $setEventListener(this$static.element, this$static);
  bitsToAdd = this$static.eventsToSink;
  this$static.eventsToSink = -1;
  bitsToAdd > 0 && (this$static.eventsToSink == -1?sinkEvents(this$static.element, bitsToAdd | (this$static.element.__eventBits || 0)):(this$static.eventsToSink |= bitsToAdd));
  this$static.doAttachChildren();
}

function $onDetach(this$static){
  if (!this$static.attached) {
    throw new IllegalStateException_1("Should only call onDetach when the widget is attached to the browser's document");
  }
  try {
    this$static.doDetachChildren();
  }
   finally {
    this$static.element.__listener = null;
    this$static.attached = false;
  }
}

function $removeFromParent(this$static){
  if (!this$static.parent_0) {
    ($clinit_RootPanel() , $contains_0(widgetsToDetach, this$static)) && detachNow(this$static);
  }
   else if (this$static.parent_0) {
    $remove_3(this$static.parent_0, this$static);
  }
   else if (this$static.parent_0) {
    throw new IllegalStateException_1("This widget's parent does not implement HasWidgets");
  }
}

function $setParent(this$static, parent_0){
  var oldParent;
  oldParent = this$static.parent_0;
  if (!parent_0) {
    try {
      !!oldParent && oldParent.attached && $onDetach(this$static);
    }
     finally {
      this$static.parent_0 = null;
    }
  }
   else {
    if (oldParent) {
      throw new IllegalStateException_1('Cannot set a new parent without first clearing the old parent');
    }
    this$static.parent_0 = parent_0;
    parent_0.attached && this$static.onAttach();
  }
}

defineSeed(141, 142, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.doAttachChildren = function doAttachChildren(){
}
;
_.doDetachChildren = function doDetachChildren(){
}
;
_.onAttach = function onAttach(){
  $onAttach(this);
}
;
_.onBrowserEvent = function onBrowserEvent(event_0){
  var related;
  switch ($eventGetTypeInt(event_0.type)) {
    case 16:
    case 32:
      related = event_0.relatedTarget;
      if (!!related && $isOrHasChild(this.element, related)) {
        return;
      }

  }
  fireNativeEvent(event_0, this, this.element);
}
;
_.attached = false;
_.eventsToSink = 0;
_.handlerManager = null;
_.parent_0 = null;
defineSeed(140, 141, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.onAttach = function onAttach_0(){
  var tabIndex;
  $onAttach(this);
  tabIndex = $getTabIndex(this.element);
  -1 == tabIndex && (this.element.tabIndex = 0 , undefined);
}
;
defineSeed(139, 140, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
function Audio_0(element){
  this.element = element;
}

function createIfSupported(){
  var element;
  !detector && (detector = new Audio$AudioElementSupportDetectedMaybe_0);
  element = $doc.createElement('audio');
  if (!element.canPlayType) {
    return null;
  }
  return new Audio_0(element);
}

function isSupported(){
  var element;
  !detector && (detector = new Audio$AudioElementSupportDetectedMaybe_0);
  element = $doc.createElement('audio');
  if (!element.canPlayType) {
    return false;
  }
  return true;
}

defineSeed(138, 139, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]), Audio_0);
var detector = null;
defineSeed(144, 1, {});
function Audio$AudioElementSupportDetectedMaybe_0(){
}

defineSeed(143, 144, {}, Audio$AudioElementSupportDetectedMaybe_0);
function $exec(this$static, input){
  return this$static.exec(input);
}

function $getItem(this$static, key){
  return $getItem_0(this$static.storage, key);
}

function $key(this$static, index){
  return $key_0(this$static.storage, index);
}

function $removeItem(this$static, key){
  $removeItem_0(this$static.storage, key);
}

function $setItem(this$static, key, data){
  $setItem_0(this$static.storage, key, data);
}

function Storage_0(){
  this.storage = 'localStorage';
}

function getLocalStorageIfSupported(){
  if ((!supportDetectorImpl && (supportDetectorImpl = new Storage$StorageSupportDetector_0) , supportDetectorImpl).isLocalStorageSupported) {
    !localStorage_0 && (localStorage_0 = new Storage_0);
    return localStorage_0;
  }
  return null;
}

defineSeed(147, 1, {}, Storage_0);
_.storage = null;
var localStorage_0 = null, supportDetectorImpl = null;
function Storage$StorageSupportDetector_0(){
  this.isLocalStorageSupported = $wnd.localStorage != null;
  $wnd.sessionStorage != null;
}

defineSeed(148, 1, {}, Storage$StorageSupportDetector_0);
function $getItem_0(storage, key){
  return $wnd[storage].getItem(key);
}

function $getLength(storage){
  return $wnd[storage].length;
}

function $key_0(storage, index){
  return index >= 0 && index < $wnd[storage].length?$wnd[storage].key(index):null;
}

function $removeItem_0(storage, key){
  $wnd[storage].getItem(key);
  $wnd[storage].removeItem(key);
}

function $setItem_0(storage, key, data){
  $wnd[storage].getItem(key);
  $wnd[storage].setItem(key, data);
}

function $implFindEntry(this$static, key, remove){
  var entry, iter, k;
  for (iter = this$static.entrySet_0().iterator(); iter.hasNext();) {
    entry = iter.next_0();
    k = entry.getKey();
    if (key == null?k == null:equals__devirtual$(key, k)) {
      remove && iter.remove_2();
      return entry;
    }
  }
  return null;
}

function $keySet(this$static){
  var entrySet;
  entrySet = new AbstractHashMap$EntrySet_0(this$static);
  return new AbstractMap$1_0(this$static, entrySet);
}

defineSeed(152, 1, makeCastMap([Q$Map]));
_.containsKey = function containsKey(key){
  return !!$implFindEntry(this, key, false);
}
;
--></script>
<script><!--
_.equals$ = function equals_2(obj){
  var entry, entry$iterator, otherKey, otherMap, otherValue;
  if (obj === this) {
    return true;
  }
  if (!instanceOf(obj, Q$Map)) {
    return false;
  }
  otherMap = obj;
  if (this.size_0() != otherMap.size_0()) {
    return false;
  }
  for (entry$iterator = otherMap.entrySet_0().iterator(); entry$iterator.hasNext();) {
    entry = entry$iterator.next_0();
    otherKey = entry.getKey();
    otherValue = entry.getValue();
    if (!this.containsKey(otherKey)) {
      return false;
    }
    if (!equalsWithNullCheck(otherValue, this.get_0(otherKey))) {
      return false;
    }
  }
  return true;
}
;
_.get_0 = function get_0(key){
  var entry;
  entry = $implFindEntry(this, key, false);
  return !entry?null:entry.getValue();
}
;
_.hashCode$ = function hashCode_4(){
  var entry, entry$iterator, hashCode;
  hashCode = 0;
  for (entry$iterator = this.entrySet_0().iterator(); entry$iterator.hasNext();) {
    entry = entry$iterator.next_0();
    hashCode += entry.hashCode$();
    hashCode = ~~hashCode;
  }
  return hashCode;
}
;
_.isEmpty = function isEmpty_1(){
  return this.size_0() == 0;
}
;
_.put = function put(key, value){
  throw new UnsupportedOperationException_1('Put not supported on this map');
}
;
_.remove_1 = function remove_4(key){
  var entry;
  entry = $implFindEntry(this, key, true);
  return !entry?null:entry.getValue();
}
;
_.size_0 = function size_1(){
  return this.entrySet_0().size_0();
}
;
_.toString$ = function toString_10(){
  var comma, entry, iter, s;
  s = '{';
  comma = false;
  for (iter = this.entrySet_0().iterator(); iter.hasNext();) {
    entry = iter.next_0();
    comma?(s += ', '):(comma = true);
    s += '' + entry.getKey();
    s += '=';
    s += '' + entry.getValue();
  }
  return s + '}';
}
;
function $containsKey(this$static, key){
  return $getItem(this$static.storage, toString__devirtual$(key)) != null;
}

function $eq(a, b){
  if (maskUndefined(a) === maskUndefined(b)) {
    return true;
  }
  if (a == null) {
    return false;
  }
  return $equals(a, b);
}

function $get_0(this$static, key){
  if (key == null) {
    return null;
  }
  return $getItem(this$static.storage, toString__devirtual$(key));
}

function $put(){
  throw new IllegalArgumentException_1('Key and value cannot be null!');
}

function $remove_1(this$static, key){
  var old;
  old = $getItem(this$static.storage, key);
  $removeItem(this$static.storage, key);
  return old;
}

function StorageMap_0(storage){
  this.storage = storage;
}

defineSeed(151, 152, makeCastMap([Q$Map]), StorageMap_0);
_.containsKey = function containsKey_0(key){
  return $containsKey(this, key);
}
;
_.entrySet_0 = function entrySet_0(){
  !this.entrySet && (this.entrySet = new StorageMap$StorageEntrySet_0(this));
  return this.entrySet;
}
;
_.get_0 = function get_1(key){
  return $get_0(this, key);
}
;
_.put = function put_0(key, value){
  return $put(value);
}
;
_.remove_1 = function remove_5(key){
  return $remove_1(this, key);
}
;
_.size_0 = function size_2(){
  return $getLength(this.storage.storage);
}
;
_.entrySet = null;
_.storage = null;
function StorageMap$StorageEntry_0(this$0, key){
  this.this$0 = this$0;
  this.key_0 = key;
}

defineSeed(153, 1, makeCastMap([Q$Map$Entry]), StorageMap$StorageEntry_0);
_.equals$ = function equals_3(obj){
  var e;
  if (obj == null) {
    return false;
  }
   else if (obj === this) {
    return true;
  }
   else if (!instanceOf(obj, Q$Map$Entry)) {
    return false;
  }
  e = obj;
  return $eq(this.key_0, e.getKey()) && $eq($getItem(this.this$0.storage, this.key_0), e.getValue());
}
;
_.getKey = function getKey(){
  return this.key_0;
}
;
_.getValue = function getValue(){
  return $getItem(this.this$0.storage, this.key_0);
}
;
_.hashCode$ = function hashCode_5(){
  var value;
  value = $getItem(this.this$0.storage, this.key_0);
  return (this.key_0 == null?0:getHashCode_0(this.key_0)) ^ (value == null?0:getHashCode_0(value));
}
;
_.setValue = function setValue(value){
  var oldValue;
  return oldValue = $getItem(this.this$0.storage, this.key_0) , $setItem(this.this$0.storage, this.key_0, value) , oldValue;
}
;
_.key_0 = null;
_.this$0 = null;
function $next(this$static){
  if (this$static.index_0 < $getLength(this$static.this$0.storage.storage) - 1) {
    ++this$static.index_0;
    this$static.removed = false;
    return new StorageMap$StorageEntry_0(this$static.this$0, $key(this$static.this$0.storage, this$static.index_0));
  }
  throw new NoSuchElementException_0;
}

function StorageMap$StorageEntryIterator_0(this$0){
  this.this$0 = this$0;
}

defineSeed(154, 1, {}, StorageMap$StorageEntryIterator_0);
_.hasNext = function hasNext(){
  return this.index_0 < $getLength(this.this$0.storage.storage) - 1;
}
;
_.next_0 = function next_0(){
  return $next(this);
}
;
_.remove_2 = function remove_6(){
  if (this.index_0 >= 0 && this.index_0 < $getLength(this.this$0.storage.storage)) {
    if (this.removed) {
      throw new IllegalStateException_1('Cannot remove() Entry - already removed!');
    }
    $removeItem(this.this$0.storage, $key(this.this$0.storage, this.index_0));
    this.removed = true;
    --this.index_0;
  }
   else {
    throw new IllegalStateException_1('Cannot remove() Entry - index=' + this.index_0 + ', size=' + $getLength(this.this$0.storage.storage));
  }
}
;
_.index_0 = -1;
_.removed = false;
_.this$0 = null;
defineSeed(156, 21, makeCastMap([Q$Set]));
_.equals$ = function equals_4(o){
  var iter, other, otherItem;
  if (o === this) {
    return true;
  }
  if (!instanceOf(o, Q$Set)) {
    return false;
  }
  other = o;
  if (other.size_0() != this.size_0()) {
    return false;
  }
  for (iter = other.iterator(); iter.hasNext();) {
    otherItem = iter.next_0();
    if (!this.contains_0(otherItem)) {
      return false;
    }
  }
  return true;
}
;
_.hashCode$ = function hashCode_6(){
  var hashCode, iter, next;
  hashCode = 0;
  for (iter = this.iterator(); iter.hasNext();) {
    next = iter.next_0();
    if (next != null) {
      hashCode += hashCode__devirtual$(next);
      hashCode = ~~hashCode;
    }
  }
  return hashCode;
}
;
function StorageMap$StorageEntrySet_0(this$0){
  this.this$0 = this$0;
}

defineSeed(155, 156, makeCastMap([Q$Set]), StorageMap$StorageEntrySet_0);
_.contains_0 = function contains_2(o){
  var e, key;
  if (o == null || !instanceOf(o, Q$Map$Entry)) {
    return false;
  }
  e = o;
  key = e.getKey();
  return key != null && $containsKey(this.this$0, key) && $eq($get_0(this.this$0, key), e.getValue());
}
;
_.iterator = function iterator_1(){
  return new StorageMap$StorageEntryIterator_0(this.this$0);
}
;
_.remove = function remove_7(o){
  var e, key, value;
  if (o == null || !instanceOf(o, Q$Map$Entry)) {
    return false;
  }
  e = o;
  if (e.getKey() == null) {
    return false;
  }
  key = toString__devirtual$(e.getKey());
  value = $getItem(this.this$0.storage, key);
  if ($eq(value, e.getValue())) {
    return $remove_1(this.this$0, key) != null;
  }
  return false;
}
;
_.size_0 = function size_3(){
  return $getLength(this.this$0.storage.storage);
}
;
_.this$0 = null;
function $set(this$static, array, offset){
  this$static.set(array, offset);
}

function $set_0(this$static, array){
  this$static.set(array);
}

function create_0(buffer, byteOffset, length_0){
  return new Float32Array(buffer, byteOffset, length_0);
}

function create_1(buffer, byteOffset, length_0){
  return new Int16Array(buffer, byteOffset, length_0);
}

function create_2(buffer, byteOffset, length_0){
  return new Int32Array(buffer, byteOffset, length_0);
}

function create_3(buffer, byteOffset, length_0){
  return new Int8Array(buffer, byteOffset, length_0);
}

function createFloat32Array(array){
  return new Float32Array(array);
}

function createInt32Array(array){
  return new Int32Array(array);
}

function createUint16Array(array){
  return new Uint16Array(array);
}

function createUint8Array(array){
  return new Uint8Array(array);
}

function create_4(buffer, byteOffset, length_0){
  return new Uint16Array(buffer, byteOffset, length_0);
}

function create_5(buffer, byteOffset, length_0){
  return new Uint8Array(buffer, byteOffset, length_0);
}

function appendChild(parent_0, child){
  $appendChild(parent_0, ($clinit_PotentialElement() , $resolve(child)));
}

function dispatchEvent_0(evt, elem, listener){
  var prevCurrentEvent;
  prevCurrentEvent = currentEvent;
  currentEvent = evt;
  elem == sCaptureElem && $eventGetTypeInt(evt.type) == 8192 && (sCaptureElem = null);
  listener.onBrowserEvent(evt);
  currentEvent = prevCurrentEvent;
}

function sinkBitlessEvent(elem, eventTypeName){
  $maybeInitializeEventSystem();
  $sinkBitlessEventImpl(elem, eventTypeName);
}

function sinkEvents(elem, eventBits){
  $maybeInitializeEventSystem();
  $sinkEventsImpl(elem, eventBits);
}

var currentEvent = null, sCaptureElem = null;
function $onModuleLoad(){
  var allowedModes, currentMode, i;
  currentMode = $doc.compatMode;
  allowedModes = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['CSS1Compat']);
  for (i = 0; i < allowedModes.length; ++i) {
    if ($equals(allowedModes[i], currentMode)) {
      return;
    }
  }
  allowedModes.length == 1 && $equals('CSS1Compat', allowedModes[0]) && $equals('BackCompat', currentMode)?"GWT no longer supports Quirks Mode (document.compatMode=' BackCompat').<br>Make sure your application's host HTML page has a Standards Mode (document.compatMode=' CSS1Compat') doctype,<br>e.g. by using &lt;!doctype html&gt; at the start of your application's HTML page.<br><br>To continue using this unsupported rendering mode and risk layout problems, suppress this message by adding<br>the following line to your*.gwt.xml module file:<br>&nbsp;&nbsp;&lt;extend-configuration-property name=\"document.compatMode\" value=\"" + currentMode + '"/&gt;':"Your *.gwt.xml module configuration prohibits the use of the current doucment rendering mode (document.compatMode=' " + currentMode + "').<br>Modify your application's host HTML page doctype, or update your custom 'document.compatMode' configuration property settings.";
}

function addCloseHandler(handler){
  maybeInitializeCloseHandlers();
  return addHandler(TYPE_0?TYPE_0:(TYPE_0 = new GwtEvent$Type_0), handler);
}

function addHandler(type, handler){
  return $addHandler((!handlers_0 && (handlers_0 = new Window$WindowHandlers_0) , handlers_0), type, handler);
}

function alert_0(msg){
  $wnd.alert(msg);
}

function maybeInitializeCloseHandlers(){
  if (!closeHandlersInitialized) {
    $initWindowCloseHandler();
    closeHandlersInitialized = true;
  }
}

function onClosing(){
  var event_0;
  if (closeHandlersInitialized) {
    event_0 = new Window$ClosingEvent_0;
    !!handlers_0 && $fireEvent(handlers_0, event_0);
    return null;
  }
  return null;
}

var closeHandlersInitialized = false, handlers_0 = null;
function $clinit_Window$ClosingEvent(){
  $clinit_Window$ClosingEvent = nullMethod;
  TYPE_1 = new GwtEvent$Type_0;
}

function Window$ClosingEvent_0(){
  $clinit_Window$ClosingEvent();
}

defineSeed(171, 108, {}, Window$ClosingEvent_0);
_.dispatch = function dispatch_1(handler){
  null.nullMethod();
}
;
_.getAssociatedType = function getAssociatedType_1(){
  return TYPE_1;
}
;
var TYPE_1;
function ensureParameterMap(){
  var kv, kvPair, kvPair$array, kvPair$index, kvPair$max, qs, queryString, regexp;
  if (!paramMap) {
    paramMap = new HashMap_0;
    queryString = $wnd.location.search;
    if (queryString != null && queryString.length > 1) {
      qs = $substring(queryString, 1);
      for (kvPair$array = $split(qs, '&', 0) , kvPair$index = 0 , kvPair$max = kvPair$array.length; kvPair$index < kvPair$max; ++kvPair$index) {
        kvPair = kvPair$array[kvPair$index];
        kv = $split(kvPair, '=', 2);
        kv.length > 1?$put_2(paramMap, kv[0], (throwIfNull(kv[1]) , regexp = /\+/g , decodeURIComponent(kv[1].replace(regexp, '%20')))):$put_2(paramMap, kv[0], '');
      }
    }
  }
}

var paramMap = null;
function Window$WindowHandlers_0(){
  HandlerManager_0.call(this, null);
}

defineSeed(174, 117, makeCastMap([Q$HasHandlers]), Window$WindowHandlers_0);
function $eventGetTypeInt(eventType){
  switch (eventType) {
    case 'blur':
      return 4096;
    case 'change':
      return 1024;
    case 'click':
      return 1;
    case 'dblclick':
      return 2;
    case 'focus':
      return 2048;
    case 'keydown':
      return 128;
    case 'keypress':
      return 256;
    case 'keyup':
      return 512;
    case 'load':
      return 32768;
    case 'losecapture':
      return 8192;
    case 'mousedown':
      return 4;
    case 'mousemove':
      return 64;
    case 'mouseout':
      return 32;
    case 'mouseover':
      return 16;
    case 'mouseup':
      return 8;
    case 'scroll':
      return 16384;
    case 'error':
      return 65536;
    case 'DOMMouseScroll':
    case 'mousewheel':
      return 131072;
    case 'contextmenu':
      return 262144;
    case 'paste':
      return 524288;
    case 'touchstart':
      return 1048576;
    case 'touchmove':
      return 2097152;
    case 'touchend':
      return 4194304;
    case 'touchcancel':
      return 8388608;
    case 'gesturestart':
      return 16777216;
    case 'gesturechange':
      return 33554432;
    case 'gestureend':
      return 67108864;
    default:return -1;
  }
}

function $maybeInitializeEventSystem(){
  if (!eventSystemIsInitialized) {
    $initEventSystem();
    eventSystemIsInitialized = true;
  }
}

function $setEventListener(elem, listener){
  elem.__listener = listener;
}

function isMyListener(object){
  return !instanceOfJso(object) && instanceOf(object, Q$EventListener);
}

var eventSystemIsInitialized = false;
function $initEventSystem(){
  dispatchCapturedEvent = $entry(function(evt){
    return true;
  }
  );
  dispatchEvent_1 = $entry(function(evt){
    var listener, curElem = this;
    while (curElem && !(listener = curElem.__listener)) {
      curElem = curElem.parentNode;
    }
    curElem && curElem.nodeType != 1 && (curElem = null);
    listener && isMyListener(listener) && dispatchEvent_0(evt, curElem, listener);
  }
  );
  dispatchDragEvent = $entry(function(evt){
    evt.preventDefault();
    dispatchEvent_1.call(this, evt);
  }
  );
  dispatchUnhandledEvent = $entry(function(evt){
    this.__gwtLastUnhandledEvent = evt.type;
    dispatchEvent_1.call(this, evt);
  }
  );
  dispatchCapturedMouseEvent = $entry(function(evt){
    var dispatchCapturedEventFn = dispatchCapturedEvent;
    if (dispatchCapturedEventFn(evt)) {
      var cap = captureElem;
      if (cap && cap.__listener) {
        if (isMyListener(cap.__listener)) {
          dispatchEvent_0(evt, cap, cap.__listener);
          evt.stopPropagation();
        }
      }
    }
  }
  );
  $wnd.addEventListener('click', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('dblclick', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mousedown', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mouseup', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mousemove', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mouseover', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mouseout', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mousewheel', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('keydown', dispatchCapturedEvent, true);
  $wnd.addEventListener('keyup', dispatchCapturedEvent, true);
  $wnd.addEventListener('keypress', dispatchCapturedEvent, true);
  $wnd.addEventListener('touchstart', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('touchmove', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('touchend', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('touchcancel', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('gesturestart', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('gesturechange', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('gestureend', dispatchCapturedMouseEvent, true);
}

function $sinkBitlessEventImpl(elem, eventTypeName){
  switch (eventTypeName) {
    case 'drag':
      elem.ondrag = dispatchEvent_1;
      break;
    case 'dragend':
      elem.ondragend = dispatchEvent_1;
      break;
    case 'dragenter':
      elem.ondragenter = dispatchDragEvent;
      break;
    case 'dragleave':
      elem.ondragleave = dispatchEvent_1;
      break;
    case 'dragover':
      elem.ondragover = dispatchDragEvent;
      break;
    case 'dragstart':
      elem.ondragstart = dispatchEvent_1;
      break;
    case 'drop':
      elem.ondrop = dispatchEvent_1;
      break;
    case 'canplaythrough':
    case 'ended':
    case 'progress':
      elem.removeEventListener(eventTypeName, dispatchEvent_1, false);
      elem.addEventListener(eventTypeName, dispatchEvent_1, false);
      break;
    default:throw 'Trying to sink unknown event type ' + eventTypeName;
  }
}

function $sinkEventsImpl(elem, bits){
  var chMask = (elem.__eventBits || 0) ^ bits;
  elem.__eventBits = bits;
  if (!chMask)
    return;
  chMask & 1 && (elem.onclick = bits & 1?dispatchEvent_1:null);
  chMask & 2 && (elem.ondblclick = bits & 2?dispatchEvent_1:null);
  chMask & 4 && (elem.onmousedown = bits & 4?dispatchEvent_1:null);
  chMask & 8 && (elem.onmouseup = bits & 8?dispatchEvent_1:null);
  chMask & 16 && (elem.onmouseover = bits & 16?dispatchEvent_1:null);
  chMask & 32 && (elem.onmouseout = bits & 32?dispatchEvent_1:null);
  chMask & 64 && (elem.onmousemove = bits & 64?dispatchEvent_1:null);
  chMask & 128 && (elem.onkeydown = bits & 128?dispatchEvent_1:null);
  chMask & 256 && (elem.onkeypress = bits & 256?dispatchEvent_1:null);
  chMask & 512 && (elem.onkeyup = bits & 512?dispatchEvent_1:null);
  chMask & 1024 && (elem.onchange = bits & 1024?dispatchEvent_1:null);
  chMask & 2048 && (elem.onfocus = bits & 2048?dispatchEvent_1:null);
  chMask & 4096 && (elem.onblur = bits & 4096?dispatchEvent_1:null);
  chMask & 8192 && (elem.onlosecapture = bits & 8192?dispatchEvent_1:null);
  chMask & 16384 && (elem.onscroll = bits & 16384?dispatchEvent_1:null);
  chMask & 32768 && (elem.onload = bits & 32768?dispatchUnhandledEvent:null);
  chMask & 65536 && (elem.onerror = bits & 65536?dispatchEvent_1:null);
  chMask & 131072 && (elem.onmousewheel = bits & 131072?dispatchEvent_1:null);
  chMask & 262144 && (elem.oncontextmenu = bits & 262144?dispatchEvent_1:null);
  chMask & 524288 && (elem.onpaste = bits & 524288?dispatchEvent_1:null);
  chMask & 1048576 && (elem.ontouchstart = bits & 1048576?dispatchEvent_1:null);
  chMask & 2097152 && (elem.ontouchmove = bits & 2097152?dispatchEvent_1:null);
  chMask & 4194304 && (elem.ontouchend = bits & 4194304?dispatchEvent_1:null);
  chMask & 8388608 && (elem.ontouchcancel = bits & 8388608?dispatchEvent_1:null);
  chMask & 16777216 && (elem.ongesturestart = bits & 16777216?dispatchEvent_1:null);
  chMask & 33554432 && (elem.ongesturechange = bits & 33554432?dispatchEvent_1:null);
  chMask & 67108864 && (elem.ongestureend = bits & 67108864?dispatchEvent_1:null);
}

var captureElem = null, dispatchCapturedEvent = null, dispatchCapturedMouseEvent = null, dispatchDragEvent = null, dispatchEvent_1 = null, dispatchUnhandledEvent = null;
function $initWindowCloseHandler(){
  var oldOnBeforeUnload = $wnd.onbeforeunload;
  var oldOnUnload = $wnd.onunload;
  $wnd.onbeforeunload = function(evt){
    var ret, oldRet;
    try {
      ret = $entry(onClosing)();
    }
     finally {
      oldRet = oldOnBeforeUnload && oldOnBeforeUnload(evt);
    }
    if (ret != null) {
      return ret;
    }
    if (oldRet != null) {
      return oldRet;
    }
  }
  ;
  $wnd.onunload = $entry(function(evt){
    try {
      closeHandlersInitialized && fire((!handlers_0 && (handlers_0 = new Window$WindowHandlers_0) , handlers_0));
    }
     finally {
      oldOnUnload && oldOnUnload(evt);
      $wnd.onresize = null;
      $wnd.onscroll = null;
      $wnd.onbeforeunload = null;
      $wnd.onunload = null;
    }
  }
  );
}

defineSeed(180, 141, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.doAttachChildren = function doAttachChildren_0(){
  tryCommand(this, ($clinit_AttachDetachException() , attachCommand));
}
;
_.doDetachChildren = function doDetachChildren_0(){
  tryCommand(this, ($clinit_AttachDetachException() , detachCommand));
}
;
function $add_1(this$static, child, container){
  $removeFromParent(child);
  $add_3(this$static.children, child);
  appendChild(container, child.element);
  $setParent(child, this$static);
}

function $remove_2(this$static, w){
  var elem, parent_0;
  if (w.parent_0 != this$static) {
    return false;
  }
  try {
    $setParent(w, null);
  }
   finally {
    elem = w.element;
    $removeChild((parent_0 = elem.parentNode , (!parent_0 || parent_0.nodeType != 1) && (parent_0 = null) , parent_0), elem);
    $remove_5(this$static.children, w);
  }
  return true;
}

defineSeed(179, 180, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.iterator = function iterator_2(){
  return new WidgetCollection$WidgetIterator_0(this.children);
}
;
_.remove_3 = function remove_8(w){
  return $remove_2(this, w);
}
;
function $add_2(this$static, w){
  $add_1(this$static, w, this$static.element);
}

function $remove_3(this$static, w){
  var removed;
  removed = $remove_2(this$static, w);
  removed && changeToStaticPositioning(w.element);
  return removed;
}

function changeToStaticPositioning(elem){
  elem.style['left'] = '';
  elem.style['top'] = '';
  elem.style['position'] = '';
}

defineSeed(178, 179, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.remove_3 = function remove_9(w){
  return $remove_3(this, w);
}
;
function $clinit_AttachDetachException(){
  $clinit_AttachDetachException = nullMethod;
  attachCommand = new AttachDetachException$1_0;
  detachCommand = new AttachDetachException$2_0;
}

function AttachDetachException_0(causes){
  UmbrellaException_2.call(this, causes);
}

function tryCommand(hasWidgets, c){
  $clinit_AttachDetachException();
  var $e0, caught, e, w, w$iterator;
  caught = null;
  for (w$iterator = hasWidgets.iterator(); w$iterator.hasNext();) {
    w = w$iterator.next_0();
    try {
      c.execute_1(w);
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$Throwable)) {
        e = $e0;
        !caught && (caught = new HashSet_0);
        $add_4(caught, e);
      }
       else 
        throw $e0;
    }
  }
  if (caught) {
    throw new AttachDetachException_0(caught);
  }
}

defineSeed(181, 122, makeCastMap([Q$UmbrellaException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), AttachDetachException_0);
var attachCommand, detachCommand;
function AttachDetachException$1_0(){
}

defineSeed(182, 1, {}, AttachDetachException$1_0);
_.execute_1 = function execute_5(w){
  w.onAttach();
}
;
function AttachDetachException$2_0(){
}

defineSeed(183, 1, {}, AttachDetachException$2_0);
_.execute_1 = function execute_6(w){
  $onDetach(w);
}
;
function $clinit_PotentialElement(){
  $clinit_PotentialElement = nullMethod;
  declareShim();
}

function $resolve(this$static){
  return this$static.__gwt_resolve?this$static.__gwt_resolve():this$static;
}

function declareShim(){
  var shim = function(){
  }
  ;
  shim.prototype = {className:'', clientHeight:0, clientWidth:0, dir:'', getAttribute:function(name_0, value){
    return this[name_0];
  }
  , href:'', id:'', lang:'', nodeType:1, removeAttribute:function(name_0, value){
    this[name_0] = undefined;
  }
  , setAttribute:function(name_0, value){
    this[name_0] = value;
  }
  , src:'', style:{}, title:''};
  $wnd.GwtPotentialElementShim = shim;
}

function $clinit_RootPanel(){
  $clinit_RootPanel = nullMethod;
  maybeDetachCommand = new RootPanel$1_0;
  rootPanels = new HashMap_0;
  widgetsToDetach = new HashSet_0;
}

function RootPanel_0(elem){
  this.children = new WidgetCollection_0(this);
  this.element = elem;
  $onAttach(this);
}

function detachNow(widget){
  $clinit_RootPanel();
  try {
    $onDetach(widget);
  }
   finally {
    $remove_9(widgetsToDetach, widget);
  }
}

function detachWidgets(){
  $clinit_RootPanel();
  try {
    tryCommand(widgetsToDetach, maybeDetachCommand);
  }
   finally {
    $clearImpl(widgetsToDetach.map);
    $clearImpl(rootPanels);
  }
}

function get_2(){
  $clinit_RootPanel();
  var rp;
  rp = $get_6(rootPanels, null);
  if (rp) {
    return rp;
  }
  rootPanels.size == 0 && addCloseHandler(new RootPanel$2_0);
  rp = new RootPanel$DefaultRootPanel_0;
  $put_2(rootPanels, null, rp);
  $add_4(widgetsToDetach, rp);
  return rp;
}

function getBodyElement(){
  $clinit_RootPanel();
  return $doc.body;
}

defineSeed(185, 178, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
var maybeDetachCommand, rootPanels, widgetsToDetach;
function RootPanel$1_0(){
}

defineSeed(186, 1, {}, RootPanel$1_0);
_.execute_1 = function execute_7(w){
  w.attached && $onDetach(w);
}
;
function RootPanel$2_0(){
}

defineSeed(187, 1, {}, RootPanel$2_0);
function RootPanel$DefaultRootPanel_0(){
  RootPanel_0.call(this, getBodyElement());
}

defineSeed(188, 185, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]), RootPanel$DefaultRootPanel_0);
function $add_3(this$static, w){
  $insert(this$static, w, this$static.size);
}

function $indexOf_0(this$static, w){
  var i;
  for (i = 0; i < this$static.size; ++i) {
    if (this$static.array[i] == w) {
      return i;
    }
  }
  return -1;
}

function $insert(this$static, w, beforeIndex){
  var i, newArray;
  if (beforeIndex < 0 || beforeIndex > this$static.size) {
    throw new IndexOutOfBoundsException_0;
  }
  if (this$static.size == this$static.array.length) {
    newArray = initDim(_3Lcom_google_gwt_user_client_ui_Widget_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Widget, this$static.array.length * 2, 0);
    for (i = 0; i < this$static.array.length; ++i) {
      setCheck(newArray, i, this$static.array[i]);
    }
    this$static.array = newArray;
  }
  ++this$static.size;
  for (i = this$static.size - 1; i > beforeIndex; --i) {
    setCheck(this$static.array, i, this$static.array[i - 1]);
  }
  setCheck(this$static.array, beforeIndex, w);
}

function $remove_4(this$static, index){
  var i;
  if (index < 0 || index >= this$static.size) {
    throw new IndexOutOfBoundsException_0;
  }
  --this$static.size;
  for (i = index; i < this$static.size; ++i) {
    setCheck(this$static.array, i, this$static.array[i + 1]);
  }
  setCheck(this$static.array, this$static.size, null);
}

function $remove_5(this$static, w){
  var index;
  index = $indexOf_0(this$static, w);
  if (index == -1) {
    throw new NoSuchElementException_0;
  }
  $remove_4(this$static, index);
}

function WidgetCollection_0(parent_0){
  this.parent_0 = parent_0;
  this.array = initDim(_3Lcom_google_gwt_user_client_ui_Widget_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Widget, 4, 0);
}

defineSeed(189, 1, {}, WidgetCollection_0);
_.iterator = function iterator_3(){
  return new WidgetCollection$WidgetIterator_0(this);
}
;
_.array = null;
_.parent_0 = null;
_.size = 0;
function $next_0(this$static){
  if (this$static.index_0 >= this$static.this$0.size) {
    throw new NoSuchElementException_0;
  }
  return this$static.this$0.array[++this$static.index_0];
}

function WidgetCollection$WidgetIterator_0(this$0){
  this.this$0 = this$0;
}

defineSeed(190, 1, {}, WidgetCollection$WidgetIterator_0);
_.hasNext = function hasNext_0(){
  return this.index_0 < this.this$0.size - 1;
}
;
_.next_0 = function next_1(){
  return $next_0(this);
}
;
_.remove_2 = function remove_10(){
  if (this.index_0 < 0 || this.index_0 >= this.this$0.size) {
    throw new IllegalStateException_0;
  }
  this.this$0.parent_0.remove_3(this.this$0.array[this.index_0--]);
}
;
_.index_0 = -1;
_.this$0 = null;
function toJsArray(data){
  var i, jsan, len;
  jsan = [];
  len = data.length;
  for (i = len - 1; i >= 0; --i) {
    jsan[i] = data[i];
  }
  return jsan;
}

function toJsArray_0(data){
  var i, jsan, len;
  jsan = [];
  len = data.length;
  for (i = len - 1; i >= 0; --i) {
    jsan[i] = data[i];
  }
  return jsan;
}

function $attachShader(this$static, program, shader){
  this$static.attachShader(program, shader);
}

function $bindBuffer(this$static, target, buffer){
  this$static.bindBuffer(target, buffer);
}

function $bindFramebuffer(this$static, target, framebuffer){
  this$static.bindFramebuffer(target, framebuffer);
}

function $bindTexture(this$static, target, texture){
  this$static.bindTexture(target, texture);
}

function $bufferData(this$static, target, data, usage){
  this$static.bufferData(target, data, usage);
}

function $clear(this$static, mask){
  this$static.clear(mask);
}

function $clearColor(this$static, red, green, blue, alpha){
  this$static.clearColor(red, green, blue, alpha);
}

function $compileShader(this$static, shader){
  this$static.compileShader(shader);
}

function $createShader(this$static, type){
  return this$static.createShader(type);
}

function $deleteBuffer(this$static, buffer){
  this$static.deleteBuffer(buffer);
}

function $deleteFramebuffer(this$static, framebuffer){
  this$static.deleteFramebuffer(framebuffer);
}

function $deleteProgram(this$static, program){
  this$static.deleteProgram(program);
}

function $deleteRenderbuffer(this$static, renderbuffer){
  this$static.deleteRenderbuffer(renderbuffer);
}

function $deleteShader(this$static, shader){
  this$static.deleteShader(shader);
}

function $deleteTexture(this$static, texture){
  this$static.deleteTexture(texture);
}

--></script>
<script><!--
function $disableVertexAttribArray(this$static, index){
  this$static.disableVertexAttribArray(index);
}

function $drawElements(this$static, mode, count, type, offset){
  this$static.drawElements(mode, count, type, offset);
}

function $enableVertexAttribArray(this$static, index){
  this$static.enableVertexAttribArray(index);
}

function $framebufferTexture2D(this$static, target, attachment, textarget, texture, level){
  this$static.framebufferTexture2D(target, attachment, textarget, texture, level);
}

function $getAttribLocation(this$static, program, name_0){
  return this$static.getAttribLocation(program, name_0);
}

function $getProgramInfoLog(this$static, program){
  return this$static.getProgramInfoLog(program);
}

function $getProgramParameterb(this$static, program, pname){
  return this$static.getProgramParameter(program, pname);
}

function $getShaderInfoLog(this$static, shader){
  return this$static.getShaderInfoLog(shader);
}

function $getShaderParameterb(this$static, shader, pname){
  return this$static.getShaderParameter(shader, pname);
}

function $getUniformLocation(this$static, program, name_0){
  return this$static.getUniformLocation(program, name_0);
}

function $linkProgram(this$static, program){
  this$static.linkProgram(program);
}

function $readPixels(this$static, x, y, width, height, format, type, pixels){
  this$static.readPixels(x, y, width, height, format, type, pixels);
}

function $shaderSource(this$static, shader, source){
  this$static.shaderSource(shader, source);
}

function $texImage2D(this$static, target, level, internalformat, width, height, border, format, type, pixels){
  this$static.texImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}

function $texImage2D_0(this$static, target, level, internalformat, format, type, image){
  this$static.texImage2D(target, level, internalformat, format, type, image);
}

function $texParameteri(this$static, target, pname, param){
  this$static.texParameteri(target, pname, param);
}

function $uniform1i(this$static, location_0, x){
  this$static.uniform1i(location_0, x);
}

function $uniform2f(this$static, location_0, x, y){
  this$static.uniform2f(location_0, x, y);
}

function $uniform4fv(this$static, location_0, v){
  this$static.uniform4fv(location_0, v);
}

function $useProgram(this$static, program){
  this$static.useProgram(program);
}

function $vertexAttribPointer(this$static, indx, size, type, normalized, stride, offset){
  this$static.vertexAttribPointer(indx, size, type, normalized, stride, offset);
}

function $viewport(this$static, x, y, width, height){
  this$static.viewport(x, y, width, height);
}

function getContext(canvas, attributes){
  var names = ['experimental-webgl', 'webgl', 'moz-webgl', 'webkit-webgl', 'webkit-3d'];
  for (var i = 0; i < names.length; i++) {
    try {
      var ctx = canvas.getContext(names[i], attributes);
      if (ctx != null) {
        if ($wnd.WebGLDebugUtils) {
          $wnd.console && $wnd.console.log && console.log('WebGL debugging enabled');
          return $wnd.WebGLDebugUtils.makeDebugContext(ctx);
        }
        return ctx;
      }
    }
     catch (e) {
    }
  }
  return null;
}

function $removeHandler(this$static){
  $doRemove(this$static.this$0, this$static.val$type, this$static.val$source, this$static.val$handler);
}

function SimpleEventBus$1_0(this$0, val$type, val$handler){
  this.this$0 = this$0;
  this.val$type = val$type;
  this.val$source = null;
  this.val$handler = val$handler;
}

defineSeed(202, 1, {}, SimpleEventBus$1_0);
_.this$0 = null;
_.val$handler = null;
_.val$source = null;
_.val$type = null;
function SimpleEventBus$2_0(this$0, val$type, val$handler){
  this.this$0 = this$0;
  this.val$type = val$type;
  this.val$source = null;
  this.val$handler = val$handler;
}

defineSeed(203, 1, {}, SimpleEventBus$2_0);
_.execute = function execute_8(){
  $doAddNow(this.this$0, this.val$type, this.val$source, this.val$handler);
}
;
_.this$0 = null;
_.val$handler = null;
_.val$source = null;
_.val$type = null;
function SimpleEventBus$3_0(this$0, val$type, val$source, val$handler){
  this.this$0 = this$0;
  this.val$type = val$type;
  this.val$source = val$source;
  this.val$handler = val$handler;
}

defineSeed(204, 1, {}, SimpleEventBus$3_0);
_.execute = function execute_9(){
  $doRemoveNow(this.this$0, this.val$type, this.val$source, this.val$handler);
}
;
_.this$0 = null;
_.val$handler = null;
_.val$source = null;
_.val$type = null;
function IndexOutOfBoundsException_0(){
  RuntimeException_0.call(this);
}

function IndexOutOfBoundsException_1(message){
  RuntimeException_1.call(this, message);
}

defineSeed(206, 45, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), IndexOutOfBoundsException_0, IndexOutOfBoundsException_1);
function ArrayIndexOutOfBoundsException_0(msg){
  IndexOutOfBoundsException_1.call(this, msg);
}

defineSeed(205, 206, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), ArrayIndexOutOfBoundsException_0);
function ArrayStoreException_0(){
  RuntimeException_0.call(this);
}

function ArrayStoreException_1(message){
  RuntimeException_1.call(this, message);
}

defineSeed(207, 45, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), ArrayStoreException_0, ArrayStoreException_1);
function Error_1(message, cause){
  Throwable_0.call(this, message, cause);
}

defineSeed(209, 47, makeCastMap([Q$Serializable, Q$Throwable]));
function AssertionError_0(message){
  Error_1.call(this, '' + message, instanceOf(message, Q$Throwable)?message:null);
}

defineSeed(208, 209, makeCastMap([Q$Serializable, Q$Throwable]), AssertionError_0);
function digit(c){
  if (c >= 48 && c < 58) {
    return c - 48;
  }
  if (c >= 97 && c < 97) {
    return c - 97 + 10;
  }
  if (c >= 65 && c < 65) {
    return c - 65 + 10;
  }
  return -1;
}

function Class_0(){
}

function asString(number){
  return typeof number == 'number'?'S' + (number < 0?-number:number):number;
}

function createForArray(seedId, componentType){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId != 0?-seedId:0)?asString(seedId != 0?-seedId:0):'' + getHashCode(clazz));
  isInstantiable(seedId != 0?-seedId:0) && setClassLiteral(seedId != 0?-seedId:0, clazz);
  clazz.modifiers = 4;
  clazz.componentType = componentType;
  return clazz;
}

function createForClass(seedId){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId)?asString(seedId):'' + getHashCode(clazz));
  isInstantiable(seedId) && setClassLiteral(seedId, clazz);
  return clazz;
}

function createForEnum(seedId, enumConstantsFunc){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId)?asString(seedId):'' + getHashCode(clazz));
  isInstantiable(seedId) && setClassLiteral(seedId, clazz);
  clazz.modifiers = enumConstantsFunc?8:0;
  return clazz;
}

function createForInterface(){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(0)?asString(0):'' + getHashCode(clazz));
  isInstantiable(0) && setClassLiteral(0, clazz);
  clazz.modifiers = 2;
  return clazz;
}

function createForPrimitive(seedId){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId)?asString(seedId):'' + getHashCode(clazz));
  isInstantiable(seedId) && setClassLiteral(seedId, clazz);
  clazz.modifiers = 1;
  return clazz;
}

function getSeedFunction(clazz){
  var func = seedTable[clazz.seedId];
  clazz = null;
  return func;
}

function isInstantiable(seedId){
  return typeof seedId == 'number' && seedId > 0;
}

function isInstantiableOrPrimitive(seedId){
  return seedId != null && seedId != 0;
}

function setClassLiteral(seedId, clazz){
  var proto;
  clazz.seedId = seedId;
  if (seedId == 2) {
    proto = String.prototype;
  }
   else {
    if (seedId > 0) {
      var seed = getSeedFunction(clazz);
      if (seed) {
        proto = seed.prototype;
      }
       else {
        seed = seedTable[seedId] = function(){
        }
        ;
        seed.___clazz$ = clazz;
        return;
      }
    }
     else {
      return;
    }
  }
  proto.___clazz$ = clazz;
}

defineSeed(211, 1, {}, Class_0);
_.toString$ = function toString_11(){
  return ((this.modifiers & 2) != 0?'interface ':(this.modifiers & 1) != 0?'':'class ') + this.typeName;
}
;
_.componentType = null;
_.modifiers = 0;
_.seedId = 0;
_.typeName = null;
function __parseAndValidateDouble(s){
  var toReturn;
  toReturn = __parseDouble(s);
  if (isNaN(toReturn)) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  return toReturn;
}

function __parseAndValidateInt(s){
  var i, length_0, startIndex, toReturn;
  if (s == null) {
    throw new NumberFormatException_0('null');
  }
  length_0 = s.length;
  startIndex = length_0 > 0 && s.charCodeAt(0) == 45?1:0;
  for (i = startIndex; i < length_0; ++i) {
    if (digit(s.charCodeAt(i)) == -1) {
      throw new NumberFormatException_0('For input string: "' + s + '"');
    }
  }
  toReturn = parseInt(s, 10);
  if (isNaN(toReturn)) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
   else if (toReturn < -2147483648 || toReturn > 2147483647) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  return toReturn;
}

function __parseDouble(str){
  var floatRegex = floatRegex_0;
  !floatRegex && (floatRegex = floatRegex_0 = /^\s*[+-]?((\d+\.?\d*)|(\.\d+))([eE][+-]?\d+)?[dDfF]?\s*$/i);
  if (floatRegex.test(str)) {
    return parseFloat(str);
  }
   else {
    return Number.NaN;
  }
}

defineSeed(213, 1, makeCastMap([Q$Serializable, Q$Number]));
var floatRegex_0 = null;
function Float_0(value){
  this.value_0 = value;
}

function parseFloat_0(s){
  var doubleValue;
  doubleValue = __parseAndValidateDouble(s);
  if (doubleValue > 3.4028234663852886E38) {
    return Infinity;
  }
   else if (doubleValue < -3.4028234663852886E38) {
    return -Infinity;
  }
  return doubleValue;
}

defineSeed(212, 213, makeCastMap([Q$Serializable, Q$Comparable, Q$Float, Q$Number]), Float_0);
_.compareTo$ = function compareTo_0(b){
  return this.value_0 < b.value_0?-1:this.value_0 > b.value_0?1:0;
}
;
_.equals$ = function equals_5(o){
  return instanceOf(o, Q$Float) && o.value_0 == this.value_0;
}
;
_.hashCode$ = function hashCode_7(){
  return round_int(this.value_0);
}
;
_.toString$ = function toString_12(){
  return '' + this.value_0;
}
;
_.value_0 = 0;
function IllegalArgumentException_0(){
  RuntimeException_0.call(this);
}

function IllegalArgumentException_1(message){
  RuntimeException_1.call(this, message);
}

defineSeed(214, 45, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), IllegalArgumentException_0, IllegalArgumentException_1);
function IllegalStateException_0(){
  RuntimeException_0.call(this);
}

function IllegalStateException_1(s){
  RuntimeException_1.call(this, s);
}

defineSeed(215, 45, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), IllegalStateException_0, IllegalStateException_1);
function Integer_0(value){
  this.value_0 = value;
}

function toPowerOfTwoString(value){
  var buf, digits, pos;
  buf = initDim(_3C_classLit, makeCastMap([Q$Serializable]), -1, 8, 1);
  digits = ($clinit_Number$__Digits() , digits_0);
  pos = 7;
  if (value >= 0) {
    while (value > 15) {
      buf[pos--] = digits[value & 15];
      value >>= 4;
    }
  }
   else {
    while (pos > 0) {
      buf[pos--] = digits[value & 15];
      value >>= 4;
    }
  }
  buf[pos] = digits[value & 15];
  return __valueOf(buf, pos, 8);
}

function valueOf(i){
  var rebase, result;
  if (i > -129 && i < 128) {
    rebase = i + 128;
    result = ($clinit_Integer$BoxedValues() , boxedValues_0)[rebase];
    !result && (result = boxedValues_0[rebase] = new Integer_0(i));
    return result;
  }
  return new Integer_0(i);
}

defineSeed(216, 213, makeCastMap([Q$Serializable, Q$Comparable, Q$Integer, Q$Number]), Integer_0);
_.compareTo$ = function compareTo_1(b){
  return this.value_0 < b.value_0?-1:this.value_0 > b.value_0?1:0;
}
;
_.equals$ = function equals_6(o){
  return instanceOf(o, Q$Integer) && o.value_0 == this.value_0;
}
;
_.hashCode$ = function hashCode_8(){
  return this.value_0;
}
;
_.toString$ = function toString_13(){
  return '' + this.value_0;
}
;
_.value_0 = 0;
function $clinit_Integer$BoxedValues(){
  $clinit_Integer$BoxedValues = nullMethod;
  boxedValues_0 = initDim(_3Ljava_lang_Integer_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Integer, 256, 0);
}

var boxedValues_0;
function abs(x){
  return x <= 0?0 - x:x;
}

function atan2(y, x){
  return Math.atan2(y, x);
}

function cos(x){
  return Math.cos(x);
}

function min(x, y){
  return x < y?x:y;
}

function sin(x){
  return Math.sin(x);
}

function sqrt(x){
  return Math.sqrt(x);
}

function NullPointerException_0(){
  RuntimeException_0.call(this);
}

function NullPointerException_1(message){
  RuntimeException_1.call(this, message);
}

defineSeed(219, 45, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), NullPointerException_0, NullPointerException_1);
function $clinit_Number$__Digits(){
  $clinit_Number$__Digits = nullMethod;
  digits_0 = initValues(_3C_classLit, makeCastMap([Q$Serializable]), -1, [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]);
}

var digits_0;
function NumberFormatException_0(message){
  IllegalArgumentException_1.call(this, message);
}

defineSeed(221, 214, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), NumberFormatException_0);
function StackTraceElement_0(methodName, fileName){
  this.className = 'Unknown';
  this.methodName = methodName;
  this.fileName = fileName;
  this.lineNumber = -1;
}

defineSeed(222, 1, makeCastMap([Q$Serializable, Q$StackTraceElement]), StackTraceElement_0);
_.toString$ = function toString_14(){
  return this.className + '.' + this.methodName + '(' + (this.fileName != null?this.fileName:'Unknown Source') + (this.lineNumber >= 0?':' + this.lineNumber:'') + ')';
}
;
_.className = null;
_.fileName = null;
_.lineNumber = 0;
_.methodName = null;
function $charAt(this$static, index){
  return this$static.charCodeAt(index);
}

function $equals(this$static, other){
  if (!instanceOf(other, Q$String)) {
    return false;
  }
  return String(this$static) == other;
}

function $indexOf_1(this$static, str){
  return this$static.indexOf(str);
}

function $lastIndexOf(this$static, str){
  return this$static.lastIndexOf(str);
}

function $lastIndexOf_0(this$static, str, start){
  return this$static.lastIndexOf(str, start);
}

function $replace_0(this$static, from, to){
  var regex, replacement;
  regex = $replaceAll(from, '([/\\\\\\.\\*\\+\\?\\|\\(\\)\\[\\]\\{\\}$^])', '\\\\$1');
  replacement = $replaceAll($replaceAll(to, '\\\\', '\\\\\\\\'), '\\$', '\\\\$');
  return $replaceAll(this$static, regex, replacement);
}

function $replaceAll(this$static, regex, replace){
  replace = __translateReplaceString(replace);
  return this$static.replace(RegExp(regex, 'g'), replace);
}

function $replaceFirst(this$static, regex, replace){
  replace = __translateReplaceString(replace);
  return this$static.replace(RegExp(regex), replace);
}

function $split(this$static, regex, maxMatch){
  var compiled = new RegExp(regex, 'g');
  var out = [];
  var count = 0;
  var trail = this$static;
  var lastTrail = null;
  while (true) {
    var matchObj = compiled.exec(trail);
    if (matchObj == null || trail == '' || count == maxMatch - 1 && maxMatch > 0) {
      out[count] = trail;
      break;
    }
     else {
      out[count] = trail.substring(0, matchObj.index);
      trail = trail.substring(matchObj.index + matchObj[0].length, trail.length);
      compiled.lastIndex = 0;
      if (lastTrail == trail) {
        out[count] = trail.substring(0, 1);
        trail = trail.substring(1);
      }
      lastTrail = trail;
      count++;
    }
  }
  if (maxMatch == 0 && this$static.length > 0) {
    var lastNonEmpty = out.length;
    while (lastNonEmpty > 0 && out[lastNonEmpty - 1] == '') {
      --lastNonEmpty;
    }
    lastNonEmpty < out.length && out.splice(lastNonEmpty, out.length - lastNonEmpty);
  }
  var jr = __createArray(out.length);
  for (var i = 0; i < out.length; ++i) {
    jr[i] = out[i];
  }
  return jr;
}

function $substring(this$static, beginIndex){
  return this$static.substr(beginIndex, this$static.length - beginIndex);
}

function $substring_0(this$static, beginIndex, endIndex){
  return this$static.substr(beginIndex, endIndex - beginIndex);
}

function $trim(this$static){
  if (this$static.length == 0 || this$static[0] > ' ' && this$static[this$static.length - 1] > ' ') {
    return this$static;
  }
  var r1 = this$static.replace(/^(\s*)/, '');
  var r2 = r1.replace(/\s*$/, '');
  return r2;
}

function __createArray(numElements){
  return initDim(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, numElements, 0);
}

function __translateReplaceString(replaceStr){
  var pos;
  pos = 0;
  while (0 <= (pos = replaceStr.indexOf('\\', pos))) {
    replaceStr.charCodeAt(pos + 1) == 36?(replaceStr = replaceStr.substr(0, pos - 0) + '$' + $substring(replaceStr, ++pos)):(replaceStr = replaceStr.substr(0, pos - 0) + $substring(replaceStr, ++pos));
  }
  return replaceStr;
}

function __valueOf(x, start, end){
  x = x.slice(start, end);
  return String.fromCharCode.apply(null, x);
}

function compareTo_3(thisStr, otherStr){
  thisStr = String(thisStr);
  if (thisStr == otherStr) {
    return 0;
  }
  return thisStr < otherStr?-1:1;
}

function fromCodePoint(codePoint){
  var hiSurrogate, loSurrogate;
  if (codePoint >= 65536) {
    hiSurrogate = 55296 + (~~(codePoint - 65536) >> 10 & 1023) & 65535;
    loSurrogate = 56320 + (codePoint - 65536 & 1023) & 65535;
    return String.fromCharCode(hiSurrogate) + String.fromCharCode(loSurrogate);
  }
   else {
    return String.fromCharCode(codePoint & 65535);
  }
}

_ = String.prototype;
_.castableTypeMap$ = makeCastMap([Q$String, Q$Serializable, Q$CharSequence, Q$Comparable]);
_.compareTo$ = function compareTo_2(other){
  return compareTo_3(this, other);
}
;
_.equals$ = function equals_7(other){
  return $equals(this, other);
}
;
_.hashCode$ = function hashCode_9(){
  return getHashCode_0(this);
}
;
_.toString$ = _.toString;
function $clinit_String$HashCache(){
  $clinit_String$HashCache = nullMethod;
  back_0 = {};
  front = {};
}

function compute(str){
  var hashCode, i, n, nBatch;
  hashCode = 0;
  n = str.length;
  nBatch = n - 4;
  i = 0;
  while (i < nBatch) {
    hashCode = str.charCodeAt(i + 3) + 31 * (str.charCodeAt(i + 2) + 31 * (str.charCodeAt(i + 1) + 31 * (str.charCodeAt(i) + 31 * hashCode))) | 0;
    i += 4;
  }
  while (i < n) {
    hashCode = hashCode * 31 + $charAt(str, i++);
  }
  return hashCode | 0;
}

function getHashCode_0(str){
  $clinit_String$HashCache();
  var key = ':' + str;
  var result = front[key];
  if (result != null) {
    return result;
  }
  result = back_0[key];
  result == null && (result = compute(str));
  increment_0();
  return front[key] = result;
}

function increment_0(){
  if (count_0 == 256) {
    back_0 = front;
    front = {};
    count_0 = 0;
  }
  ++count_0;
}

var back_0, count_0 = 0, front;
function $append_4(this$static, x){
  $append_1(this$static.impl, x);
  return this$static;
}

function $append_5(this$static, x){
  $append_3(this$static.impl, x);
  return this$static;
}

function StringBuffer_0(){
  this.impl = new StringBufferImplAppend_0;
}

defineSeed(224, 1, makeCastMap([Q$CharSequence]), StringBuffer_0);
_.toString$ = function toString_15(){
  return this.impl.string;
}
;
function $$init(this$static){
  this$static.impl = new StringBufferImplAppend_0;
}

function $append_6(this$static, x){
  $appendNonNull(this$static.impl, String.fromCharCode(x));
  return this$static;
}

function $append_7(this$static, x){
  $append(this$static.impl, x);
  return this$static;
}

function $append_8(this$static, x){
  $append_0(this$static.impl, x);
  return this$static;
}

function $append_9(this$static, x){
  $append_1(this$static.impl, x);
  return this$static;
}

function $append_10(this$static, x){
  $append_2(this$static.impl, x);
  return this$static;
}

function $append_11(this$static, x){
  $append_3(this$static.impl, x);
  return this$static;
}

function $append_12(this$static, x){
  $appendNonNull(this$static.impl, String.fromCharCode.apply(null, x));
  return this$static;
}

function $charAt_0(this$static, index){
  return $charAt(this$static.impl.string, index);
}

function $setLength(this$static, newLength){
  var oldLength;
  oldLength = this$static.impl.string.length;
  newLength < oldLength?($replace(this$static.impl, newLength, oldLength) , this$static):newLength > oldLength && $append_12(this$static, initDim(_3C_classLit, makeCastMap([Q$Serializable]), -1, newLength - oldLength, 1));
}

function StringBuilder_0(){
  $$init(this);
}

function StringBuilder_1(s){
  $$init(this);
  $append_3(this.impl, s);
}

defineSeed(225, 1, makeCastMap([Q$CharSequence]), StringBuilder_0, StringBuilder_1);
_.toString$ = function toString_16(){
  return this.impl.string;
}
;
function arraycopy(src, srcOfs, dest, destOfs, len){
  var destComp, destEnd, destType, destlen, srcComp, srcType, srclen;
  if (src == null || dest == null) {
    throw new NullPointerException_0;
  }
  srcType = src.___clazz$;
  destType = dest.___clazz$;
  if ((srcType.modifiers & 4) == 0 || (destType.modifiers & 4) == 0) {
    throw new ArrayStoreException_1('Must be array types');
  }
  srcComp = srcType.componentType;
  destComp = destType.componentType;
  if (!((srcComp.modifiers & 1) != 0?srcComp == destComp:(destComp.modifiers & 1) == 0)) {
    throw new ArrayStoreException_1('Array types must match');
  }
  srclen = src.length;
  destlen = dest.length;
  if (srcOfs < 0 || destOfs < 0 || len < 0 || srcOfs + len > srclen || destOfs + len > destlen) {
    throw new IndexOutOfBoundsException_0;
  }
  if (((srcComp.modifiers & 1) == 0 || (srcComp.modifiers & 4) != 0) && srcType != destType) {
    if (src === dest && srcOfs < destOfs) {
      srcOfs += len;
      for (destEnd = destOfs + len; destEnd-- > destOfs;) {
        dest[destEnd] = src[--srcOfs];
      }
    }
     else {
      for (destEnd = destOfs + len; destOfs < destEnd;) {
        dest[destOfs++] = src[srcOfs++];
      }
    }
  }
   else {
    Array.prototype.splice.apply(dest, [destOfs, len].concat(src.slice(srcOfs, srcOfs + len)));
  }
}

function $get_1(this$static){
  this$static.object == null && (this$static.object = this$static.initialValue());
  return this$static.object;
}

defineSeed(227, 1, {});
_.initialValue = function initialValue(){
  return null;
}
;
_.object = null;
function UnsupportedOperationException_0(){
  RuntimeException_0.call(this);
}

function UnsupportedOperationException_1(message){
  RuntimeException_1.call(this, message);
}

defineSeed(228, 45, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), UnsupportedOperationException_0, UnsupportedOperationException_1);
function $clear_0(this$static){
  this$static.position_0 = 0;
  this$static.mark = -1;
  this$static.limit = this$static.capacity;
  return this$static;
}

function $position(this$static){
  if (0 > this$static.limit) {
    throw new IllegalArgumentException_0;
  }
  this$static.position_0 = 0;
  this$static.mark != -1 && this$static.mark > this$static.position_0 && (this$static.mark = -1);
  return this$static;
}

function Buffer_0(capacity){
  if (capacity < 0) {
    throw new IllegalArgumentException_0;
  }
  this.capacity = this.limit = capacity;
}

defineSeed(229, 1, {});
_.capacity = 0;
_.limit = 0;
_.mark = -1;
_.position_0 = 0;
function $$init_0(this$static){
  this$static.order = ($clinit_ByteOrder() , BIG_ENDIAN);
}

function $asIntBuffer(this$static){
  if (this$static.order != ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER)) {
    throw new RuntimeException_1('Native order supported only.');
  }
  return new IntBuffer_0($slice(this$static));
}

function $asShortBuffer(this$static){
  if (this$static.order != ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER)) {
    throw new RuntimeException_1('Native order supported only.');
  }
  return new ShortBuffer_0($slice(this$static));
}

function $compareTo(this$static, otherBuffer){
  var compareRemaining, otherByte, otherPos, thisByte, thisPos;
  compareRemaining = this$static.limit - this$static.position_0 < otherBuffer.limit - otherBuffer.position_0?this$static.limit - this$static.position_0:otherBuffer.limit - otherBuffer.position_0;
  thisPos = this$static.position_0;
  otherPos = otherBuffer.position_0;
  while (compareRemaining > 0) {
    thisByte = this$static.byteArray[thisPos];
    otherByte = otherBuffer.byteArray[otherPos];
    if (thisByte != otherByte) {
      return thisByte < otherByte?-1:1;
    }
    ++thisPos;
    ++otherPos;
    --compareRemaining;
  }
  return this$static.limit - this$static.position_0 - (otherBuffer.limit - otherBuffer.position_0);
}

function $get_2(this$static, index){
  return this$static.byteArray[index];
}

function $order(this$static, byteOrder){
  this$static.order = byteOrder;
  return this$static;
}

function $slice(this$static){
  var slice;
  slice = new ByteBuffer_2(this$static.byteArray.buffer, this$static.limit - this$static.position_0, this$static.byteArray.byteOffset + this$static.position_0);
  slice.order = this$static.order;
  return slice;
}

function ByteBuffer_0(capacity){
  ByteBuffer_1.call(this, new ArrayBuffer(capacity));
}

function ByteBuffer_1(buf){
  Buffer_0.call(this, buf.byteLength);
  $$init_0(this);
  this.byteArray = new Int8Array(buf);
}

function ByteBuffer_2(buffer, capacity, offset){
  Buffer_0.call(this, capacity);
  $$init_0(this);
  this.byteArray = new Int8Array(buffer, offset, capacity);
}

function allocateDirect(capacity){
  if (capacity < 0) {
    throw new IllegalArgumentException_0;
  }
  return new ByteBuffer_0(capacity);
}

defineSeed(230, 229, makeCastMap([Q$Comparable, Q$ByteBuffer, Q$HasArrayBufferView]), ByteBuffer_0, ByteBuffer_2);
_.compareTo$ = function compareTo_4(otherBuffer){
  return $compareTo(this, otherBuffer);
}
;
_.equals$ = function equals_8(other){
  var equalSoFar, myPosition, otherBuffer, otherPosition;
  if (!instanceOf(other, Q$ByteBuffer)) {
    return false;
  }
  otherBuffer = other;
  if (this.limit - this.position_0 != otherBuffer.limit - otherBuffer.position_0) {
    return false;
  }
  myPosition = this.position_0;
  otherPosition = otherBuffer.position_0;
  equalSoFar = true;
  while (equalSoFar && myPosition < this.limit) {
    equalSoFar = $get_2(this, myPosition++) == $get_2(otherBuffer, otherPosition++);
  }
  return equalSoFar;
}
;
_.getElementSize = function getElementSize(){
  return 1;
}
;
_.getElementType = function getElementType(){
  return 5120;
}
;
_.getTypedArray = function getTypedArray(){
  return this.byteArray;
}
;
_.hashCode$ = function hashCode_10(){
  var hash, myPosition;
  myPosition = this.position_0;
  hash = 0;
  while (myPosition < this.limit) {
    hash = hash + $get_2(this, myPosition++);
  }
  return hash;
}
;
_.toString$ = function toString_17(){
  var buf;
  buf = new StringBuffer_0;
  $append_5(buf, Ljava_nio_ByteBuffer_2_classLit.typeName);
  buf.impl.string += ', status: capacity=';
  $append_4(buf, this.capacity);
  buf.impl.string += ' position=';
  $append_4(buf, this.position_0);
  buf.impl.string += ' limit=';
  $append_4(buf, this.limit);
  return buf.impl.string;
}
;
_.byteArray = null;
function $clinit_ByteOrder(){
  $clinit_ByteOrder = nullMethod;
  BIG_ENDIAN = new ByteOrder_0('BIG_ENDIAN');
  LITTLE_ENDIAN = new ByteOrder_0('LITTLE_ENDIAN');
  NATIVE_ORDER = LITTLE_ENDIAN;
}

function ByteOrder_0(name_0){
  this.name_0 = name_0;
}

defineSeed(231, 1, {}, ByteOrder_0);
_.toString$ = function toString_18(){
  return this.name_0;
}
;
_.name_0 = null;
var BIG_ENDIAN, LITTLE_ENDIAN, NATIVE_ORDER = null;
function $compareTo_0(this$static, otherBuffer){
  var compareRemaining, otherFloat, otherPos, thisFloat, thisPos;
  compareRemaining = this$static.limit - this$static.position_0 < otherBuffer.limit - otherBuffer.position_0?this$static.limit - this$static.position_0:otherBuffer.limit - otherBuffer.position_0;
  thisPos = this$static.position_0;
  otherPos = otherBuffer.position_0;
  while (compareRemaining > 0) {
    thisFloat = this$static.floatArray[thisPos];
    otherFloat = otherBuffer.floatArray[otherPos];
    if (thisFloat != otherFloat && (thisFloat == thisFloat || otherFloat == otherFloat)) {
      return thisFloat < otherFloat?-1:1;
    }
    ++thisPos;
    ++otherPos;
    --compareRemaining;
  }
  return this$static.limit - this$static.position_0 - (otherBuffer.limit - otherBuffer.position_0);
}

function $get_3(this$static, index){
  return this$static.floatArray[index];
}

function $put_0(this$static, c){
  this$static.floatArray[this$static.position_0++] = c;
  return this$static;
}

function FloatBuffer_0(byteBuffer){
  Buffer_0.call(this, ~~byteBuffer.capacity >> 2);
  this.byteBuffer = byteBuffer;
  $clear_0(this.byteBuffer);
  this.floatArray = create_0(byteBuffer.byteArray.buffer, byteBuffer.byteArray.byteOffset, this.capacity);
}

defineSeed(232, 229, makeCastMap([Q$Comparable, Q$FloatBuffer, Q$HasArrayBufferView]), FloatBuffer_0);
_.compareTo$ = function compareTo_5(otherBuffer){
  return $compareTo_0(this, otherBuffer);
}
;
--></script>
<script><!--
_.equals$ = function equals_9(other){
  var equalSoFar, myPosition, otherBuffer, otherPosition;
  if (!instanceOf(other, Q$FloatBuffer)) {
    return false;
  }
  otherBuffer = other;
  if (this.limit - this.position_0 != otherBuffer.limit - otherBuffer.position_0) {
    return false;
  }
  myPosition = this.position_0;
  otherPosition = otherBuffer.position_0;
  equalSoFar = true;
  while (equalSoFar && myPosition < this.limit) {
    equalSoFar = $get_3(this, myPosition++) == $get_3(otherBuffer, otherPosition++);
  }
  return equalSoFar;
}
;
_.getElementSize = function getElementSize_0(){
  return 4;
}
;
_.getElementType = function getElementType_0(){
  return 5126;
}
;
_.getTypedArray = function getTypedArray_0(){
  return this.floatArray;
}
;
_.toString$ = function toString_19(){
  var buf;
  buf = new StringBuffer_0;
  $append_5(buf, Ljava_nio_FloatBuffer_2_classLit.typeName);
  buf.impl.string += ', status: capacity=';
  $append_4(buf, this.capacity);
  buf.impl.string += ' position=';
  $append_4(buf, this.position_0);
  buf.impl.string += ' limit=';
  $append_4(buf, this.limit);
  return buf.impl.string;
}
;
_.byteBuffer = null;
_.floatArray = null;
function $compareTo_1(this$static, otherBuffer){
  var compareRemaining, otherInt, otherPos, thisInt, thisPos;
  compareRemaining = this$static.limit - this$static.position_0 < otherBuffer.limit - otherBuffer.position_0?this$static.limit - this$static.position_0:otherBuffer.limit - otherBuffer.position_0;
  thisPos = this$static.position_0;
  otherPos = otherBuffer.position_0;
  while (compareRemaining > 0) {
    thisInt = this$static.intArray[thisPos];
    otherInt = otherBuffer.intArray[otherPos];
    if (thisInt != otherInt) {
      return thisInt < otherInt?-1:1;
    }
    ++thisPos;
    ++otherPos;
    --compareRemaining;
  }
  return this$static.limit - this$static.position_0 - (otherBuffer.limit - otherBuffer.position_0);
}

function $get_4(this$static, index){
  return this$static.intArray[index];
}

function IntBuffer_0(byteBuffer){
  Buffer_0.call(this, ~~byteBuffer.capacity >> 2);
  this.byteBuffer = byteBuffer;
  $clear_0(this.byteBuffer);
  this.intArray = create_2(byteBuffer.byteArray.buffer, byteBuffer.byteArray.byteOffset, this.capacity);
}

defineSeed(233, 229, makeCastMap([Q$Comparable, Q$IntBuffer, Q$HasArrayBufferView]), IntBuffer_0);
_.compareTo$ = function compareTo_6(otherBuffer){
  return $compareTo_1(this, otherBuffer);
}
;
_.equals$ = function equals_10(other){
  var equalSoFar, myPosition, otherBuffer, otherPosition;
  if (!instanceOf(other, Q$IntBuffer)) {
    return false;
  }
  otherBuffer = other;
  if (this.limit - this.position_0 != otherBuffer.limit - otherBuffer.position_0) {
    return false;
  }
  myPosition = this.position_0;
  otherPosition = otherBuffer.position_0;
  equalSoFar = true;
  while (equalSoFar && myPosition < this.limit) {
    equalSoFar = $get_4(this, myPosition++) == $get_4(otherBuffer, otherPosition++);
  }
  return equalSoFar;
}
;
_.getElementSize = function getElementSize_1(){
  return 4;
}
;
_.getElementType = function getElementType_1(){
  return 5124;
}
;
_.getTypedArray = function getTypedArray_1(){
  return this.intArray;
}
;
_.hashCode$ = function hashCode_11(){
  var hash, myPosition;
  myPosition = this.position_0;
  hash = 0;
  while (myPosition < this.limit) {
    hash = hash + $get_4(this, myPosition++);
  }
  return hash;
}
;
_.toString$ = function toString_20(){
  var buf;
  buf = new StringBuffer_0;
  $append_5(buf, Ljava_nio_IntBuffer_2_classLit.typeName);
  buf.impl.string += ', status: capacity=';
  $append_4(buf, this.capacity);
  buf.impl.string += ' position=';
  $append_4(buf, this.position_0);
  buf.impl.string += ' limit=';
  $append_4(buf, this.limit);
  return buf.impl.string;
}
;
_.byteBuffer = null;
_.intArray = null;
function $compareTo_2(this$static, otherBuffer){
  var compareRemaining, otherByte, otherPos, thisByte, thisPos;
  compareRemaining = this$static.limit - this$static.position_0 < otherBuffer.limit - otherBuffer.position_0?this$static.limit - this$static.position_0:otherBuffer.limit - otherBuffer.position_0;
  thisPos = this$static.position_0;
  otherPos = otherBuffer.position_0;
  while (compareRemaining > 0) {
    thisByte = this$static.shortArray[thisPos];
    otherByte = otherBuffer.shortArray[otherPos];
    if (thisByte != otherByte) {
      return thisByte < otherByte?-1:1;
    }
    ++thisPos;
    ++otherPos;
    --compareRemaining;
  }
  return this$static.limit - this$static.position_0 - (otherBuffer.limit - otherBuffer.position_0);
}

function $get_5(this$static, index){
  return this$static.shortArray[index];
}

function $put_1(this$static, c){
  this$static.shortArray[this$static.position_0++] = c;
  return this$static;
}

function ShortBuffer_0(byteBuffer){
  Buffer_0.call(this, ~~byteBuffer.capacity >> 1);
  this.byteBuffer = byteBuffer;
  $clear_0(this.byteBuffer);
  this.shortArray = create_1(byteBuffer.byteArray.buffer, byteBuffer.byteArray.byteOffset, this.capacity);
}

defineSeed(234, 229, makeCastMap([Q$Comparable, Q$ShortBuffer, Q$HasArrayBufferView]), ShortBuffer_0);
_.compareTo$ = function compareTo_7(otherBuffer){
  return $compareTo_2(this, otherBuffer);
}
;
_.equals$ = function equals_11(other){
  var equalSoFar, myPosition, otherBuffer, otherPosition;
  if (!instanceOf(other, Q$ShortBuffer)) {
    return false;
  }
  otherBuffer = other;
  if (this.limit - this.position_0 != otherBuffer.limit - otherBuffer.position_0) {
    return false;
  }
  myPosition = this.position_0;
  otherPosition = otherBuffer.position_0;
  equalSoFar = true;
  while (equalSoFar && myPosition < this.limit) {
    equalSoFar = $get_5(this, myPosition++) == $get_5(otherBuffer, otherPosition++);
  }
  return equalSoFar;
}
;
_.getElementSize = function getElementSize_2(){
  return 2;
}
;
_.getElementType = function getElementType_2(){
  return 5122;
}
;
_.getTypedArray = function getTypedArray_2(){
  return this.shortArray;
}
;
_.hashCode$ = function hashCode_12(){
  var hash, myPosition;
  myPosition = this.position_0;
  hash = 0;
  while (myPosition < this.limit) {
    hash = hash + $get_5(this, myPosition++);
  }
  return hash;
}
;
_.toString$ = function toString_21(){
  var buf;
  buf = new StringBuffer_0;
  $append_5(buf, Ljava_nio_ShortBuffer_2_classLit.typeName);
  buf.impl.string += ', status: capacity=';
  $append_4(buf, this.capacity);
  buf.impl.string += ' position=';
  $append_4(buf, this.position_0);
  buf.impl.string += ' limit=';
  $append_4(buf, this.limit);
  return buf.impl.string;
}
;
_.byteBuffer = null;
_.shortArray = null;
function $addAllHashEntries(this$static, dest){
  var hashCodeMap = this$static.hashCodeMap;
  for (var hashCode in hashCodeMap) {
    var hashCodeInt = parseInt(hashCode, 10);
    if (hashCode == hashCodeInt) {
      var array = hashCodeMap[hashCodeInt];
      for (var i = 0, c = array.length; i < c; ++i) {
        dest.add(array[i]);
      }
    }
  }
}

function $addAllStringEntries(this$static, dest){
  var stringMap = this$static.stringMap;
  for (var key in stringMap) {
    if (key.charCodeAt(0) == 58) {
      var entry = new AbstractHashMap$MapEntryString_0(this$static, key.substring(1));
      dest.add(entry);
    }
  }
}

function $clearImpl(this$static){
  this$static.hashCodeMap = [];
  this$static.stringMap = {};
  this$static.nullSlotLive = false;
  this$static.nullSlot = null;
  this$static.size = 0;
}

function $containsKey_0(this$static, key){
  return key == null?this$static.nullSlotLive:instanceOf(key, Q$String)?':' + key in this$static.stringMap:$hasHashValue(this$static, key, ~~hashCode__devirtual$(key));
}

function $get_6(this$static, key){
  return key == null?this$static.nullSlot:instanceOf(key, Q$String)?this$static.stringMap[':' + key]:$getHashValue(this$static, key, ~~hashCode__devirtual$(key));
}

function $getHashValue(this$static, key, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        return entry.getValue();
      }
    }
  }
  return null;
}

function $getStringValue(this$static, key){
  return this$static.stringMap[':' + key];
}

function $hasHashValue(this$static, key, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        return true;
      }
    }
  }
  return false;
}

function $put_2(this$static, key, value){
  return key == null?$putNullSlot(this$static, value):instanceOf(key, Q$String)?$putStringValue(this$static, key, value):$putHashValue(this$static, key, value, ~~hashCode__devirtual$(key));
}

function $putHashValue(this$static, key, value, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        var previous = entry.getValue();
        entry.setValue(value);
        return previous;
      }
    }
  }
   else {
    array = this$static.hashCodeMap[hashCode] = [];
  }
  var entry = new MapEntryImpl_0(key, value);
  array.push(entry);
  ++this$static.size;
  return null;
}

function $putNullSlot(this$static, value){
  var result;
  result = this$static.nullSlot;
  this$static.nullSlot = value;
  if (!this$static.nullSlotLive) {
    this$static.nullSlotLive = true;
    ++this$static.size;
  }
  return result;
}

function $putStringValue(this$static, key, value){
  var result, stringMap = this$static.stringMap;
  key = ':' + key;
  key in stringMap?(result = stringMap[key]):++this$static.size;
  stringMap[key] = value;
  return result;
}

function $remove_6(this$static, key){
  return key == null?$removeNullSlot(this$static):instanceOf(key, Q$String)?$removeStringValue(this$static, key):$removeHashValue(this$static, key, ~~hashCode__devirtual$(key));
}

function $removeHashValue(this$static, key, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        array.length == 1?delete this$static.hashCodeMap[hashCode]:array.splice(i, 1);
        --this$static.size;
        return entry.getValue();
      }
    }
  }
  return null;
}

function $removeNullSlot(this$static){
  var result;
  result = this$static.nullSlot;
  this$static.nullSlot = null;
  if (this$static.nullSlotLive) {
    this$static.nullSlotLive = false;
    --this$static.size;
  }
  return result;
}

function $removeStringValue(this$static, key){
  var result, stringMap = this$static.stringMap;
  key = ':' + key;
  if (key in stringMap) {
    result = stringMap[key];
    --this$static.size;
    delete stringMap[key];
  }
  return result;
}

defineSeed(235, 152, makeCastMap([Q$Map]));
_.containsKey = function containsKey_1(key){
  return $containsKey_0(this, key);
}
;
_.entrySet_0 = function entrySet_1(){
  return new AbstractHashMap$EntrySet_0(this);
}
;
_.equalsBridge = function equalsBridge(value1, value2){
  return maskUndefined(value1) === maskUndefined(value2) || value1 != null && equals__devirtual$(value1, value2);
}
;
_.get_0 = function get_3(key){
  return $get_6(this, key);
}
;
_.put = function put_1(key, value){
  return $put_2(this, key, value);
}
;
_.remove_1 = function remove_11(key){
  return $remove_6(this, key);
}
;
_.size_0 = function size_4(){
  return this.size;
}
;
_.hashCodeMap = null;
_.nullSlot = null;
_.nullSlotLive = false;
_.size = 0;
_.stringMap = null;
function $contains(this$static, o){
  var entry, key, value;
  if (instanceOf(o, Q$Map$Entry)) {
    entry = o;
    key = entry.getKey();
    if ($containsKey_0(this$static.this$0, key)) {
      value = $get_6(this$static.this$0, key);
      return $equals_0(entry.getValue(), value);
    }
  }
  return false;
}

function AbstractHashMap$EntrySet_0(this$0){
  this.this$0 = this$0;
}

defineSeed(236, 156, makeCastMap([Q$Set]), AbstractHashMap$EntrySet_0);
_.contains_0 = function contains_3(o){
  return $contains(this, o);
}
;
_.iterator = function iterator_4(){
  return new AbstractHashMap$EntrySetIterator_0(this.this$0);
}
;
_.remove = function remove_12(entry){
  var key;
  if ($contains(this, entry)) {
    key = entry.getKey();
    $remove_6(this.this$0, key);
    return true;
  }
  return false;
}
;
_.size_0 = function size_5(){
  return this.this$0.size;
}
;
_.this$0 = null;
function $next_1(this$static){
  return this$static.last = $next_2(this$static.iter);
}

function $remove_7(this$static){
  if (!this$static.last) {
    throw new IllegalStateException_1('Must call next() before remove().');
  }
   else {
    $remove_8(this$static.iter);
    $remove_6(this$static.this$0, this$static.last.getKey());
    this$static.last = null;
  }
}

function AbstractHashMap$EntrySetIterator_0(this$0){
  var list;
  this.this$0 = this$0;
  list = new ArrayList_0;
  this$0.nullSlotLive && $add_0(list, new AbstractHashMap$MapEntryNull_0(this$0));
  $addAllStringEntries(this$0, list);
  $addAllHashEntries(this$0, list);
  this.iter = new AbstractList$IteratorImpl_0(list);
}

defineSeed(237, 1, {}, AbstractHashMap$EntrySetIterator_0);
_.hasNext = function hasNext_1(){
  return $hasNext(this.iter);
}
;
_.next_0 = function next_2(){
  return $next_1(this);
}
;
_.remove_2 = function remove_13(){
  $remove_7(this);
}
;
_.iter = null;
_.last = null;
_.this$0 = null;
defineSeed(239, 1, makeCastMap([Q$Map$Entry]));
_.equals$ = function equals_12(other){
  var entry;
  if (instanceOf(other, Q$Map$Entry)) {
    entry = other;
    if (equalsWithNullCheck(this.getKey(), entry.getKey()) && equalsWithNullCheck(this.getValue(), entry.getValue())) {
      return true;
    }
  }
  return false;
}
;
_.hashCode$ = function hashCode_13(){
  var keyHash, valueHash;
  keyHash = 0;
  valueHash = 0;
  this.getKey() != null && (keyHash = hashCode__devirtual$(this.getKey()));
  this.getValue() != null && (valueHash = hashCode__devirtual$(this.getValue()));
  return keyHash ^ valueHash;
}
;
_.toString$ = function toString_22(){
  return this.getKey() + '=' + this.getValue();
}
;
function AbstractHashMap$MapEntryNull_0(this$0){
  this.this$0 = this$0;
}

defineSeed(238, 239, makeCastMap([Q$Map$Entry]), AbstractHashMap$MapEntryNull_0);
_.getKey = function getKey_0(){
  return null;
}
;
_.getValue = function getValue_0(){
  return this.this$0.nullSlot;
}
;
_.setValue = function setValue_0(object){
  return $putNullSlot(this.this$0, object);
}
;
_.this$0 = null;
function AbstractHashMap$MapEntryString_0(this$0, key){
  this.this$0 = this$0;
  this.key_0 = key;
}

defineSeed(240, 239, makeCastMap([Q$Map$Entry]), AbstractHashMap$MapEntryString_0);
_.getKey = function getKey_1(){
  return this.key_0;
}
;
_.getValue = function getValue_1(){
  return $getStringValue(this.this$0, this.key_0);
}
;
_.setValue = function setValue_1(object){
  return $putStringValue(this.this$0, this.key_0, object);
}
;
_.key_0 = null;
_.this$0 = null;
function $hasNext(this$static){
  return this$static.i < this$static.this$0_0.size_0();
}

function $next_2(this$static){
  if (this$static.i >= this$static.this$0_0.size_0()) {
    throw new NoSuchElementException_0;
  }
  return this$static.this$0_0.get(this$static.last = this$static.i++);
}

function $remove_8(this$static){
  if (this$static.last < 0) {
    throw new IllegalStateException_0;
  }
  this$static.this$0_0.remove_0(this$static.last);
  this$static.i = this$static.last;
  this$static.last = -1;
}

function AbstractList$IteratorImpl_0(this$0){
  this.this$0_0 = this$0;
}

defineSeed(241, 1, {}, AbstractList$IteratorImpl_0);
_.hasNext = function hasNext_2(){
  return $hasNext(this);
}
;
_.next_0 = function next_3(){
  return $next_2(this);
}
;
_.remove_2 = function remove_14(){
  $remove_8(this);
}
;
_.i = 0;
_.last = -1;
_.this$0_0 = null;
function $previous(this$static){
  if (this$static.i <= 0) {
    throw new NoSuchElementException_0;
  }
  return this$static.this$0.get(this$static.last = --this$static.i);
}

function AbstractList$ListIteratorImpl_0(this$0, start){
  var size;
  this.this$0 = this$0;
  this.this$0_0 = this$0;
  size = this$0.size_0();
  (start < 0 || start > size) && indexOutOfBounds(start, size);
  this.i = start;
}

defineSeed(242, 241, {}, AbstractList$ListIteratorImpl_0);
_.this$0 = null;
function $iterator(this$static){
  var outerIter;
  outerIter = new AbstractHashMap$EntrySetIterator_0(this$static.val$entrySet.this$0);
  return new AbstractMap$1$1_0(outerIter);
}

function AbstractMap$1_0(this$0, val$entrySet){
  this.this$0 = this$0;
  this.val$entrySet = val$entrySet;
}

defineSeed(243, 156, makeCastMap([Q$Set]), AbstractMap$1_0);
_.contains_0 = function contains_4(key){
  return $containsKey_0(this.this$0, key);
}
;
_.iterator = function iterator_5(){
  return $iterator(this);
}
;
_.size_0 = function size_6(){
  return this.val$entrySet.this$0.size;
}
;
_.this$0 = null;
_.val$entrySet = null;
function AbstractMap$1$1_0(val$outerIter){
  this.val$outerIter = val$outerIter;
}

defineSeed(244, 1, {}, AbstractMap$1$1_0);
_.hasNext = function hasNext_3(){
  return $hasNext(this.val$outerIter.iter);
}
;
_.next_0 = function next_4(){
  var entry;
  entry = $next_1(this.val$outerIter);
  return entry.getKey();
}
;
_.remove_2 = function remove_15(){
  $remove_7(this.val$outerIter);
}
;
_.val$outerIter = null;
function insertionSort(array, low, high, comp){
  var i, j, t;
  for (i = low + 1; i < high; ++i) {
    for (j = i; j > low && comp.compare(array[j - 1], array[j]) > 0; --j) {
      t = array[j];
      setCheck(array, j, array[j - 1]);
      setCheck(array, j - 1, t);
    }
  }
}

function merge(src, srcLow, srcMid, srcHigh, dest, destLow, destHigh, comp){
  var topIdx;
  topIdx = srcMid;
  while (destLow < destHigh) {
    topIdx >= srcHigh || srcLow < srcMid && comp.compare(src[srcLow], src[topIdx]) <= 0?setCheck(dest, destLow++, src[srcLow++]):setCheck(dest, destLow++, src[topIdx++]);
  }
}

function mergeSort(x, fromIndex, toIndex, comp){
  var temp, a, result;
  temp = (a = x , result = a.slice(fromIndex, toIndex) , initValues(a.___clazz$, a.castableTypeMap$, a.queryId$, result) , result);
  mergeSort_0(temp, x, fromIndex, toIndex, -fromIndex, comp);
}

function mergeSort_0(temp, array, low, high, ofs, comp){
  var length_0, tempHigh, tempLow, tempMid;
  length_0 = high - low;
  if (length_0 < 7) {
    insertionSort(array, low, high, comp);
    return;
  }
  tempLow = low + ofs;
  tempHigh = high + ofs;
  tempMid = tempLow + (~~(tempHigh - tempLow) >> 1);
  mergeSort_0(array, temp, tempLow, tempMid, -ofs, comp);
  mergeSort_0(array, temp, tempMid, tempHigh, -ofs, comp);
  if (comp.compare(temp[tempMid - 1], temp[tempMid]) <= 0) {
    while (low < high) {
      setCheck(array, low++, temp[tempLow++]);
    }
    return;
  }
  merge(temp, tempLow, tempMid, tempHigh, array, low, high, comp);
}

function sort(x, toIndex, c){
  verifySortIndices(toIndex, x.length);
  mergeSort(x, 0, toIndex, c?c:($clinit_Comparators() , $clinit_Comparators() , NATURAL));
}

function verifySortIndices(toIndex, length_0){
  if (0 > toIndex) {
    throw new IllegalArgumentException_1('fromIndex(0) > toIndex(' + toIndex + ')');
  }
  if (toIndex > length_0) {
    throw new ArrayIndexOutOfBoundsException_0('fromIndex(0) or toIndex(' + toIndex + ') out of bounds (0 - ' + length_0 + ')');
  }
}

function $clinit_Collections(){
  $clinit_Collections = nullMethod;
  EMPTY_LIST = new Collections$EmptyList_0;
}

var EMPTY_LIST;
function Collections$EmptyList_0(){
}

defineSeed(247, 20, makeCastMap([Q$Serializable, Q$List]), Collections$EmptyList_0);
_.contains_0 = function contains_5(object){
  return false;
}
;
_.get = function get_4(location_0){
  throw new IndexOutOfBoundsException_0;
}
;
_.size_0 = function size_7(){
  return 0;
}
;
function $clinit_Comparators(){
  $clinit_Comparators = nullMethod;
  NATURAL = new Comparators$1_0;
}

var NATURAL;
function Comparators$1_0(){
}

defineSeed(249, 1, {}, Comparators$1_0);
_.compare = function compare(o1, o2){
  return o1.compareTo$(o2);
}
;
function EmptyStackException_0(){
  RuntimeException_0.call(this);
}

defineSeed(250, 45, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), EmptyStackException_0);
function $equals_0(value1, value2){
  return maskUndefined(value1) === maskUndefined(value2) || value1 != null && equals__devirtual$(value1, value2);
}

function HashMap_0(){
  $clearImpl(this);
}

defineSeed(251, 235, makeCastMap([Q$Serializable, Q$Map]), HashMap_0);
function $add_4(this$static, o){
  var old;
  old = $put_2(this$static.map, o, this$static);
  return old == null;
}

function $contains_0(this$static, o){
  return $containsKey_0(this$static.map, o);
}

function $remove_9(this$static, o){
  return $remove_6(this$static.map, o) != null;
}

function HashSet_0(){
  this.map = new HashMap_0;
}

defineSeed(252, 156, makeCastMap([Q$Serializable, Q$Set]), HashSet_0);
_.add = function add_4(o){
  return $add_4(this, o);
}
;
_.contains_0 = function contains_6(o){
  return $containsKey_0(this.map, o);
}
;
_.isEmpty = function isEmpty_2(){
  return this.map.size == 0;
}
;
_.iterator = function iterator_6(){
  return $iterator($keySet(this.map));
}
;
_.remove = function remove_16(o){
  return $remove_9(this, o);
}
;
_.size_0 = function size_8(){
  return this.map.size;
}
;
_.toString$ = function toString_23(){
  return $toString($keySet(this.map));
}
;
_.map = null;
function MapEntryImpl_0(key, value){
  this.key_0 = key;
  this.value_0 = value;
}

defineSeed(253, 239, makeCastMap([Q$Map$Entry]), MapEntryImpl_0);
_.getKey = function getKey_2(){
  return this.key_0;
}
;
_.getValue = function getValue_2(){
  return this.value_0;
}
;
_.setValue = function setValue_2(value){
  var old;
  old = this.value_0;
  this.value_0 = value;
  return old;
}
;
_.key_0 = null;
_.value_0 = null;
function NoSuchElementException_0(){
  RuntimeException_0.call(this);
}

defineSeed(254, 45, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), NoSuchElementException_0);
function $add_5(this$static, o){
  return $add_0(this$static.arrayList, o);
}

defineSeed(256, 20, makeCastMap([Q$Serializable, Q$List]));
_.add_0 = function add_5(index, o){
  $add(this.arrayList, index, o);
}
;
_.add = function add_6(o){
  return $add_0(this.arrayList, o);
}
;
_.contains_0 = function contains_7(elem){
  return $indexOf(this.arrayList, elem, 0) != -1;
}
;
_.get = function get_5(index){
  return $get(this.arrayList, index);
}
;
_.isEmpty = function isEmpty_3(){
  return this.arrayList.size == 0;
}
;
_.iterator = function iterator_7(){
  return new AbstractList$IteratorImpl_0(this.arrayList);
}
;
_.remove_0 = function remove_17(index){
  return $remove(this.arrayList, index);
}
;
_.size_0 = function size_9(){
  return this.arrayList.size;
}
;
_.toString$ = function toString_24(){
  return $toString(this.arrayList);
}
;
_.arrayList = null;
function $pop(this$static){
  var sz;
  sz = this$static.arrayList.size;
  if (sz > 0) {
    return $remove(this$static.arrayList, sz - 1);
  }
   else {
    throw new EmptyStackException_0;
  }
}

function Stack_0(){
  this.arrayList = new ArrayList_0;
}

defineSeed(255, 256, makeCastMap([Q$Serializable, Q$List]), Stack_0);
function equalsWithNullCheck(a, b){
  return maskUndefined(a) === maskUndefined(b) || a != null && equals__devirtual$(a, b);
}

function $shouldCollide(fixtureA, fixtureB){
  var collide, filterA, filterB;
  filterA = fixtureA.m_filter;
  filterB = fixtureB.m_filter;
  if (filterA.groupIndex == filterB.groupIndex && filterA.groupIndex != 0) {
    return filterA.groupIndex > 0;
  }
  collide = (filterA.maskBits & filterB.categoryBits) != 0 && (filterA.categoryBits & filterB.maskBits) != 0;
  return collide;
}

function ContactFilter_0(){
}

defineSeed(258, 1, {}, ContactFilter_0);
function ContactImpulse_0(){
  initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, ($clinit_Settings() , 2), 1);
  initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 2, 1);
}

defineSeed(259, 1, {}, ContactImpulse_0);
function $drawPolygon(){
  var i;
  for (i = 0; i < 3; i += 1) {
  }
}

defineSeed(260, 1, {});
_.m_drawFlags = 0;
_.viewportTransform = null;
function $combine(this$static, aabb1, aab){
  this$static.lowerBound.x = aabb1.lowerBound.x < aab.lowerBound.x?aabb1.lowerBound.x:aab.lowerBound.x;
  this$static.lowerBound.y = aabb1.lowerBound.y < aab.lowerBound.y?aabb1.lowerBound.y:aab.lowerBound.y;
  this$static.upperBound.x = aabb1.upperBound.x > aab.upperBound.x?aabb1.upperBound.x:aab.upperBound.x;
  this$static.upperBound.y = aabb1.upperBound.y > aab.upperBound.y?aabb1.upperBound.y:aab.upperBound.y;
}

function $contains_1(this$static, aabb){
  return this$static.lowerBound.x > aabb.lowerBound.x && this$static.lowerBound.y > aabb.lowerBound.y && aabb.upperBound.x > this$static.upperBound.x && aabb.upperBound.y > this$static.upperBound.y;
}

function $getCenterToOut(this$static, out){
  out.x = (this$static.lowerBound.x + this$static.upperBound.x) * 0.5;
  out.y = (this$static.lowerBound.y + this$static.upperBound.y) * 0.5;
}

function $getVertices(this$static, argRay){
  $set_14(argRay[0], this$static.lowerBound);
  $set_14(argRay[1], this$static.lowerBound);
  argRay[1].x += this$static.upperBound.x - this$static.lowerBound.x;
  $set_14(argRay[2], this$static.upperBound);
  $set_14(argRay[3], this$static.upperBound);
  argRay[3].x -= this$static.upperBound.x - this$static.lowerBound.x;
}

function $set_1(this$static, aabb){
  $set_14(this$static.lowerBound, aabb.lowerBound);
  $set_14(this$static.upperBound, aabb.upperBound);
}

function AABB_0(){
  this.lowerBound = new Vec2_0;
  this.upperBound = new Vec2_0;
}

function testOverlap(a, b){
  if (b.lowerBound.x - a.upperBound.x > 0 || b.lowerBound.y - a.upperBound.y > 0) {
    return false;
  }
  if (a.lowerBound.x - b.upperBound.x > 0 || a.lowerBound.y - b.upperBound.y > 0) {
    return false;
  }
  return true;
}

defineSeed(261, 1, makeCastMap([Q$AABB]), AABB_0);
_.toString$ = function toString_25(){
  var s;
  s = 'AABB[' + this.lowerBound + ' . ' + this.upperBound + ']';
  return s;
}
;
_.lowerBound = null;
_.upperBound = null;
function $collideCircles(this$static, manifold, circle1, xfA, circle2, xfB){
  var distSqr, radius;
  manifold.pointCount = 0;
  mulToOut_0(xfA, circle1.m_p, this$static.pA);
  mulToOut_0(xfB, circle2.m_p, this$static.pB);
  $subLocal($set_14(this$static.d, this$static.pB), this$static.pA);
  distSqr = dot_0(this$static.d, this$static.d);
  radius = circle1.m_radius + circle2.m_radius;
  if (distSqr > radius * radius) {
    return;
  }
  manifold.type_0 = ($clinit_Manifold$ManifoldType() , CIRCLES);
  $set_14(manifold.localPoint, circle1.m_p);
  $setZero(manifold.localNormal);
  manifold.pointCount = 1;
  $set_14(manifold.points[0].localPoint, circle2.m_p);
  $zero(manifold.points[0].id_0);
}

--></script>
<script><!--
function $collidePolygonAndCircle(this$static, manifold, xfA, circle, xfB){
  var i, normalIndex, normals, radius, s, separation, u1, u2, v1, v2, vertIndex2, vertexCount, vertices;
  manifold.pointCount = 0;
  mulToOut_0(xfB, circle.m_p, this$static.c);
  mulTransToOut_0(xfA, this$static.c, this$static.cLocal);
  normalIndex = 0;
  separation = 1.401298464324817E-45;
  radius = null.nullField + circle.m_radius;
  vertexCount = null.nullField;
  vertices = null.nullField;
  normals = null.nullField;
  for (i = 0; i < vertexCount; ++i) {
    $subLocal($set_14(this$static.temp, this$static.cLocal), vertices[i]);
    s = dot_0(normals[i], this$static.temp);
    if (s > radius) {
      return;
    }
    if (s > separation) {
      separation = s;
      normalIndex = i;
    }
  }
  vertIndex2 = normalIndex + 1 < vertexCount?normalIndex + 1:0;
  v1 = vertices[normalIndex];
  v2 = vertices[vertIndex2];
  if (separation < 1.1920928955078125E-7) {
    manifold.pointCount = 1;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    $set_14(manifold.localNormal, normals[normalIndex]);
    $mulLocal($addLocal($set_14(manifold.localPoint, v1), v2), 0.5);
    $set_14(manifold.points[0].localPoint, circle.m_p);
    $zero(manifold.points[0].id_0);
    return;
  }
  $subLocal($set_14(this$static.temp, this$static.cLocal), v1);
  $subLocal($set_14(this$static.temp2, v2), v1);
  u1 = dot_0(this$static.temp, this$static.temp2);
  $subLocal($set_14(this$static.temp, this$static.cLocal), v2);
  $subLocal($set_14(this$static.temp2, v1), v2);
  u2 = dot_0(this$static.temp, this$static.temp2);
  if (u1 <= 0) {
    if (distanceSquared(this$static.cLocal, v1) > radius * radius) {
      return;
    }
    manifold.pointCount = 1;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    $subLocal($set_14(manifold.localNormal, this$static.cLocal), v1);
    $normalize_0(manifold.localNormal);
    $set_14(manifold.localPoint, v1);
    $set_14(manifold.points[0].localPoint, circle.m_p);
    $zero(manifold.points[0].id_0);
  }
   else if (u2 <= 0) {
    if (distanceSquared(this$static.cLocal, v2) > radius * radius) {
      return;
    }
    manifold.pointCount = 1;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    $subLocal($set_14(manifold.localNormal, this$static.cLocal), v2);
    $normalize_0(manifold.localNormal);
    $set_14(manifold.localPoint, v2);
    $set_14(manifold.points[0].localPoint, circle.m_p);
    $zero(manifold.points[0].id_0);
  }
   else {
    $mulLocal($addLocal($set_14(this$static.temp, v1), v2), 0.5);
    $subLocal($set_14(this$static.temp2, this$static.cLocal), this$static.temp);
    separation = dot_0(this$static.temp2, normals[normalIndex]);
    if (separation > radius) {
      return;
    }
    manifold.pointCount = 1;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    $set_14(manifold.localNormal, normals[normalIndex]);
    $set_14(manifold.localPoint, this$static.temp);
    $set_14(manifold.points[0].localPoint, circle.m_p);
    $zero(manifold.points[0].id_0);
  }
}

function $collidePolygons(this$static, manifold, xfA, xfB){
  var count1, cp, edge1, flip, frontOffset, i, np, pointCount, separation, sideOffset1, sideOffset2, totalRadius, vertices1, xf1, xf2;
  manifold.pointCount = 0;
  totalRadius = null.nullField + null.nullField;
  $findMaxSeparation(this$static, this$static.results1, xfA, xfB);
  if (this$static.results1.separation > totalRadius) {
    return;
  }
  $findMaxSeparation(this$static, this$static.results2, xfB, xfA);
  if (this$static.results2.separation > totalRadius) {
    return;
  }
  if (this$static.results2.separation > 0.9800000190734863 * this$static.results1.separation + 0.0010000000474974513) {
    xf1 = xfB;
    xf2 = xfA;
    edge1 = this$static.results2.edgeIndex;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_B);
    flip = 1;
  }
   else {
    xf1 = xfA;
    xf2 = xfB;
    edge1 = this$static.results1.edgeIndex;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    flip = 0;
  }
  $findIncidentEdge(this$static, this$static.incidentEdge, xf1, edge1, xf2);
  count1 = null.nullField;
  vertices1 = null.nullField;
  $set_14(this$static.v11, vertices1[edge1]);
  $set_14(this$static.v12, edge1 + 1 < count1?vertices1[edge1 + 1]:vertices1[0]);
  $subLocal($set_14(this$static.localTangent, this$static.v12), this$static.v11);
  $normalize_0(this$static.localTangent);
  crossToOut_0(this$static.localTangent, 1, this$static.localNormal);
  $mulLocal($addLocal($set_14(this$static.planePoint, this$static.v11), this$static.v12), 0.5);
  mulToOut(xf1.R, this$static.localTangent, this$static.tangent);
  crossToOut_0(this$static.tangent, 1, this$static.normal);
  mulToOut_0(xf1, this$static.v11, this$static.v11);
  mulToOut_0(xf1, this$static.v12, this$static.v12);
  frontOffset = dot_0(this$static.normal, this$static.v11);
  sideOffset1 = -dot_0(this$static.tangent, this$static.v11) + totalRadius;
  sideOffset2 = dot_0(this$static.tangent, this$static.v12) + totalRadius;
  $negateLocal(this$static.tangent);
  np = clipSegmentToLine(this$static.clipPoints1, this$static.incidentEdge, this$static.tangent, sideOffset1);
  $negateLocal(this$static.tangent);
  if (np < 2) {
    return;
  }
  np = clipSegmentToLine(this$static.clipPoints2, this$static.clipPoints1, this$static.tangent, sideOffset2);
  if (np < 2) {
    return;
  }
  $set_14(manifold.localNormal, this$static.localNormal);
  $set_14(manifold.localPoint, this$static.planePoint);
  pointCount = 0;
  for (i = 0; i < ($clinit_Settings() , 2); ++i) {
    separation = dot_0(this$static.normal, this$static.clipPoints2[i].v) - frontOffset;
    if (separation <= totalRadius) {
      cp = manifold.points[pointCount];
      mulTransToOut_0(xf2, this$static.clipPoints2[i].v, cp.localPoint);
      $set_3(cp.id_0, this$static.clipPoints2[i].id_0);
      cp.id_0.features.flip = flip;
      ++pointCount;
    }
  }
  manifold.pointCount = pointCount;
}

function $edgeSeparation(this$static, xf1, edge1, xf2){
  var count2, dot, i, index, minDot, normals1, separation, vertices1, vertices2;
  vertices1 = null.nullField;
  normals1 = null.nullField;
  count2 = null.nullField;
  vertices2 = null.nullField;
  mulToOut(xf1.R, normals1[edge1], this$static.normal1World);
  mulTransToOut(xf2.R, this$static.normal1World, this$static.normal1);
  index = 0;
  minDot = 3.4028234663852886E38;
  for (i = 0; i < count2; ++i) {
    dot = dot_0(vertices2[i], this$static.normal1);
    if (dot < minDot) {
      minDot = dot;
      index = i;
    }
  }
  mulToOut_0(xf1, vertices1[edge1], this$static.v1);
  mulToOut_0(xf2, vertices2[index], this$static.v2);
  separation = dot_0($subLocal(this$static.v2, this$static.v1), this$static.normal1World);
  return separation;
}

function $findIncidentEdge(this$static, c, xf1, edge1, xf2){
  var count2, dot, i, i2, index, minDot, normals1, normals2, vertices2;
  normals1 = null.nullField;
  count2 = null.nullField;
  vertices2 = null.nullField;
  normals2 = null.nullField;
  mulToOut(xf1.R, normals1[edge1], this$static.normal1);
  mulTransToOut(xf2.R, this$static.normal1, this$static.normal1);
  index = 0;
  minDot = 3.4028234663852886E38;
  for (i = 0; i < count2; ++i) {
    dot = dot_0(this$static.normal1, normals2[i]);
    if (dot < minDot) {
      minDot = dot;
      index = i;
    }
  }
  i2 = index + 1 < count2?index + 1:0;
  mulToOut_0(xf2, vertices2[index], c[0].v);
  c[0].id_0.features.referenceEdge = edge1;
  c[0].id_0.features.incidentEdge = index;
  c[0].id_0.features.incidentVertex = 0;
  mulToOut_0(xf2, vertices2[i2], c[1].v);
  c[1].id_0.features.referenceEdge = edge1;
  c[1].id_0.features.incidentEdge = i2;
  c[1].id_0.features.incidentVertex = 1;
}

function $findMaxSeparation(this$static, results, xf1, xf2){
  var bestEdge, bestSeparation, count1, dot, edge, i, increment, maxDot, nextEdge, normals1, prevEdge, s, sNext, sPrev;
  count1 = null.nullField;
  normals1 = null.nullField;
  mulToOut_0(xf2, null.nullField, this$static.d);
  mulToOut_0(xf1, null.nullField, this$static.temp);
  $subLocal(this$static.d, this$static.temp);
  mulTransToOut(xf1.R, this$static.d, this$static.dLocal1);
  edge = 0;
  maxDot = 1.401298464324817E-45;
  for (i = 0; i < count1; ++i) {
    dot = dot_0(normals1[i], this$static.dLocal1);
    if (dot > maxDot) {
      maxDot = dot;
      edge = i;
    }
  }
  s = $edgeSeparation(this$static, xf1, edge, xf2);
  prevEdge = edge - 1 >= 0?edge - 1:count1 - 1;
  sPrev = $edgeSeparation(this$static, xf1, prevEdge, xf2);
  nextEdge = edge + 1 < count1?edge + 1:0;
  sNext = $edgeSeparation(this$static, xf1, nextEdge, xf2);
  if (sPrev > s && sPrev > sNext) {
    increment = -1;
    bestEdge = prevEdge;
    bestSeparation = sPrev;
  }
   else if (sNext > s) {
    increment = 1;
    bestEdge = nextEdge;
    bestSeparation = sNext;
  }
   else {
    results.edgeIndex = edge;
    results.separation = s;
    return;
  }
  for (;;) {
    increment == -1?(edge = bestEdge - 1 >= 0?bestEdge - 1:count1 - 1):(edge = bestEdge + 1 < count1?bestEdge + 1:0);
    s = $edgeSeparation(this$static, xf1, edge, xf2);
    if (s > bestSeparation) {
      bestEdge = edge;
      bestSeparation = s;
    }
     else {
      break;
    }
  }
  results.edgeIndex = bestEdge;
  results.separation = bestSeparation;
}

function $testOverlap(this$static, shapeA, shapeB, xfA, xfB){
  $set_5(this$static.input.proxyA, shapeA);
  $set_5(this$static.input.proxyB, shapeB);
  $set_12(this$static.input.transformA, xfA);
  $set_12(this$static.input.transformB, xfB);
  this$static.input.useRadii = true;
  this$static.cache.count = 0;
  $distance(this$static.pool.dist, this$static.output, this$static.cache, this$static.input);
  return this$static.output.distance < 1.1920928955078125E-6;
}

function Collision_0(argPool){
  this.input = new DistanceInput_0;
  this.cache = new Distance$SimplexCache_0;
  this.output = new DistanceOutput_0;
  this.d = new Vec2_0;
  this.pA = new Vec2_0;
  this.pB = new Vec2_0;
  this.c = new Vec2_0;
  this.cLocal = new Vec2_0;
  this.temp = new Vec2_0;
  this.temp2 = new Vec2_0;
  this.normal1World = new Vec2_0;
  this.normal1 = new Vec2_0;
  this.v1 = new Vec2_0;
  this.v2 = new Vec2_0;
  this.dLocal1 = new Vec2_0;
  this.results1 = new Collision$EdgeResults_0;
  this.results2 = new Collision$EdgeResults_0;
  this.incidentEdge = initDim(_3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Collision$ClipVertex, 2, 0);
  this.localTangent = new Vec2_0;
  this.localNormal = new Vec2_0;
  this.planePoint = new Vec2_0;
  this.tangent = new Vec2_0;
  this.normal = new Vec2_0;
  this.v11 = new Vec2_0;
  this.v12 = new Vec2_0;
  this.clipPoints1 = initDim(_3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Collision$ClipVertex, 2, 0);
  this.clipPoints2 = initDim(_3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Collision$ClipVertex, 2, 0);
  this.incidentEdge[0] = new Collision$ClipVertex_0;
  this.incidentEdge[1] = new Collision$ClipVertex_0;
  this.clipPoints1[0] = new Collision$ClipVertex_0;
  this.clipPoints1[1] = new Collision$ClipVertex_0;
  this.clipPoints2[0] = new Collision$ClipVertex_0;
  this.clipPoints2[1] = new Collision$ClipVertex_0;
  this.pool = argPool;
}

function clipSegmentToLine(vOut, vIn, normal, offset){
  var distance0, distance1, interp, numOut;
  numOut = 0;
  distance0 = dot_0(normal, vIn[0].v) - offset;
  distance1 = dot_0(normal, vIn[1].v) - offset;
  distance0 <= 0 && $set_2(vOut[numOut++], vIn[0]);
  distance1 <= 0 && $set_2(vOut[numOut++], vIn[1]);
  if (distance0 * distance1 < 0) {
    interp = distance0 / (distance0 - distance1);
    $addLocal($mulLocal($subLocal($set_14(vOut[numOut].v, vIn[1].v), vIn[0].v), interp), vIn[0].v);
    distance0 > 0?$set_3(vOut[numOut].id_0, vIn[0].id_0):$set_3(vOut[numOut].id_0, vIn[1].id_0);
    ++numOut;
  }
  return numOut;
}

defineSeed(262, 1, {}, Collision_0);
_.pool = null;
function $set_2(this$static, cv){
  $set_14(this$static.v, cv.v);
  $set_3(this$static.id_0, cv.id_0);
}

function Collision$ClipVertex_0(){
  this.v = new Vec2_0;
  this.id_0 = new ContactID_0;
}

defineSeed(263, 1, makeCastMap([Q$Collision$ClipVertex]), Collision$ClipVertex_0);
_.id_0 = null;
_.v = null;
function Collision$EdgeResults_0(){
}

defineSeed(264, 1, {}, Collision$EdgeResults_0);
_.edgeIndex = 0;
_.separation = 0;
function $isEqual(this$static, cid){
  return $isEqual_0(cid.features, this$static.features);
}

function $set_3(this$static, c){
  $set_4(this$static.features, c.features);
}

function $zero(this$static){
  this$static.features.flip = 0;
  this$static.features.incidentEdge = 0;
  this$static.features.incidentVertex = 0;
  this$static.features.referenceEdge = 0;
}

function ContactID_0(){
  this.features = new ContactID$Features_0;
}

defineSeed(265, 1, {}, ContactID_0);
_.features = null;
function $isEqual_0(this$static, f){
  return this$static.referenceEdge == f.referenceEdge && this$static.incidentEdge == f.incidentEdge && this$static.incidentVertex == f.incidentVertex && this$static.flip == f.flip;
}

function $set_4(this$static, f){
  this$static.referenceEdge = f.referenceEdge;
  this$static.incidentEdge = f.incidentEdge;
  this$static.incidentVertex = f.incidentVertex;
  this$static.flip = f.flip;
}

function ContactID$Features_0(){
  this.referenceEdge = this.incidentEdge = this.incidentVertex = this.flip = 0;
}

defineSeed(266, 1, {}, ContactID$Features_0);
_.toString$ = function toString_26(){
  var s;
  s = 'Features: (' + this.flip + ' ,' + this.incidentEdge + ' ,' + this.incidentVertex + ' ,' + this.referenceEdge + ')';
  return s;
}
;
_.flip = 0;
_.incidentEdge = 0;
_.incidentVertex = 0;
_.referenceEdge = 0;
function $distance(this$static, output, cache, input){
  var duplicate, i, iter, proxyA, proxyB, rA, rB, saveCount, transformA, transformB, vertex, vertices;
  ++GJK_CALLS;
  proxyA = input.proxyA;
  proxyB = input.proxyB;
  transformA = input.transformA;
  transformB = input.transformB;
  $readCache(this$static.simplex, cache, proxyA, transformA, proxyB, transformB);
  vertices = this$static.simplex.vertices;
  $getClosestPoint(this$static.simplex, this$static.closestPoint);
  $lengthSquared(this$static.closestPoint);
  iter = 0;
  while (iter < GJK_MAX_ITERS) {
    saveCount = this$static.simplex.m_count;
    for (i = 0; i < saveCount; ++i) {
      this$static.saveA[i] = vertices[i].indexA;
      this$static.saveB[i] = vertices[i].indexB;
    }
    switch (this$static.simplex.m_count) {
      case 2:
        $solve2(this$static.simplex);
        break;
      case 3:
        $solve3(this$static.simplex);
    }
    if (this$static.simplex.m_count == 3) {
      break;
    }
    $getClosestPoint(this$static.simplex, this$static.closestPoint);
    $lengthSquared(this$static.closestPoint);
    $getSearchDirection(this$static.simplex, this$static.d);
    if ($lengthSquared(this$static.d) < 1.4210854715202004E-14) {
      break;
    }
    vertex = vertices[this$static.simplex.m_count];
    mulTransToOut(transformA.R, $negateLocal(this$static.d), this$static.temp);
    vertex.indexA = $getSupport(proxyA, this$static.temp);
    mulToOut_0(transformA, $getVertex(proxyA, vertex.indexA), vertex.wA);
    mulTransToOut(transformB.R, $negateLocal(this$static.d), this$static.temp);
    vertex.indexB = $getSupport(proxyB, this$static.temp);
    mulToOut_0(transformB, $getVertex(proxyB, vertex.indexB), vertex.wB);
    $subLocal($set_14(vertex.w, vertex.wB), vertex.wA);
    ++iter;
    ++GJK_ITERS;
    duplicate = false;
    for (i = 0; i < saveCount; ++i) {
      if (vertex.indexA == this$static.saveA[i] && vertex.indexB == this$static.saveB[i]) {
        duplicate = true;
        break;
      }
    }
    if (duplicate) {
      break;
    }
    ++this$static.simplex.m_count;
  }
  GJK_MAX_ITERS = max_0(GJK_MAX_ITERS, iter);
  $getWitnessPoints(this$static.simplex, output.pointA, output.pointB);
  output.distance = ($clinit_MathUtils() , $clinit_MathUtils() , sqrt(distanceSquared(output.pointA, output.pointB)));
  $writeCache(this$static.simplex, cache);
  if (input.useRadii) {
    rA = proxyA.m_radius;
    rB = proxyB.m_radius;
    if (output.distance > rA + rB && output.distance > 1.1920928955078125E-7) {
      output.distance -= rA + rB;
      $subLocal($set_14(this$static.normal, output.pointB), output.pointA);
      $normalize_0(this$static.normal);
      $mulLocal($set_14(this$static.temp, this$static.normal), rA);
      $addLocal(output.pointA, this$static.temp);
      $mulLocal($set_14(this$static.temp, this$static.normal), rB);
      $subLocal(output.pointB, this$static.temp);
    }
     else {
      $mulLocal($addLocal(output.pointA, output.pointB), 0.5);
      $set_14(output.pointB, output.pointA);
      output.distance = 0;
    }
  }
}

function Distance_0(){
  this.simplex = new Distance$Simplex_0;
  this.saveA = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 3, 1);
  this.saveB = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 3, 1);
  this.closestPoint = new Vec2_0;
  this.d = new Vec2_0;
  this.temp = new Vec2_0;
  this.normal = new Vec2_0;
}

defineSeed(267, 1, {}, Distance_0);
var GJK_CALLS = 0, GJK_ITERS = 0, GJK_MAX_ITERS = 20;
function $getSupport(this$static, d){
  var bestIndex, bestValue, i, value;
  bestIndex = 0;
  bestValue = dot_0(this$static.m_vertices[0], d);
  for (i = 1; i < this$static.m_count; ++i) {
    value = dot_0(this$static.m_vertices[i], d);
    if (value > bestValue) {
      bestIndex = i;
      bestValue = value;
    }
  }
  return bestIndex;
}

function $getVertex(this$static, index){
  return this$static.m_vertices[index];
}

function $set_5(this$static, shape){
  var i;
  switch (shape.m_type.ordinal) {
    case 1:
      $set_14(this$static.m_vertices[0], shape.m_p);
      this$static.m_count = 1;
      this$static.m_radius = shape.m_radius;
      break;
    case 2:
      this$static.m_count = null.nullField;
      this$static.m_radius = null.nullField;
      for (i = 0; i < this$static.m_count; ++i) {
        $set_14(this$static.m_vertices[i], null.nullField[i]);
      }

  }
}

function Distance$DistanceProxy_0(){
  var i;
  this.m_vertices = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, ($clinit_Settings() , 8), 0);
  for (i = 0; i < this.m_vertices.length; ++i) {
    this.m_vertices[i] = new Vec2_0;
  }
  this.m_count = 0;
  this.m_radius = 0;
}

defineSeed(268, 1, {}, Distance$DistanceProxy_0);
_.m_count = 0;
_.m_radius = 0;
_.m_vertices = null;
function $getClosestPoint(this$static, out){
  switch (this$static.m_count) {
    case 3:
    default:case 0:
      out.x = 0;
      out.y = 0;
      return;
    case 1:
      $set_14(out, this$static.m_v1.w);
      return;
    case 2:
      $mulLocal($set_14(this$static.case22, this$static.m_v2.w), this$static.m_v2.a_0);
      $addLocal($mulLocal($set_14(this$static.case2, this$static.m_v1.w), this$static.m_v1.a_0), this$static.case22);
      $set_14(out, this$static.case2);
      return;
  }
}

function $getMetric(this$static){
  switch (this$static.m_count) {
    case 1:
    default:case 0:
      return 0;
    case 2:
      return $clinit_MathUtils() , $clinit_MathUtils() , sqrt(distanceSquared(this$static.m_v1.w, this$static.m_v2.w));
    case 3:
      $subLocal($set_14(this$static.case3, this$static.m_v2.w), this$static.m_v1.w);
      $subLocal($set_14(this$static.case33, this$static.m_v3.w), this$static.m_v1.w);
      return cross(this$static.case3, this$static.case33);
  }
}

function $getSearchDirection(this$static, out){
  var sgn;
  switch (this$static.m_count) {
    case 1:
      $negateLocal($set_14(out, this$static.m_v1.w));
      return;
    case 2:
      $subLocal($set_14(this$static.e12, this$static.m_v2.w), this$static.m_v1.w);
      $negateLocal($set_14(out, this$static.m_v1.w));
      sgn = cross(this$static.e12, out);
      if (sgn > 0) {
        crossToOut(1, this$static.e12, out);
        return;
      }
       else {
        crossToOut_0(this$static.e12, 1, out);
        return;
      }

    default:out.x = 0;
      out.y = 0;
      return;
  }
}

function $getWitnessPoints(this$static, pA, pB){
  switch (this$static.m_count) {
    case 1:
      $set_14(pA, this$static.m_v1.wA);
      $set_14(pB, this$static.m_v1.wB);
      break;
    case 2:
      $mulLocal($set_14(this$static.case2, this$static.m_v1.wA), this$static.m_v1.a_0);
      $addLocal($mulLocal($set_14(pA, this$static.m_v2.wA), this$static.m_v2.a_0), this$static.case2);
      $mulLocal($set_14(this$static.case2, this$static.m_v1.wB), this$static.m_v1.a_0);
      $addLocal($mulLocal($set_14(pB, this$static.m_v2.wB), this$static.m_v2.a_0), this$static.case2);
      break;
    case 3:
      $mulLocal($set_14(pA, this$static.m_v1.wA), this$static.m_v1.a_0);
      $mulLocal($set_14(this$static.case3, this$static.m_v2.wA), this$static.m_v2.a_0);
      $mulLocal($set_14(this$static.case33, this$static.m_v3.wA), this$static.m_v3.a_0);
      $addLocal($addLocal(pA, this$static.case3), this$static.case33);
      $set_14(pB, pA);
  }
}

function $readCache(this$static, cache, proxyA, transformA, proxyB, transformB){
  var i, metric1, metric2, v, wALocal, wBLocal;
  this$static.m_count = cache.count;
  for (i = 0; i < this$static.m_count; ++i) {
    v = this$static.vertices[i];
    v.indexA = cache.indexA[i];
    v.indexB = cache.indexB[i];
    wALocal = $getVertex(proxyA, v.indexA);
    wBLocal = $getVertex(proxyB, v.indexB);
    mulToOut_0(transformA, wALocal, v.wA);
    mulToOut_0(transformB, wBLocal, v.wB);
    $subLocal($set_14(v.w, v.wB), v.wA);
    v.a_0 = 0;
  }
  if (this$static.m_count > 1) {
    metric1 = cache.metric;
    metric2 = $getMetric(this$static);
    (metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < 1.1920928955078125E-7) && (this$static.m_count = 0);
  }
  if (this$static.m_count == 0) {
    v = this$static.vertices[0];
    v.indexA = 0;
    v.indexB = 0;
    wALocal = proxyA.m_vertices[0];
    wBLocal = proxyB.m_vertices[0];
    mulToOut_0(transformA, wALocal, v.wA);
    mulToOut_0(transformB, wBLocal, v.wB);
    $subLocal($set_14(v.w, v.wB), v.wA);
    this$static.m_count = 1;
  }
}

function $solve2(this$static){
  var d12_1, d12_2, inv_d12, w1, w2;
  w1 = this$static.m_v1.w;
  w2 = this$static.m_v2.w;
  $subLocal($set_14(this$static.e12, w2), w1);
  d12_2 = -dot_0(w1, this$static.e12);
  if (d12_2 <= 0) {
    this$static.m_v1.a_0 = 1;
    this$static.m_count = 1;
    return;
  }
  d12_1 = dot_0(w2, this$static.e12);
  if (d12_1 <= 0) {
    this$static.m_v2.a_0 = 1;
    this$static.m_count = 1;
    $set_6(this$static.m_v1, this$static.m_v2);
    return;
  }
  inv_d12 = 1 / (d12_1 + d12_2);
  this$static.m_v1.a_0 = d12_1 * inv_d12;
  this$static.m_v2.a_0 = d12_2 * inv_d12;
  this$static.m_count = 2;
}

function $solve3(this$static){
  var d123_1, d123_2, d123_3, d12_2, d13_2, d23_2, inv_d12, inv_d123, inv_d13, inv_d23, n123, w1e12, w1e13, w2e12, w2e23, w3e13, w3e23;
  $set_14(this$static.w1, this$static.m_v1.w);
  $set_14(this$static.w2, this$static.m_v2.w);
  $set_14(this$static.w3, this$static.m_v3.w);
  $subLocal($set_14(this$static.e12, this$static.w2), this$static.w1);
  w1e12 = dot_0(this$static.w1, this$static.e12);
  w2e12 = dot_0(this$static.w2, this$static.e12);
  d12_2 = -w1e12;
  $subLocal($set_14(this$static.e13, this$static.w3), this$static.w1);
  w1e13 = dot_0(this$static.w1, this$static.e13);
  w3e13 = dot_0(this$static.w3, this$static.e13);
  d13_2 = -w1e13;
  $subLocal($set_14(this$static.e23, this$static.w3), this$static.w2);
  w2e23 = dot_0(this$static.w2, this$static.e23);
  w3e23 = dot_0(this$static.w3, this$static.e23);
  d23_2 = -w2e23;
  n123 = cross(this$static.e12, this$static.e13);
  d123_1 = n123 * cross(this$static.w2, this$static.w3);
  d123_2 = n123 * cross(this$static.w3, this$static.w1);
  d123_3 = n123 * cross(this$static.w1, this$static.w2);
  if (d12_2 <= 0 && d13_2 <= 0) {
    this$static.m_v1.a_0 = 1;
    this$static.m_count = 1;
    return;
  }
  if (w2e12 > 0 && d12_2 > 0 && d123_3 <= 0) {
    inv_d12 = 1 / (w2e12 + d12_2);
    this$static.m_v1.a_0 = w2e12 * inv_d12;
    this$static.m_v2.a_0 = d12_2 * inv_d12;
    this$static.m_count = 2;
    return;
  }
  if (w3e13 > 0 && d13_2 > 0 && d123_2 <= 0) {
    inv_d13 = 1 / (w3e13 + d13_2);
    this$static.m_v1.a_0 = w3e13 * inv_d13;
    this$static.m_v3.a_0 = d13_2 * inv_d13;
    this$static.m_count = 2;
    $set_6(this$static.m_v2, this$static.m_v3);
    return;
  }
  if (w2e12 <= 0 && d23_2 <= 0) {
    this$static.m_v2.a_0 = 1;
    this$static.m_count = 1;
    $set_6(this$static.m_v1, this$static.m_v2);
    return;
  }
  if (w3e13 <= 0 && w3e23 <= 0) {
    this$static.m_v3.a_0 = 1;
    this$static.m_count = 1;
    $set_6(this$static.m_v1, this$static.m_v3);
    return;
  }
  if (w3e23 > 0 && d23_2 > 0 && d123_1 <= 0) {
    inv_d23 = 1 / (w3e23 + d23_2);
    this$static.m_v2.a_0 = w3e23 * inv_d23;
    this$static.m_v3.a_0 = d23_2 * inv_d23;
    this$static.m_count = 2;
    $set_6(this$static.m_v1, this$static.m_v3);
    return;
  }
  inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
  this$static.m_v1.a_0 = d123_1 * inv_d123;
  this$static.m_v2.a_0 = d123_2 * inv_d123;
  this$static.m_v3.a_0 = d123_3 * inv_d123;
  this$static.m_count = 3;
}

function $writeCache(this$static, cache){
  var i;
  cache.metric = $getMetric(this$static);
  cache.count = this$static.m_count;
  for (i = 0; i < this$static.m_count; ++i) {
    cache.indexA[i] = this$static.vertices[i].indexA;
    cache.indexB[i] = this$static.vertices[i].indexB;
  }
}

function Distance$Simplex_0(){
  this.m_v1 = new Distance$SimplexVertex_0;
  this.m_v2 = new Distance$SimplexVertex_0;
  this.m_v3 = new Distance$SimplexVertex_0;
  this.vertices = initValues(_3Lorg_jbox2d_collision_Distance$SimplexVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Distance$SimplexVertex, [this.m_v1, this.m_v2, this.m_v3]);
  this.e12 = new Vec2_0;
  this.case2 = new Vec2_0;
  this.case22 = new Vec2_0;
  this.case3 = new Vec2_0;
  this.case33 = new Vec2_0;
  this.e13 = new Vec2_0;
  this.e23 = new Vec2_0;
  this.w1 = new Vec2_0;
  this.w2 = new Vec2_0;
  this.w3 = new Vec2_0;
}

defineSeed(269, 1, {}, Distance$Simplex_0);
_.m_count = 0;
function Distance$SimplexCache_0(){
  this.indexA = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 3, 1);
  this.indexB = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 3, 1);
  this.metric = 0;
  this.count = 0;
  this.indexA[0] = 2147483647;
  this.indexA[1] = 2147483647;
  this.indexA[2] = 2147483647;
  this.indexB[0] = 2147483647;
  this.indexB[1] = 2147483647;
  this.indexB[2] = 2147483647;
}

defineSeed(270, 1, {}, Distance$SimplexCache_0);
_.count = 0;
_.metric = 0;
function $set_6(this$static, sv){
  $set_14(this$static.wA, sv.wA);
  $set_14(this$static.wB, sv.wB);
  $set_14(this$static.w, sv.w);
  this$static.a_0 = sv.a_0;
  this$static.indexA = sv.indexA;
  this$static.indexB = sv.indexB;
}

function Distance$SimplexVertex_0(){
  this.wA = new Vec2_0;
  this.wB = new Vec2_0;
  this.w = new Vec2_0;
}

defineSeed(271, 1, makeCastMap([Q$Distance$SimplexVertex]), Distance$SimplexVertex_0);
_.a_0 = 0;
_.indexA = 0;
_.indexB = 0;
function DistanceInput_0(){
  this.proxyA = new Distance$DistanceProxy_0;
  this.proxyB = new Distance$DistanceProxy_0;
  this.transformA = new Transform_0;
  this.transformB = new Transform_0;
}

defineSeed(272, 1, {}, DistanceInput_0);
_.useRadii = false;
function DistanceOutput_0(){
  this.pointA = new Vec2_0;
  this.pointB = new Vec2_0;
}

defineSeed(273, 1, {}, DistanceOutput_0);
_.distance = 0;
function $set_7(this$static, cp){
  var i;
  for (i = 0; i < cp.pointCount; ++i) {
    $set_8(this$static.points[i], cp.points[i]);
  }
  this$static.type_0 = cp.type_0;
  $set_14(this$static.localNormal, cp.localNormal);
  $set_14(this$static.localPoint, cp.localPoint);
  this$static.pointCount = cp.pointCount;
}

function Manifold_0(){
  var i;
  this.points = initDim(_3Lorg_jbox2d_collision_ManifoldPoint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ManifoldPoint, ($clinit_Settings() , 2), 0);
  for (i = 0; i < 2; ++i) {
    this.points[i] = new ManifoldPoint_0;
  }
  this.localNormal = new Vec2_0;
  this.localPoint = new Vec2_0;
  this.pointCount = 0;
}

defineSeed(274, 1, {}, Manifold_0);
_.localNormal = null;
_.localPoint = null;
_.pointCount = 0;
_.points = null;
_.type_0 = null;
function $clinit_Manifold$ManifoldType(){
  $clinit_Manifold$ManifoldType = nullMethod;
  CIRCLES = new Manifold$ManifoldType_0('CIRCLES', 0);
  FACE_A = new Manifold$ManifoldType_0('FACE_A', 1);
  FACE_B = new Manifold$ManifoldType_0('FACE_B', 2);
  $VALUES_7 = initValues(_3Lorg_jbox2d_collision_Manifold$ManifoldType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Manifold$ManifoldType, [CIRCLES, FACE_A, FACE_B]);
}

function Manifold$ManifoldType_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_7(){
  $clinit_Manifold$ManifoldType();
  return $VALUES_7;
}

defineSeed(275, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Manifold$ManifoldType]), Manifold$ManifoldType_0);
var $VALUES_7, CIRCLES, FACE_A, FACE_B;
function $set_8(this$static, cp){
  $set_14(this$static.localPoint, cp.localPoint);
  this$static.normalImpulse = cp.normalImpulse;
  this$static.tangentImpulse = cp.tangentImpulse;
  $set_3(this$static.id_0, cp.id_0);
}

function ManifoldPoint_0(){
  this.localPoint = new Vec2_0;
  this.normalImpulse = this.tangentImpulse = 0;
  this.id_0 = new ContactID_0;
}

defineSeed(276, 1, makeCastMap([Q$ManifoldPoint]), ManifoldPoint_0);
_.id_0 = null;
_.localPoint = null;
_.normalImpulse = 0;
_.tangentImpulse = 0;
function RayCastInput_0(){
  new Vec2_0;
  new Vec2_0;
}

--></script>
<script><!--
defineSeed(277, 1, {}, RayCastInput_0);
function RayCastOutput_0(){
  new Vec2_0;
}

defineSeed(278, 1, {}, RayCastOutput_0);
function $evaluate(this$static, indexA, indexB, t){
  var separation;
  $getTransform(this$static.m_sweepA, this$static.xfa, t);
  $getTransform(this$static.m_sweepB, this$static.xfb, t);
  switch (this$static.m_type.ordinal) {
    case 0:
      {
        mulTransToOut(this$static.xfa.R, this$static.m_axis, this$static.axisA);
        mulTransToOut(this$static.xfb.R, $negateLocal(this$static.m_axis), this$static.axisB);
        $negateLocal(this$static.m_axis);
        $set_14(this$static.localPointA, $getVertex(this$static.m_proxyA, indexA));
        $set_14(this$static.localPointB, $getVertex(this$static.m_proxyB, indexB));
        mulToOut_0(this$static.xfa, this$static.localPointA, this$static.pointA);
        mulToOut_0(this$static.xfb, this$static.localPointB, this$static.pointB);
        separation = dot_0($subLocal(this$static.pointB, this$static.pointA), this$static.m_axis);
        return separation;
      }

    case 1:
      {
        mulToOut(this$static.xfa.R, this$static.m_axis, this$static.normal);
        mulToOut_0(this$static.xfa, this$static.m_localPoint, this$static.pointA);
        mulTransToOut(this$static.xfb.R, $negateLocal(this$static.normal), this$static.axisB);
        $negateLocal(this$static.normal);
        $set_14(this$static.localPointB, $getVertex(this$static.m_proxyB, indexB));
        mulToOut_0(this$static.xfb, this$static.localPointB, this$static.pointB);
        separation = dot_0($subLocal(this$static.pointB, this$static.pointA), this$static.normal);
        return separation;
      }

    case 2:
      {
        mulToOut(this$static.xfb.R, this$static.m_axis, this$static.normal);
        mulToOut_0(this$static.xfb, this$static.m_localPoint, this$static.pointB);
        mulTransToOut(this$static.xfa.R, $negateLocal(this$static.normal), this$static.axisA);
        $negateLocal(this$static.normal);
        $set_14(this$static.localPointA, $getVertex(this$static.m_proxyA, indexA));
        mulToOut_0(this$static.xfa, this$static.localPointA, this$static.pointA);
        separation = dot_0($subLocal(this$static.pointA, this$static.pointB), this$static.normal);
        return separation;
      }

    default:return 0;
  }
}

function $findMinSeparation(this$static, indexes, t){
  var separation;
  $getTransform(this$static.m_sweepA, this$static.xfa, t);
  $getTransform(this$static.m_sweepB, this$static.xfb, t);
  switch (this$static.m_type.ordinal) {
    case 0:
      {
        mulTransToOut(this$static.xfa.R, this$static.m_axis, this$static.axisA);
        mulTransToOut(this$static.xfb.R, $negateLocal(this$static.m_axis), this$static.axisB);
        $negateLocal(this$static.m_axis);
        indexes[0] = $getSupport(this$static.m_proxyA, this$static.axisA);
        indexes[1] = $getSupport(this$static.m_proxyB, this$static.axisB);
        $set_14(this$static.localPointA, $getVertex(this$static.m_proxyA, indexes[0]));
        $set_14(this$static.localPointB, $getVertex(this$static.m_proxyB, indexes[1]));
        mulToOut_0(this$static.xfa, this$static.localPointA, this$static.pointA);
        mulToOut_0(this$static.xfb, this$static.localPointB, this$static.pointB);
        separation = dot_0($subLocal(this$static.pointB, this$static.pointA), this$static.m_axis);
        return separation;
      }

    case 1:
      {
        mulToOut(this$static.xfa.R, this$static.m_axis, this$static.normal);
        mulToOut_0(this$static.xfa, this$static.m_localPoint, this$static.pointA);
        mulTransToOut(this$static.xfb.R, $negateLocal(this$static.normal), this$static.axisB);
        $negateLocal(this$static.normal);
        indexes[0] = -1;
        indexes[1] = $getSupport(this$static.m_proxyB, this$static.axisB);
        $set_14(this$static.localPointB, $getVertex(this$static.m_proxyB, indexes[1]));
        mulToOut_0(this$static.xfb, this$static.localPointB, this$static.pointB);
        separation = dot_0($subLocal(this$static.pointB, this$static.pointA), this$static.normal);
        return separation;
      }

    case 2:
      {
        mulToOut(this$static.xfb.R, this$static.m_axis, this$static.normal);
        mulToOut_0(this$static.xfb, this$static.m_localPoint, this$static.pointB);
        mulTransToOut(this$static.xfa.R, $negateLocal(this$static.normal), this$static.axisA);
        $negateLocal(this$static.normal);
        indexes[1] = -1;
        indexes[0] = $getSupport(this$static.m_proxyA, this$static.axisA);
        $set_14(this$static.localPointA, $getVertex(this$static.m_proxyA, indexes[0]));
        mulToOut_0(this$static.xfa, this$static.localPointA, this$static.pointA);
        separation = dot_0($subLocal(this$static.pointA, this$static.pointB), this$static.normal);
        return separation;
      }

    default:indexes[0] = -1;
      indexes[1] = -1;
      return 0;
  }
}

function $initialize(this$static, cache, proxyA, sweepA, proxyB, sweepB, t1){
  var count, s;
  this$static.m_proxyA = proxyA;
  this$static.m_proxyB = proxyB;
  count = cache.count;
  this$static.m_sweepA = sweepA;
  this$static.m_sweepB = sweepB;
  $getTransform(this$static.m_sweepA, this$static.xfa, t1);
  $getTransform(this$static.m_sweepB, this$static.xfb, t1);
  if (count == 1) {
    this$static.m_type = ($clinit_Type() , POINTS);
    $set_14(this$static.localPointA, $getVertex(this$static.m_proxyA, cache.indexA[0]));
    $set_14(this$static.localPointB, $getVertex(this$static.m_proxyB, cache.indexB[0]));
    mulToOut_0(this$static.xfa, this$static.localPointA, this$static.pointA);
    mulToOut_0(this$static.xfb, this$static.localPointB, this$static.pointB);
    $subLocal($set_14(this$static.m_axis, this$static.pointB), this$static.pointA);
    s = $normalize_0(this$static.m_axis);
    return s;
  }
   else if (cache.indexA[0] == cache.indexA[1]) {
    this$static.m_type = ($clinit_Type() , FACE_B_0);
    $set_14(this$static.localPointB1, $getVertex(this$static.m_proxyB, cache.indexB[0]));
    $set_14(this$static.localPointB2, $getVertex(this$static.m_proxyB, cache.indexB[1]));
    $subLocal($set_14(this$static.temp, this$static.localPointB2), this$static.localPointB1);
    crossToOut_0(this$static.temp, 1, this$static.m_axis);
    $normalize_0(this$static.m_axis);
    mulToOut(this$static.xfb.R, this$static.m_axis, this$static.normal);
    $mulLocal($addLocal($set_14(this$static.m_localPoint, this$static.localPointB1), this$static.localPointB2), 0.5);
    mulToOut_0(this$static.xfb, this$static.m_localPoint, this$static.pointB);
    $set_14(this$static.localPointA, $getVertex(proxyA, cache.indexA[0]));
    mulToOut_0(this$static.xfa, this$static.localPointA, this$static.pointA);
    $subLocal($set_14(this$static.temp, this$static.pointA), this$static.pointB);
    s = dot_0(this$static.temp, this$static.normal);
    if (s < 0) {
      $negateLocal(this$static.m_axis);
      s = -s;
    }
    return s;
  }
   else {
    this$static.m_type = ($clinit_Type() , FACE_A_0);
    $set_14(this$static.localPointA1, $getVertex(this$static.m_proxyA, cache.indexA[0]));
    $set_14(this$static.localPointA2, $getVertex(this$static.m_proxyA, cache.indexA[1]));
    $subLocal($set_14(this$static.temp, this$static.localPointA2), this$static.localPointA1);
    crossToOut_0(this$static.temp, 1, this$static.m_axis);
    $normalize_0(this$static.m_axis);
    mulToOut(this$static.xfa.R, this$static.m_axis, this$static.normal);
    $mulLocal($addLocal($set_14(this$static.m_localPoint, this$static.localPointA1), this$static.localPointA2), 0.5);
    mulToOut_0(this$static.xfa, this$static.m_localPoint, this$static.pointA);
    $set_14(this$static.localPointB, $getVertex(this$static.m_proxyB, cache.indexB[0]));
    mulToOut_0(this$static.xfb, this$static.localPointB, this$static.pointB);
    $subLocal($set_14(this$static.temp, this$static.pointB), this$static.pointA);
    s = dot_0(this$static.temp, this$static.normal);
    if (s < 0) {
      $negateLocal(this$static.m_axis);
      s = -s;
    }
    return s;
  }
}

function SeparationFunction_0(){
  this.m_localPoint = new Vec2_0;
  this.m_axis = new Vec2_0;
  this.localPointA = new Vec2_0;
  this.localPointB = new Vec2_0;
  this.pointA = new Vec2_0;
  this.pointB = new Vec2_0;
  this.localPointA1 = new Vec2_0;
  this.localPointA2 = new Vec2_0;
  this.normal = new Vec2_0;
  this.localPointB1 = new Vec2_0;
  this.localPointB2 = new Vec2_0;
  this.temp = new Vec2_0;
  this.xfa = new Transform_0;
  this.xfb = new Transform_0;
  this.axisA = new Vec2_0;
  this.axisB = new Vec2_0;
}

defineSeed(279, 1, {}, SeparationFunction_0);
_.m_proxyA = null;
_.m_proxyB = null;
_.m_sweepA = null;
_.m_sweepB = null;
_.m_type = null;
function $timeOfImpact(this$static, output, input){
  var a1, a2, done, iter, proxyA, proxyB, pushBackIter, rootIterCount, s, s1, s2, t, t1, t2, tMax, target, tolerance, totalRadius;
  ++toiCalls;
  output.state = ($clinit_TimeOfImpact$TOIOutputState() , UNKNOWN);
  output.t = input.tMax;
  proxyA = input.proxyA;
  proxyB = input.proxyB;
  $set_11(this$static.sweepA, input.sweepA);
  $set_11(this$static.sweepB, input.sweepB);
  $normalize(this$static.sweepA);
  $normalize(this$static.sweepB);
  tMax = input.tMax;
  totalRadius = proxyA.m_radius + proxyB.m_radius;
  target = max(($clinit_Settings() , 0.004999999888241291), totalRadius - 3 * 0.004999999888241291);
  tolerance = 0.25 * 0.004999999888241291;
  t1 = 0;
  iter = 0;
  this$static.cache.count = 0;
  this$static.distanceInput.proxyA = input.proxyA;
  this$static.distanceInput.proxyB = input.proxyB;
  this$static.distanceInput.useRadii = false;
  for (;;) {
    $getTransform(this$static.sweepA, this$static.xfA, t1);
    $getTransform(this$static.sweepB, this$static.xfB, t1);
    this$static.distanceInput.transformA = this$static.xfA;
    this$static.distanceInput.transformB = this$static.xfB;
    $distance(this$static.pool.dist, this$static.distanceOutput, this$static.cache, this$static.distanceInput);
    if (this$static.distanceOutput.distance <= 0) {
      output.state = OVERLAPPED;
      output.t = 0;
      break;
    }
    if (this$static.distanceOutput.distance < target + tolerance) {
      output.state = TOUCHING;
      output.t = t1;
      break;
    }
    $initialize(this$static.fcn, this$static.cache, proxyA, this$static.sweepA, proxyB, this$static.sweepB, t1);
    done = false;
    t2 = tMax;
    pushBackIter = 0;
    for (;;) {
      s2 = $findMinSeparation(this$static.fcn, this$static.indexes, t2);
      if (s2 > target + tolerance) {
        output.state = SEPARATED;
        output.t = tMax;
        done = true;
        break;
      }
      if (s2 > target - tolerance) {
        t1 = t2;
        break;
      }
      s1 = $evaluate(this$static.fcn, this$static.indexes[0], this$static.indexes[1], t1);
      if (s1 < target - tolerance) {
        output.state = FAILED;
        output.t = t1;
        done = true;
        break;
      }
      if (s1 <= target + tolerance) {
        output.state = TOUCHING;
        output.t = t1;
        done = true;
        break;
      }
      rootIterCount = 0;
      a1 = t1;
      a2 = t2;
      for (;;) {
        (rootIterCount & 1) == 1?(t = a1 + (target - s1) * (a2 - a1) / (s2 - s1)):(t = 0.5 * (a1 + a2));
        s = $evaluate(this$static.fcn, this$static.indexes[0], this$static.indexes[1], t);
        if (($clinit_MathUtils() , s - target > 0?s - target:-(s - target)) < tolerance) {
          t2 = t;
          break;
        }
        if (s > target) {
          a1 = t;
          s1 = s;
        }
         else {
          a2 = t;
          s2 = s;
        }
        ++rootIterCount;
        ++toiRootIters;
        if (rootIterCount == 50) {
          break;
        }
      }
      toiMaxRootIters = max_0(toiMaxRootIters, rootIterCount);
      ++pushBackIter;
      if (pushBackIter == 8) {
        break;
      }
    }
    ++iter;
    ++toiIters;
    if (done) {
      break;
    }
    if (iter == 1000) {
      output.state = FAILED;
      output.t = t1;
      break;
    }
  }
  toiMaxIters = max_0(toiMaxIters, iter);
}

function TimeOfImpact_0(argPool){
  this.cache = new Distance$SimplexCache_0;
  this.distanceInput = new DistanceInput_0;
  this.xfA = new Transform_0;
  this.xfB = new Transform_0;
  this.distanceOutput = new DistanceOutput_0;
  this.fcn = new SeparationFunction_0;
  this.indexes = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 2, 1);
  this.sweepA = new Sweep_0;
  this.sweepB = new Sweep_0;
  this.pool = argPool;
}

defineSeed(280, 1, {}, TimeOfImpact_0);
_.pool = null;
var toiCalls = 0, toiIters = 0, toiMaxIters = 0, toiMaxRootIters = 0, toiRootIters = 0;
function TimeOfImpact$TOIInput_0(){
  this.proxyA = new Distance$DistanceProxy_0;
  this.proxyB = new Distance$DistanceProxy_0;
  this.sweepA = new Sweep_0;
  this.sweepB = new Sweep_0;
}

defineSeed(281, 1, {}, TimeOfImpact$TOIInput_0);
_.tMax = 0;
function TimeOfImpact$TOIOutput_0(){
}

defineSeed(282, 1, {}, TimeOfImpact$TOIOutput_0);
_.state = null;
_.t = 0;
function $clinit_TimeOfImpact$TOIOutputState(){
  $clinit_TimeOfImpact$TOIOutputState = nullMethod;
  UNKNOWN = new TimeOfImpact$TOIOutputState_0('UNKNOWN', 0);
  FAILED = new TimeOfImpact$TOIOutputState_0('FAILED', 1);
  OVERLAPPED = new TimeOfImpact$TOIOutputState_0('OVERLAPPED', 2);
  TOUCHING = new TimeOfImpact$TOIOutputState_0('TOUCHING', 3);
  SEPARATED = new TimeOfImpact$TOIOutputState_0('SEPARATED', 4);
  $VALUES_8 = initValues(_3Lorg_jbox2d_collision_TimeOfImpact$TOIOutputState_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$TimeOfImpact$TOIOutputState, [UNKNOWN, FAILED, OVERLAPPED, TOUCHING, SEPARATED]);
}

function TimeOfImpact$TOIOutputState_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_8(){
  $clinit_TimeOfImpact$TOIOutputState();
  return $VALUES_8;
}

defineSeed(283, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TimeOfImpact$TOIOutputState]), TimeOfImpact$TOIOutputState_0);
var $VALUES_8, FAILED, OVERLAPPED, SEPARATED, TOUCHING, UNKNOWN;
function $clinit_Type(){
  $clinit_Type = nullMethod;
  POINTS = new Type_0('POINTS', 0);
  FACE_A_0 = new Type_0('FACE_A', 1);
  FACE_B_0 = new Type_0('FACE_B', 2);
  $VALUES_9 = initValues(_3Lorg_jbox2d_collision_Type_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Type, [POINTS, FACE_A_0, FACE_B_0]);
}

function Type_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_9(){
  $clinit_Type();
  return $VALUES_9;
}

defineSeed(284, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Type]), Type_0);
var $VALUES_9, FACE_A_0, FACE_B_0, POINTS;
function $initialize_0(this$static, manifold, xfA, radiusA, xfB, radiusB){
  var R, cAx, cAy, cBx, cBy, clipPoint, i, planePoint, pointA, pointB, scalar, v;
  if (manifold.pointCount == 0) {
    return;
  }
  switch (manifold.type_0.ordinal) {
    case 0:
      {
        pointA = this$static.pool3;
        pointB = this$static.pool4;
        this$static.normal.x = 1;
        this$static.normal.y = 0;
        pointA.x = xfA.position_0.x + xfA.R.m11 * manifold.localPoint.x + xfA.R.m21 * manifold.localPoint.y;
        pointA.y = xfA.position_0.y + xfA.R.m12 * manifold.localPoint.x + xfA.R.m22 * manifold.localPoint.y;
        pointB.x = xfB.position_0.x + xfB.R.m11 * manifold.points[0].localPoint.x + xfB.R.m21 * manifold.points[0].localPoint.y;
        pointB.y = xfB.position_0.y + xfB.R.m12 * manifold.points[0].localPoint.x + xfB.R.m22 * manifold.points[0].localPoint.y;
        if (distanceSquared(pointA, pointB) > 1.4210854715202004E-14) {
          this$static.normal.x = pointB.x - pointA.x;
          this$static.normal.y = pointB.y - pointA.y;
          $normalize_0(this$static.normal);
        }
        cAx = this$static.normal.x * radiusA + pointA.x;
        cAy = this$static.normal.y * radiusA + pointA.y;
        cBx = -this$static.normal.x * radiusB + pointB.x;
        cBy = -this$static.normal.y * radiusB + pointB.y;
        this$static.points[0].x = (cAx + cBx) * 0.5;
        this$static.points[0].y = (cAy + cBy) * 0.5;
      }

      break;
    case 1:
      {
        planePoint = this$static.pool3;
        this$static.normal.x = xfA.R.m11 * manifold.localNormal.x + xfA.R.m21 * manifold.localNormal.y;
        this$static.normal.y = xfA.R.m12 * manifold.localNormal.x + xfA.R.m22 * manifold.localNormal.y;
        planePoint.x = xfA.position_0.x + xfA.R.m11 * manifold.localPoint.x + xfA.R.m21 * manifold.localPoint.y;
        planePoint.y = xfA.position_0.y + xfA.R.m12 * manifold.localPoint.x + xfA.R.m22 * manifold.localPoint.y;
        clipPoint = this$static.pool4;
        for (i = 0; i < manifold.pointCount; ++i) {
          clipPoint.x = xfB.position_0.x + xfB.R.m11 * manifold.points[i].localPoint.x + xfB.R.m21 * manifold.points[i].localPoint.y;
          clipPoint.y = xfB.position_0.y + xfB.R.m12 * manifold.points[i].localPoint.x + xfB.R.m22 * manifold.points[i].localPoint.y;
          scalar = radiusA - ((clipPoint.x - planePoint.x) * this$static.normal.x + (clipPoint.y - planePoint.y) * this$static.normal.y);
          cAx = this$static.normal.x * scalar + clipPoint.x;
          cAy = this$static.normal.y * scalar + clipPoint.y;
          cBx = -this$static.normal.x * radiusB + clipPoint.x;
          cBy = -this$static.normal.y * radiusB + clipPoint.y;
          this$static.points[i].x = (cAx + cBx) * 0.5;
          this$static.points[i].y = (cAy + cBy) * 0.5;
        }
      }

      break;
    case 2:
      planePoint = this$static.pool3;
      R = xfB.R;
      this$static.normal.x = R.m11 * manifold.localNormal.x + R.m21 * manifold.localNormal.y;
      this$static.normal.y = R.m12 * manifold.localNormal.x + R.m22 * manifold.localNormal.y;
      v = manifold.localPoint;
      planePoint.x = xfB.position_0.x + xfB.R.m11 * v.x + xfB.R.m21 * v.y;
      planePoint.y = xfB.position_0.y + xfB.R.m12 * v.x + xfB.R.m22 * v.y;
      clipPoint = this$static.pool4;
      for (i = 0; i < manifold.pointCount; ++i) {
        clipPoint.x = xfA.position_0.x + xfA.R.m11 * manifold.points[i].localPoint.x + xfA.R.m21 * manifold.points[i].localPoint.y;
        clipPoint.y = xfA.position_0.y + xfA.R.m12 * manifold.points[i].localPoint.x + xfA.R.m22 * manifold.points[i].localPoint.y;
        scalar = radiusB - ((clipPoint.x - planePoint.x) * this$static.normal.x + (clipPoint.y - planePoint.y) * this$static.normal.y);
        cBx = this$static.normal.x * scalar + clipPoint.x;
        cBy = this$static.normal.y * scalar + clipPoint.y;
        cAx = -this$static.normal.x * radiusA + clipPoint.x;
        cAy = -this$static.normal.y * radiusA + clipPoint.y;
        this$static.points[i].x = (cAx + cBx) * 0.5;
        this$static.points[i].y = (cAy + cBy) * 0.5;
      }

      this$static.normal.x = -this$static.normal.x;
      this$static.normal.y = -this$static.normal.y;
  }
}

function WorldManifold_0(){
  var i;
  this.pool3 = new Vec2_0;
  this.pool4 = new Vec2_0;
  this.normal = new Vec2_0;
  this.points = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, ($clinit_Settings() , 2), 0);
  for (i = 0; i < 2; ++i) {
    this.points[i] = new Vec2_0;
  }
}

defineSeed(285, 1, {}, WorldManifold_0);
_.normal = null;
_.points = null;
function $bufferMove(this$static, node){
  var i, old;
  if (this$static.m_moveCount == this$static.m_moveCapacity) {
    old = this$static.m_moveBuffer;
    this$static.m_moveCapacity *= 2;
    this$static.m_moveBuffer = initDim(_3Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$DynamicTreeNode, this$static.m_moveCapacity, 0);
    for (i = 0; i < old.length; ++i) {
      this$static.m_moveBuffer[i] = old[i];
    }
  }
  this$static.m_moveBuffer[this$static.m_moveCount] = node;
  ++this$static.m_moveCount;
}

function $createProxy(this$static, aabb, userData){
  var node;
  node = $createProxy_0(this$static.m_tree, aabb, userData);
  ++this$static.m_proxyCount;
  $bufferMove(this$static, node);
  return node;
}

function $drawTree(this$static, argDraw){
  $drawTree_0(this$static.m_tree, argDraw);
}

function $moveProxy(this$static, proxy, aabb, displacement){
  var buffer;
  buffer = $moveProxy_0(this$static.m_tree, proxy, aabb, displacement);
  buffer && $bufferMove(this$static, proxy);
}

function $testOverlap_0(proxyA, proxyB){
  var a, b;
  a = proxyA.aabb;
  b = proxyB.aabb;
  if (b.lowerBound.x - a.upperBound.x > 0 || b.lowerBound.y - a.upperBound.y > 0) {
    return false;
  }
  if (a.lowerBound.x - b.upperBound.x > 0 || a.lowerBound.y - b.upperBound.y > 0) {
    return false;
  }
  return true;
}

function $treeCallback(this$static, proxy){
  var i, oldBuffer;
  if (proxy == this$static.m_queryProxy) {
    return true;
  }
  if (this$static.m_pairCount == this$static.m_pairCapacity) {
    oldBuffer = this$static.m_pairBuffer;
    this$static.m_pairCapacity *= 2;
    this$static.m_pairBuffer = initDim(_3Lorg_jbox2d_collision_broadphase_Pair_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Pair, this$static.m_pairCapacity, 0);
    for (i = 0; i < oldBuffer.length; ++i) {
      this$static.m_pairBuffer[i] = oldBuffer[i];
    }
    for (i = oldBuffer.length; i < this$static.m_pairCapacity; ++i) {
      this$static.m_pairBuffer[i] = new Pair_0;
    }
  }
  if (proxy.key_0 < this$static.m_queryProxy.key_0) {
    this$static.m_pairBuffer[this$static.m_pairCount].proxyA = proxy;
    this$static.m_pairBuffer[this$static.m_pairCount].proxyB = this$static.m_queryProxy;
  }
   else {
    this$static.m_pairBuffer[this$static.m_pairCount].proxyA = this$static.m_queryProxy;
    this$static.m_pairBuffer[this$static.m_pairCount].proxyB = proxy;
  }
  ++this$static.m_pairCount;
  return true;
}

function $updatePairs(this$static, callback){
  var i, pair, primaryPair, userDataA, userDataB;
  this$static.m_pairCount = 0;
  for (i = 0; i < this$static.m_moveCount; ++i) {
    this$static.m_queryProxy = this$static.m_moveBuffer[i];
    if (!this$static.m_queryProxy) {
      continue;
    }
    $query(this$static.m_tree, this$static, this$static.m_queryProxy.aabb);
  }
  this$static.m_moveCount = 0;
  $clinit_Settings();
  for (i = 0; i < this$static.m_pairCount; ++i) {
    this$static.m_pairBuffer[i].stableIdx = i;
  }
  sort(this$static.m_pairBuffer, this$static.m_pairCount, new Pair$StableComparator_0);
  i = 0;
  while (i < this$static.m_pairCount) {
    primaryPair = this$static.m_pairBuffer[i];
    userDataA = primaryPair.proxyA.userData;
    userDataB = primaryPair.proxyB.userData;
    $addPair(callback, userDataA, userDataB);
    ++i;
    while (i < this$static.m_pairCount) {
      pair = this$static.m_pairBuffer[i];
      if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
        break;
      }
      ++i;
    }
  }
  $rebalance(this$static.m_tree, 4);
}

function BroadPhase_0(){
  var i;
  this.m_proxyCount = 0;
  this.m_pairCapacity = 16;
  this.m_pairCount = 0;
  this.m_pairBuffer = initDim(_3Lorg_jbox2d_collision_broadphase_Pair_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Pair, this.m_pairCapacity, 0);
  for (i = 0; i < this.m_pairCapacity; ++i) {
    this.m_pairBuffer[i] = new Pair_0;
  }
  this.m_moveCapacity = 16;
  this.m_moveCount = 0;
  this.m_moveBuffer = initDim(_3Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$DynamicTreeNode, this.m_moveCapacity, 0);
  this.m_tree = new DynamicTree_0;
  this.m_queryProxy = null;
}

defineSeed(286, 1, {}, BroadPhase_0);
_.m_moveBuffer = null;
_.m_moveCapacity = 0;
_.m_moveCount = 0;
_.m_pairBuffer = null;
_.m_pairCapacity = 0;
_.m_pairCount = 0;
_.m_proxyCount = 0;
_.m_queryProxy = null;
_.m_tree = null;
function $allocateNode(this$static){
  var node;
  if (this$static.nodeStack.arrayList.size == 0) {
    $add_5(this$static.nodeStack, new DynamicTreeNode_0);
    $add_5(this$static.nodeStack, new DynamicTreeNode_0);
    $add_5(this$static.nodeStack, new DynamicTreeNode_0);
    $add_5(this$static.nodeStack, new DynamicTreeNode_0);
    $add_5(this$static.nodeStack, new DynamicTreeNode_0);
    $add_5(this$static.nodeStack, new DynamicTreeNode_0);
  }
  node = $pop(this$static.nodeStack);
  node.parent_0 = null;
  node.child1 = null;
  node.child2 = null;
  node.userData = null;
  node.key_0 = this$static.nodeCounter++;
  ++this$static.m_nodeCount;
  return node;
}

function $computeHeight(this$static, argNode){
  var height1, height2;
  if (!argNode) {
    return 0;
  }
  height1 = $computeHeight(this$static, argNode.child1);
  height2 = $computeHeight(this$static, argNode.child2);
  return 1 + ($clinit_MathUtils() , height1 > height2?height1:height2);
}

function $createProxy_0(this$static, argAABB, argUserData){
  var height, iterationCount, proxy, tryCount;
  proxy = $allocateNode(this$static);
  proxy.aabb.lowerBound.x = argAABB.lowerBound.x - ($clinit_Settings() , 0.10000000149011612);
  proxy.aabb.lowerBound.y = argAABB.lowerBound.y - 0.10000000149011612;
  proxy.aabb.upperBound.x = argAABB.upperBound.x + 0.10000000149011612;
  proxy.aabb.upperBound.y = argAABB.upperBound.y + 0.10000000149011612;
  proxy.userData = argUserData;
  $insertLeaf(this$static, proxy);
  iterationCount = ~~this$static.m_nodeCount >> 4;
  tryCount = 0;
  height = $computeHeight(this$static, this$static.m_root);
  while (height > 64 && tryCount < 10) {
    $rebalance(this$static, iterationCount);
    height = $computeHeight(this$static, this$static.m_root);
    ++tryCount;
  }
  return proxy;
}

function $drawTree_0(this$static, argDraw){
  var height;
  if (!this$static.m_root) {
    return;
  }
  height = $computeHeight(this$static, this$static.m_root);
  $drawTree_1(this$static, argDraw, this$static.m_root, 0, height);
}

function $drawTree_1(this$static, argDraw, argNode, spot, height){
  $getVertices(argNode.aabb, this$static.drawVecs);
  $drawPolygon();
  argDraw.viewportTransform.nullMethod();
  !!argNode.child1 && $drawTree_1(this$static, argDraw, argNode.child1, spot + 1, height);
  !!argNode.child2 && $drawTree_1(this$static, argDraw, argNode.child2, spot + 1, height);
}

function $insertLeaf(this$static, argNode){
  var child1, child2, node1, node2, norm1, norm2, sibling;
  ++this$static.m_insertionCount;
  if (!this$static.m_root) {
    this$static.m_root = argNode;
    argNode.parent_0 = null;
    return;
  }
  $getCenterToOut(argNode.aabb, this$static.center);
  sibling = this$static.m_root;
  if (sibling.child1) {
    do {
      child1 = sibling.child1;
      child2 = sibling.child2;
      $getCenterToOut(child1.aabb, this$static.delta1);
      $getCenterToOut(child2.aabb, this$static.delta2);
      $absLocal($subLocal(this$static.delta1, this$static.center));
      $absLocal($subLocal(this$static.delta2, this$static.center));
      norm1 = this$static.delta1.x + this$static.delta1.y;
      norm2 = this$static.delta2.x + this$static.delta2.y;
      norm1 < norm2?(sibling = child1):(sibling = child2);
    }
     while (sibling.child1);
  }
  node1 = sibling.parent_0;
  node2 = $allocateNode(this$static);
  node2.parent_0 = node1;
  node2.userData = null;
  $combine(node2.aabb, argNode.aabb, sibling.aabb);
  if (node1) {
    sibling.parent_0.child1 == sibling?(node1.child1 = node2):(node1.child2 = node2);
    node2.child1 = sibling;
    node2.child2 = argNode;
    sibling.parent_0 = node2;
    argNode.parent_0 = node2;
    do {
      if ($contains_1(node1.aabb, node2.aabb)) {
        break;
      }
      $combine(node1.aabb, node1.child1.aabb, node1.child2.aabb);
      node2 = node1;
      node1 = node1.parent_0;
    }
     while (node1);
  }
   else {
    node2.child1 = sibling;
    node2.child2 = argNode;
    sibling.parent_0 = node2;
    argNode.parent_0 = node2;
    this$static.m_root = node2;
  }
}

function $moveProxy_0(this$static, argProxy, argAABB, displacement){
  if ($contains_1(argProxy.aabb, argAABB)) {
    return false;
  }
  $removeLeaf(this$static, argProxy);
  argAABB.lowerBound.x -= ($clinit_Settings() , 0.10000000149011612);
  argAABB.lowerBound.y -= 0.10000000149011612;
  argAABB.upperBound.x += 0.10000000149011612;
  argAABB.upperBound.y += 0.10000000149011612;
  $mulLocal($set_14(this$static.d, displacement), 2);
  this$static.d.x < 0?(argAABB.lowerBound.x += this$static.d.x):(argAABB.upperBound.x += this$static.d.x);
  this$static.d.y < 0?(argAABB.lowerBound.y += this$static.d.y):(argAABB.upperBound.y += this$static.d.y);
  $set_1(argProxy.aabb, argAABB);
  $insertLeaf(this$static, argProxy);
  return true;
}

function $query(this$static, argCallback, argAABB){
  $query_0(this$static, argCallback, argAABB, this$static.m_root, 1);
}

function $query_0(this$static, argCallback, argAABB, argNode, count){
  var proceed;
  if (!argNode) {
    return true;
  }
  if (testOverlap(argAABB, argNode.aabb)) {
    if (!argNode.child1) {
      proceed = $treeCallback(argCallback, argNode);
      if (!proceed) {
        return false;
      }
    }
     else {
      if (count < 128) {
        proceed = $query_0(this$static, argCallback, argAABB, argNode.child1, ++count);
        if (!proceed) {
          return false;
        }
      }
      if (count < 128) {
        proceed = $query_0(this$static, argCallback, argAABB, argNode.child2, ++count);
        if (!proceed) {
          return false;
        }
      }
    }
  }
  return true;
}

--></script>
<script><!--
function $rebalance(this$static, argIterations){
  var bit, currNode, goLeft, i;
  if (!this$static.m_root) {
    return;
  }
  for (i = 0; i < argIterations; ++i) {
    currNode = this$static.m_root;
    bit = 0;
    while (currNode.child1) {
      goLeft = ~~this$static.m_path >> bit & 1;
      goLeft == 0?(currNode = currNode.child1):(currNode = currNode.child2);
      bit = bit + 1 & 31;
    }
    ++this$static.m_path;
    $removeLeaf(this$static, currNode);
    $insertLeaf(this$static, currNode);
  }
}

function $removeLeaf(this$static, argNode){
  var node1, node2, sibling;
  if (argNode == this$static.m_root) {
    this$static.m_root = null;
    this$static.lastLeaf == argNode && (this$static.lastLeaf = null);
    return;
  }
  node2 = argNode.parent_0;
  node1 = node2.parent_0;
  node2.child1 == argNode?(sibling = node2.child2):(sibling = node2.child1);
  if (node1) {
    node1.child1 == node2?(node1.child1 = sibling):(node1.child2 = sibling);
    sibling.parent_0 = node1;
    $add_5(this$static.nodeStack, node2);
    --this$static.m_nodeCount;
    while (node1) {
      $set_1(this$static.oldAABB, node1.aabb);
      $combine(node1.aabb, node1.child1.aabb, node1.child2.aabb);
      if ($contains_1(this$static.oldAABB, node1.aabb)) {
        break;
      }
      node1 = node1.parent_0;
    }
  }
   else {
    this$static.m_root = sibling;
    sibling.parent_0 = null;
    $add_5(this$static.nodeStack, node2);
    --this$static.m_nodeCount;
  }
  this$static.lastLeaf == argNode && (this$static.lastLeaf = this$static.m_root);
}

function DynamicTree_0(){
  var i;
  this.nodeStack = new Stack_0;
  this.drawVecs = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 4, 0);
  this.d = new Vec2_0;
  new OrderedStackVec2_0(388);
  new AABB_0;
  new RayCastInput_0;
  this.center = new Vec2_0;
  this.delta1 = new Vec2_0;
  this.delta2 = new Vec2_0;
  this.oldAABB = new AABB_0;
  new Vec2_0;
  this.m_root = null;
  this.m_nodeCount = 0;
  this.m_insertionCount = 0;
  this.m_path = 0;
  this.lastLeaf = null;
  for (i = 0; i < this.drawVecs.length; ++i) {
    this.drawVecs[i] = new Vec2_0;
  }
}

defineSeed(287, 1, {}, DynamicTree_0);
_.lastLeaf = null;
_.m_insertionCount = 0;
_.m_nodeCount = 0;
_.m_path = 0;
_.m_root = null;
_.nodeCounter = 0;
function DynamicTreeNode_0(){
  this.aabb = new AABB_0;
}

defineSeed(288, 1, makeCastMap([Q$DynamicTreeNode]), DynamicTreeNode_0);
_.child1 = null;
_.child2 = null;
_.key_0 = 0;
_.parent_0 = null;
_.userData = null;
function $compareTo_3(this$static, pair2){
  if (this$static.proxyA.key_0 < pair2.proxyA.key_0) {
    return -1;
  }
  if (this$static.proxyA.key_0 == pair2.proxyA.key_0) {
    return this$static.proxyB.key_0 < pair2.proxyB.key_0?-1:this$static.proxyB.key_0 == pair2.proxyB.key_0?0:1;
  }
  return 1;
}

function Pair_0(){
}

defineSeed(289, 1, makeCastMap([Q$Pair]), Pair_0);
_.proxyA = null;
_.proxyB = null;
_.stableIdx = 0;
function Pair$StableComparator_0(){
}

defineSeed(290, 1, {}, Pair$StableComparator_0);
_.compare = function compare_0(pair1, pair2){
  var stdRtn;
  return stdRtn = $compareTo_3(pair1, pair2) , stdRtn == 0?pair1.stableIdx < pair2.stableIdx?-1:pair1.stableIdx > pair2.stableIdx?1:0:stdRtn;
}
;
defineSeed(292, 1, {});
_.m_radius = 0;
_.m_type = null;
function $clone(this$static){
  var shape;
  shape = new CircleShape_0;
  $set_14(shape.m_p, this$static.m_p);
  shape.m_radius = this$static.m_radius;
  return shape;
}

function $computeAABB(this$static, argAabb, argTransform){
  var p;
  p = this$static.pool1;
  mulToOut(argTransform.R, this$static.m_p, p);
  $addLocal(p, argTransform.position_0);
  argAabb.lowerBound.x = p.x - this$static.m_radius;
  argAabb.lowerBound.y = p.y - this$static.m_radius;
  argAabb.upperBound.x = p.x + this$static.m_radius;
  argAabb.upperBound.y = p.y + this$static.m_radius;
}

function $computeMass(this$static, massData, density){
  massData.mass = density * 3.1415927410125732 * this$static.m_radius * this$static.m_radius;
  $set_14(massData.center, this$static.m_p);
  massData.I = massData.mass * (0.5 * this$static.m_radius * this$static.m_radius + dot_0(this$static.m_p, this$static.m_p));
}

function CircleShape_0(){
  this.m_type = ($clinit_ShapeType() , UNKNOWN_0);
  this.pool1 = new Vec2_0;
  new Vec2_0;
  new Vec2_0;
  this.m_type = CIRCLE;
  this.m_p = new Vec2_0;
  this.m_radius = 0;
}

defineSeed(291, 292, {}, CircleShape_0);
_.m_p = null;
function MassData_0(){
  this.mass = this.I = 0;
  this.center = new Vec2_0;
}

defineSeed(293, 1, {}, MassData_0);
_.I = 0;
_.center = null;
_.mass = 0;
function $clinit_ShapeType(){
  $clinit_ShapeType = nullMethod;
  UNKNOWN_0 = new ShapeType_0('UNKNOWN', 0, -1);
  CIRCLE = new ShapeType_0('CIRCLE', 1, 0);
  POLYGON = new ShapeType_0('POLYGON', 2, 1);
  $VALUES_10 = initValues(_3Lorg_jbox2d_collision_shapes_ShapeType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ShapeType, [UNKNOWN_0, CIRCLE, POLYGON]);
}

function ShapeType_0(enum$name, enum$ordinal, argValue){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.intValue = argValue;
}

function values_10(){
  $clinit_ShapeType();
  return $VALUES_10;
}

defineSeed(294, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$ShapeType]), ShapeType_0);
_.intValue = 0;
var $VALUES_10, CIRCLE, POLYGON, UNKNOWN_0;
function $invertLocal(this$static){
  var a, b, c, d, det;
  a = this$static.m11;
  b = this$static.m21;
  c = this$static.m12;
  d = this$static.m22;
  det = a * d - b * c;
  det != 0 && (det = 1 / det);
  this$static.m11 = det * d;
  this$static.m21 = -det * b;
  this$static.m12 = -det * c;
  this$static.m22 = det * a;
  return this$static;
}

function $set_9(this$static, angle){
  var c, s;
  c = Math.cos(angle);
  s = Math.sin(angle);
  this$static.m11 = c;
  this$static.m21 = -s;
  this$static.m12 = s;
  this$static.m22 = c;
}

function $set_10(this$static, m_0){
  this$static.m11 = m_0.m11;
  this$static.m12 = m_0.m12;
  this$static.m21 = m_0.m21;
  this$static.m22 = m_0.m22;
  return this$static;
}

function $setIdentity(this$static){
  this$static.m11 = 1;
  this$static.m21 = 0;
  this$static.m12 = 0;
  this$static.m22 = 1;
}

function Mat22_0(){
}

function mulToOut(R, v, out){
  var tempy;
  tempy = R.m12 * v.x + R.m22 * v.y;
  out.x = R.m11 * v.x + R.m21 * v.y;
  out.y = tempy;
}

function mulTransToOut(R, v, out){
  var outx;
  outx = v.x * R.m11 + v.y * R.m12;
  out.y = v.x * R.m21 + v.y * R.m22;
  out.x = outx;
}

defineSeed(295, 1, makeCastMap([Q$Mat22]), Mat22_0);
_.toString$ = function toString_27(){
  var s;
  s = '';
  s += '[' + this.m11 + ',' + this.m21 + ']\n';
  s += '[' + this.m12 + ',' + this.m22 + ']';
  return s;
}
;
_.m11 = 0;
_.m12 = 0;
_.m21 = 0;
_.m22 = 0;
function $clinit_MathUtils(){
  $clinit_MathUtils = nullMethod;
  var i;
  sinLUT = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, ($clinit_Settings() , SINCOS_LUT_LENGTH), 1);
  cosLUT = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, SINCOS_LUT_LENGTH, 1);
  for (i = 0; i < SINCOS_LUT_LENGTH; ++i) {
    sinLUT[i] = Math.sin(i * 1.1000000085914508E-4);
    cosLUT[i] = Math.cos(i * 1.1000000085914508E-4);
  }
}

function abs_0(x){
  $clinit_MathUtils();
  return x > 0?x:-x;
}

function clamp(a, low, high){
  $clinit_MathUtils();
  return low > (a < high?a:high)?low:a < high?a:high;
}

function distanceSquared(v1, v2){
  $clinit_MathUtils();
  var dx, dy;
  dx = v1.x - v2.x;
  dy = v1.y - v2.y;
  return dx * dx + dy * dy;
}

function floor(x){
  $clinit_MathUtils();
  var y;
  y = round_int(x);
  x < 0 && x != y && --y;
  return y;
}

function max(a, b){
  $clinit_MathUtils();
  return a > b?a:b;
}

function max_0(a, b){
  $clinit_MathUtils();
  return a > b?a:b;
}

function min_0(a, b){
  $clinit_MathUtils();
  return a < b?a:b;
}

var cosLUT, sinLUT;
function $clinit_Settings(){
  $clinit_Settings = nullMethod;
  SINCOS_LUT_LENGTH = round_int(Math.ceil(57119.86598277577));
}

function mixFriction(friction1, friction2){
  $clinit_Settings();
  return $clinit_MathUtils() , Math.sqrt(friction1 * friction2);
}

function mixRestitution(restitution1, restitution2){
  $clinit_Settings();
  return restitution1 > restitution2?restitution1:restitution2;
}

var SINCOS_LUT_LENGTH;
function $advance(this$static, t){
  this$static.c0.x = (1 - t) * this$static.c0.x + t * this$static.c.x;
  this$static.c0.y = (1 - t) * this$static.c0.y + t * this$static.c.y;
  this$static.a0 = (1 - t) * this$static.a0 + t * this$static.a_0;
}

function $getTransform(this$static, xf, alpha){
  xf.position_0.x = (1 - alpha) * this$static.c0.x + alpha * this$static.c.x;
  xf.position_0.y = (1 - alpha) * this$static.c0.y + alpha * this$static.c.y;
  $set_9(xf.R, (1 - alpha) * this$static.a0 + alpha * this$static.a_0);
  xf.position_0.x -= xf.R.m11 * this$static.localCenter.x + xf.R.m21 * this$static.localCenter.y;
  xf.position_0.y -= xf.R.m12 * this$static.localCenter.x + xf.R.m22 * this$static.localCenter.y;
}

function $normalize(this$static){
  var d;
  d = 6.2831854820251465 * floor(this$static.a0 / 6.2831854820251465);
  this$static.a0 -= d;
  this$static.a_0 -= d;
}

function $set_11(this$static, argCloneFrom){
  $set_14(this$static.localCenter, argCloneFrom.localCenter);
  $set_14(this$static.c0, argCloneFrom.c0);
  $set_14(this$static.c, argCloneFrom.c);
  this$static.a0 = argCloneFrom.a0;
  this$static.a_0 = argCloneFrom.a_0;
  return this$static;
}

function Sweep_0(){
  this.localCenter = new Vec2_0;
  this.c0 = new Vec2_0;
  this.c = new Vec2_0;
}

defineSeed(298, 1, {}, Sweep_0);
_.toString$ = function toString_28(){
  var s;
  s = 'Sweep:\nlocalCenter: ' + this.localCenter + '\n';
  s += 'c0: ' + this.c0 + ', c: ' + this.c + '\n';
  s += 'a0: ' + this.a0 + ', a: ' + this.a_0 + '\n';
  return s;
}
;
_.a_0 = 0;
_.a0 = 0;
_.c = null;
_.c0 = null;
_.localCenter = null;
function $clinit_Transform(){
  $clinit_Transform = nullMethod;
  identity = new Transform_0;
  $setIdentity_0(identity);
}

function $set_12(this$static, xf){
  $set_14(this$static.position_0, xf.position_0);
  $set_10(this$static.R, xf.R);
  return this$static;
}

function $setIdentity_0(this$static){
  $setZero(this$static.position_0);
  $setIdentity(this$static.R);
}

function Transform_0(){
  $clinit_Transform();
  this.position_0 = new Vec2_0;
  this.R = new Mat22_0;
}

function mulToOut_0(T, v, out){
  $clinit_Transform();
  var tempy;
  tempy = T.position_0.y + T.R.m12 * v.x + T.R.m22 * v.y;
  out.x = T.position_0.x + T.R.m11 * v.x + T.R.m21 * v.y;
  out.y = tempy;
}

function mulTransToOut_0(T, v, out){
  $clinit_Transform();
  var tempy, v1x, v1y;
  v1x = v.x - T.position_0.x;
  v1y = v.y - T.position_0.y;
  tempy = v1x * T.R.m21 + v1y * T.R.m22;
  out.x = v1x * T.R.m11 + v1y * T.R.m12;
  out.y = tempy;
}

defineSeed(299, 1, {}, Transform_0);
_.toString$ = function toString_29(){
  var s;
  s = 'XForm:\n';
  s += 'Position: ' + this.position_0 + '\n';
  s += 'R: \n' + this.R + '\n';
  return s;
}
;
_.R = null;
_.position_0 = null;
var identity = null;
function $absLocal(this$static){
  this$static.x = abs_0(this$static.x);
  this$static.y = abs_0(this$static.y);
}

function $addLocal(this$static, v){
  this$static.x += v.x;
  this$static.y += v.y;
  return this$static;
}

function $length(this$static){
  return $clinit_MathUtils() , sqrt(this$static.x * this$static.x + this$static.y * this$static.y);
}

function $lengthSquared(this$static){
  return this$static.x * this$static.x + this$static.y * this$static.y;
}

function $mulLocal(this$static, a){
  this$static.x *= a;
  this$static.y *= a;
  return this$static;
}

function $negateLocal(this$static){
  this$static.x = -this$static.x;
  this$static.y = -this$static.y;
  return this$static;
}

function $normalize_0(this$static){
  var invLength, length_0;
  length_0 = ($clinit_MathUtils() , sqrt(this$static.x * this$static.x + this$static.y * this$static.y));
  if (length_0 < 1.1920928955078125E-7) {
    return 0;
  }
  invLength = 1 / length_0;
  this$static.x *= invLength;
  this$static.y *= invLength;
  return length_0;
}

function $set_13(this$static, x, y){
  this$static.x = x;
  this$static.y = y;
  return this$static;
}

function $set_14(this$static, v){
  this$static.x = v.x;
  this$static.y = v.y;
  return this$static;
}

function $setZero(this$static){
  this$static.x = 0;
  this$static.y = 0;
}

function $subLocal(this$static, v){
  this$static.x -= v.x;
  this$static.y -= v.y;
  return this$static;
}

function Vec2_0(){
  Vec2_1.call(this, 0, 0);
}

function Vec2_1(x, y){
  this.x = x;
  this.y = y;
}

function cross(a, b){
  return a.x * b.y - a.y * b.x;
}

function crossToOut(s, a, out){
  var tempY;
  tempY = s * a.x;
  out.x = -s * a.y;
  out.y = tempY;
}

function crossToOut_0(a, s, out){
  var tempy;
  tempy = -s * a.x;
  out.x = s * a.y;
  out.y = tempy;
}

function dot_0(a, b){
  return a.x * b.x + a.y * b.y;
}

defineSeed(300, 1, makeCastMap([Q$Vec2]), Vec2_0, Vec2_1);
_.equals$ = function equals_13(obj){
  var other;
  if (this === obj)
    return true;
  if (obj == null)
    return false;
  if (Lorg_jbox2d_common_Vec2_2_classLit != getClass__devirtual$(obj))
    return false;
  other = obj;
  if (this.x != other.x)
    return false;
  if (this.y != other.y)
    return false;
  return true;
}
;
_.hashCode$ = function hashCode_14(){
  var result;
  result = 31 + round_int(this.x);
  result = 31 * result + round_int(this.y);
  return result;
}
;
_.toString$ = function toString_30(){
  return '(' + this.x + ',' + this.y + ')';
}
;
_.x = 0;
_.y = 0;
function Vec3_0(){
  this.x = this.y = this.z = 0;
}

defineSeed(301, 1, makeCastMap([Q$Vec3]), Vec3_0);
_.equals$ = function equals_14(obj){
  var other;
  if (this === obj)
    return true;
  if (obj == null)
    return false;
  if (Lorg_jbox2d_common_Vec3_2_classLit != getClass__devirtual$(obj))
    return false;
  other = obj;
  if (this.x != other.x)
    return false;
  if (this.y != other.y)
    return false;
  if (this.z != other.z)
    return false;
  return true;
}
;
_.hashCode$ = function hashCode_15(){
  var result;
  result = 31 + round_int(this.x);
  result = 31 * result + round_int(this.y);
  result = 31 * result + round_int(this.z);
  return result;
}
;
_.toString$ = function toString_31(){
  return '(' + this.x + ',' + this.y + ',' + this.z + ')';
}
;
_.x = 0;
_.y = 0;
_.z = 0;
function $advance_0(this$static, t){
  $advance(this$static.m_sweep, t);
  $set_14(this$static.m_sweep.c, this$static.m_sweep.c0);
  this$static.m_sweep.a_0 = this$static.m_sweep.a0;
  $synchronizeTransform(this$static);
}

function $createFixture(this$static, def){
  var broadPhase, fixture;
  if ((this$static.m_world.m_flags & 2) == 2) {
    return null;
  }
  fixture = new Fixture_0;
  fixture.m_userData = def.userData;
  fixture.m_friction = def.friction;
  fixture.m_restitution = def.restitution;
  fixture.m_body = this$static;
  fixture.m_next = null;
  $set_15(fixture.m_filter, def.filter);
  fixture.m_isSensor = def.isSensor;
  fixture.m_shape = $clone(def.shape);
  fixture.m_density = def.density;
  if ((this$static.m_flags & 32) == 32) {
    broadPhase = this$static.m_world.m_contactManager.m_broadPhase;
    $createProxy_1(fixture, broadPhase, this$static.m_xf);
  }
  fixture.m_next = this$static.m_fixtureList;
  this$static.m_fixtureList = fixture;
  ++this$static.m_fixtureCount;
  fixture.m_body = this$static;
  fixture.m_density > 0 && $resetMassData(this$static);
  this$static.m_world.m_flags |= 1;
  return fixture;
}

function $getWorldPointToOut(this$static, localPoint, out){
  mulToOut_0(this$static.m_xf, localPoint, out);
}

function $getWorldVectorToOut(this$static, localVector, out){
  mulToOut(this$static.m_xf.R, localVector, out);
}

function $resetMassData(this$static){
  var center, f, massData, oldCenter, temp;
  this$static.m_mass = 0;
  this$static.m_invMass = 0;
  this$static.m_I = 0;
  this$static.m_invI = 0;
  $setZero(this$static.m_sweep.localCenter);
  if (this$static.m_type == ($clinit_BodyType() , STATIC_0) || this$static.m_type == KINEMATIC) {
    $set_14(this$static.m_sweep.c, this$static.m_xf.position_0);
    $set_14(this$static.m_sweep.c0, this$static.m_xf.position_0);
    return;
  }
  center = $pop_1(this$static.m_world.pool.vecs);
  center.x = 0;
  center.y = 0;
  temp = $pop_1(this$static.m_world.pool.vecs);
  massData = this$static.pmd;
  for (f = this$static.m_fixtureList; f; f = f.m_next) {
    if (f.m_density == 0) {
      continue;
    }
    $computeMass(f.m_shape, massData, f.m_density);
    this$static.m_mass += massData.mass;
    $mulLocal($set_14(temp, massData.center), massData.mass);
    center.x += temp.x;
    center.y += temp.y;
    this$static.m_I += massData.I;
  }
  if (this$static.m_mass > 0) {
    this$static.m_invMass = 1 / this$static.m_mass;
    $mulLocal(center, this$static.m_invMass);
  }
   else {
    this$static.m_mass = 1;
    this$static.m_invMass = 1;
  }
  if (this$static.m_I > 0 && (this$static.m_flags & 16) == 0) {
    this$static.m_I -= this$static.m_mass * (center.x * center.x + center.y * center.y);
    this$static.m_invI = 1 / this$static.m_I;
  }
   else {
    this$static.m_I = 0;
    this$static.m_invI = 0;
  }
  oldCenter = $pop_1(this$static.m_world.pool.vecs);
  $set_14(oldCenter, this$static.m_sweep.c);
  $set_14(this$static.m_sweep.localCenter, center);
  mulToOut_0(this$static.m_xf, this$static.m_sweep.localCenter, this$static.m_sweep.c0);
  $set_14(this$static.m_sweep.c, this$static.m_sweep.c0);
  $subLocal($set_14(temp, this$static.m_sweep.c), oldCenter);
  crossToOut(this$static.m_angularVelocity, temp, temp);
  $addLocal(this$static.m_linearVelocity, temp);
  this$static.m_world.pool.vecs.index_0 -= 3;
}

function $setAwake(this$static, flag){
  if (flag) {
    if ((this$static.m_flags & 2) == 0) {
      this$static.m_flags |= 2;
      this$static.m_sleepTime = 0;
    }
  }
   else {
    this$static.m_flags &= -3;
    this$static.m_sleepTime = 0;
    $setZero(this$static.m_linearVelocity);
    this$static.m_angularVelocity = 0;
    $setZero(this$static.m_force);
    this$static.m_torque = 0;
  }
}

function $shouldCollide_0(this$static, other){
  if (this$static.m_type != ($clinit_BodyType() , DYNAMIC) && other.m_type != DYNAMIC) {
    return false;
  }
  return true;
}

function $synchronizeFixtures(this$static){
  var broadPhase, f, xf1;
  xf1 = this$static.pxf;
  $set_9(xf1.R, this$static.m_sweep.a0);
  mulToOut(xf1.R, this$static.m_sweep.localCenter, xf1.position_0);
  $addLocal($mulLocal(xf1.position_0, -1), this$static.m_sweep.c0);
  broadPhase = this$static.m_world.m_contactManager.m_broadPhase;
  for (f = this$static.m_fixtureList; f; f = f.m_next) {
    $synchronize(f, broadPhase, xf1, this$static.m_xf);
  }
}

function $synchronizeTransform(this$static){
  var c, s;
  c = ($clinit_MathUtils() , cos(this$static.m_sweep.a_0));
  s = sin(this$static.m_sweep.a_0);
  this$static.m_xf.R.m11 = c;
  this$static.m_xf.R.m21 = -s;
  this$static.m_xf.R.m12 = s;
  this$static.m_xf.R.m22 = c;
  this$static.m_xf.position_0.x = this$static.m_xf.R.m11 * this$static.m_sweep.localCenter.x + this$static.m_xf.R.m21 * this$static.m_sweep.localCenter.y;
  this$static.m_xf.position_0.y = this$static.m_xf.R.m12 * this$static.m_sweep.localCenter.x + this$static.m_xf.R.m22 * this$static.m_sweep.localCenter.y;
  this$static.m_xf.position_0.x *= -1;
  this$static.m_xf.position_0.y *= -1;
  this$static.m_xf.position_0.x += this$static.m_sweep.c.x;
  this$static.m_xf.position_0.y += this$static.m_sweep.c.y;
}

function Body_0(bd, world){
  this.m_xf = new Transform_0;
  this.m_sweep = new Sweep_0;
  this.m_linearVelocity = new Vec2_0;
  this.m_force = new Vec2_0;
  new FixtureDef_0;
  this.pmd = new MassData_0;
  this.pxf = new Transform_0;
  this.m_flags = 0;
  bd.bullet && (this.m_flags |= 8);
  bd.fixedRotation && (this.m_flags |= 16);
  bd.allowSleep && (this.m_flags |= 4);
  bd.awake && (this.m_flags |= 2);
  bd.active && (this.m_flags |= 32);
  this.m_world = world;
  $set_14(this.m_xf.position_0, bd.position_0);
  $set_9(this.m_xf.R, bd.angle);
  $setZero(this.m_sweep.localCenter);
  this.m_sweep.a0 = this.m_sweep.a_0 = bd.angle;
  mulToOut_0(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c0);
  $set_14(this.m_sweep.c, this.m_sweep.c0);
  this.m_contactList = null;
  this.m_next = null;
  $set_14(this.m_linearVelocity, bd.linearVelocity);
  this.m_angularVelocity = bd.angularVelocity;
  this.m_linearDamping = bd.linearDamping;
  this.m_angularDamping = bd.angularDamping;
  $setZero(this.m_force);
  this.m_torque = 0;
  this.m_sleepTime = 0;
  this.m_type = bd.type_0;
  if (this.m_type == ($clinit_BodyType() , DYNAMIC)) {
    this.m_mass = 1;
    this.m_invMass = 1;
  }
   else {
    this.m_mass = 0;
    this.m_invMass = 0;
  }
  this.m_I = 0;
  this.m_invI = 0;
  this.m_fixtureList = null;
  this.m_fixtureCount = 0;
}

defineSeed(302, 1, makeCastMap([Q$Body]), Body_0);
_.m_I = 0;
_.m_angularDamping = 0;
_.m_angularVelocity = 0;
_.m_contactList = null;
_.m_fixtureCount = 0;
_.m_fixtureList = null;
_.m_flags = 0;
_.m_invI = 0;
_.m_invMass = 0;
_.m_linearDamping = 0;
_.m_mass = 0;
_.m_next = null;
_.m_sleepTime = 0;
_.m_torque = 0;
_.m_type = null;
_.m_world = null;
function BodyDef_0(){
  this.position_0 = new Vec2_0;
  this.angle = 0;
  this.linearVelocity = new Vec2_0;
  this.angularVelocity = 0;
  this.linearDamping = 0;
  this.angularDamping = 0;
  this.allowSleep = true;
  this.awake = true;
  this.fixedRotation = false;
  this.bullet = false;
  this.type_0 = ($clinit_BodyType() , STATIC_0);
  this.active = true;
}

defineSeed(303, 1, {}, BodyDef_0);
_.active = false;
_.allowSleep = false;
_.angle = 0;
_.angularDamping = 0;
_.angularVelocity = 0;
_.awake = false;
_.bullet = false;
_.fixedRotation = false;
_.linearDamping = 0;
_.linearVelocity = null;
_.position_0 = null;
_.type_0 = null;
function $clinit_BodyType(){
  $clinit_BodyType = nullMethod;
  STATIC_0 = new BodyType_0('STATIC', 0);
  KINEMATIC = new BodyType_0('KINEMATIC', 1);
  DYNAMIC = new BodyType_0('DYNAMIC', 2);
  $VALUES_11 = initValues(_3Lorg_jbox2d_dynamics_BodyType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$BodyType, [STATIC_0, KINEMATIC, DYNAMIC]);
}

function BodyType_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_11(){
  $clinit_BodyType();
  return $VALUES_11;
}

defineSeed(304, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$BodyType]), BodyType_0);
var $VALUES_11, DYNAMIC, KINEMATIC, STATIC_0;
function $addPair(this$static, proxyUserDataA, proxyUserDataB){
  var bodyA, bodyB, c, edge, fA, fB, fixtureA, fixtureB;
  bodyA = proxyUserDataA.m_body;
  bodyB = proxyUserDataB.m_body;
  if (bodyA == bodyB) {
    return;
  }
  edge = bodyB.m_contactList;
  while (edge) {
    if (edge.other == bodyA) {
      fA = edge.contact.m_fixtureA;
      fB = edge.contact.m_fixtureB;
      if (fA == proxyUserDataA && fB == proxyUserDataB) {
        return;
      }
      if (fA == proxyUserDataB && fB == proxyUserDataA) {
        return;
      }
    }
    edge = edge.next;
  }
  if (!$shouldCollide_0(bodyB, bodyA)) {
    return;
  }
  if (!!this$static.m_contactFilter && !$shouldCollide(proxyUserDataA, proxyUserDataB)) {
    return;
  }
  c = $popContact(this$static.pool, proxyUserDataA, proxyUserDataB);
  fixtureA = c.m_fixtureA;
  fixtureB = c.m_fixtureB;
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  c.m_prev = null;
  c.m_next = this$static.m_contactList;
  !!this$static.m_contactList && (this$static.m_contactList.m_prev = c);
  this$static.m_contactList = c;
  c.m_nodeA.contact = c;
  c.m_nodeA.other = bodyB;
  c.m_nodeA.prev = null;
  c.m_nodeA.next = bodyA.m_contactList;
  !!bodyA.m_contactList && (bodyA.m_contactList.prev = c.m_nodeA);
  bodyA.m_contactList = c.m_nodeA;
  c.m_nodeB.contact = c;
  c.m_nodeB.other = bodyA;
  c.m_nodeB.prev = null;
  c.m_nodeB.next = bodyB.m_contactList;
  !!bodyB.m_contactList && (bodyB.m_contactList.prev = c.m_nodeB);
  bodyB.m_contactList = c.m_nodeB;
  ++this$static.m_contactCount;
}

function $collide(this$static){
  var bodyA, bodyB, c, cNuke, fixtureA, fixtureB, overlap, proxyIdA, proxyIdB;
  c = this$static.m_contactList;
  while (c) {
    fixtureA = c.m_fixtureA;
    fixtureB = c.m_fixtureB;
    bodyA = fixtureA.m_body;
    bodyB = fixtureB.m_body;
    if ((bodyA.m_flags & 2) != 2 && (bodyB.m_flags & 2) != 2) {
      c = c.m_next;
      continue;
    }
    if ((c.m_flags & 8) == 8) {
      if (!$shouldCollide_0(bodyB, bodyA)) {
        cNuke = c;
        c = c.m_next;
        $destroy(this$static, cNuke);
        continue;
      }
      if (!!this$static.m_contactFilter && !$shouldCollide(fixtureA, fixtureB)) {
        cNuke = c;
        c = c.m_next;
        $destroy(this$static, cNuke);
        continue;
      }
      c.m_flags &= -9;
    }
    proxyIdA = fixtureA.m_proxy;
    proxyIdB = fixtureB.m_proxy;
    overlap = $testOverlap_0(proxyIdA, proxyIdB);
    if (!overlap) {
      cNuke = c;
      c = c.m_next;
      $destroy(this$static, cNuke);
      continue;
    }
    $update(c);
    c = c.m_next;
  }
}

function $destroy(this$static, c){
  var bodyA, bodyB, fixtureA, fixtureB;
  fixtureA = c.m_fixtureA;
  fixtureB = c.m_fixtureB;
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  !!c.m_prev && (c.m_prev.m_next = c.m_next);
  !!c.m_next && (c.m_next.m_prev = c.m_prev);
  c == this$static.m_contactList && (this$static.m_contactList = c.m_next);
  c.m_next = null;
  c.m_prev = null;
  !!c.m_nodeA.prev && (c.m_nodeA.prev.next = c.m_nodeA.next);
  !!c.m_nodeA.next && (c.m_nodeA.next.prev = c.m_nodeA.prev);
  c.m_nodeA == bodyA.m_contactList && (bodyA.m_contactList = c.m_nodeA.next);
  !!c.m_nodeB.prev && (c.m_nodeB.prev.next = c.m_nodeB.next);
  !!c.m_nodeB.next && (c.m_nodeB.next.prev = c.m_nodeB.prev);
  c.m_nodeB == bodyB.m_contactList && (bodyB.m_contactList = c.m_nodeB.next);
  $pushContact(this$static.pool, c);
  --this$static.m_contactCount;
}

function $findNewContacts(this$static){
  $updatePairs(this$static.m_broadPhase, this$static);
}

function ContactManager_0(argPool){
  this.m_contactList = null;
  this.m_contactCount = 0;
  this.m_contactFilter = new ContactFilter_0;
  this.m_broadPhase = new BroadPhase_0;
  this.pool = argPool;
}

defineSeed(305, 1, {}, ContactManager_0);
_.m_broadPhase = null;
_.m_contactCount = 0;
_.m_contactFilter = null;
_.m_contactList = null;
_.pool = null;
function $set_15(this$static, argOther){
  this$static.categoryBits = argOther.categoryBits;
  this$static.maskBits = argOther.maskBits;
  this$static.groupIndex = argOther.groupIndex;
}

function Filter_0(){
}

defineSeed(306, 1, {}, Filter_0);
_.categoryBits = 0;
_.groupIndex = 0;
_.maskBits = 0;
function $createProxy_1(this$static, broadPhase, xf){
  $computeAABB(this$static.m_shape, this$static.m_aabb, xf);
  this$static.m_proxy = $createProxy(broadPhase, this$static.m_aabb, this$static);
}

function $synchronize(this$static, broadPhase, transform1, transform2){
  var disp;
  if (!this$static.m_proxy) {
    return;
  }
  $computeAABB(this$static.m_shape, this$static.pool1, transform1);
  $computeAABB(this$static.m_shape, this$static.pool2, transform2);
  this$static.m_aabb.lowerBound.x = this$static.pool1.lowerBound.x < this$static.pool2.lowerBound.x?this$static.pool1.lowerBound.x:this$static.pool2.lowerBound.x;
  this$static.m_aabb.lowerBound.y = this$static.pool1.lowerBound.y < this$static.pool2.lowerBound.y?this$static.pool1.lowerBound.y:this$static.pool2.lowerBound.y;
  this$static.m_aabb.upperBound.x = this$static.pool1.upperBound.x > this$static.pool2.upperBound.x?this$static.pool1.upperBound.x:this$static.pool2.upperBound.x;
  this$static.m_aabb.upperBound.y = this$static.pool1.upperBound.y > this$static.pool2.upperBound.y?this$static.pool1.upperBound.y:this$static.pool2.upperBound.y;
  disp = this$static.pool1.lowerBound;
  disp.x = transform2.position_0.x - transform1.position_0.x;
  disp.y = transform2.position_0.y - transform1.position_0.y;
  $moveProxy(broadPhase, this$static.m_proxy, this$static.m_aabb, disp);
}

function Fixture_0(){
  this.m_aabb = new AABB_0;
  this.pool1 = new AABB_0;
  this.pool2 = new AABB_0;
  this.m_userData = null;
  this.m_body = null;
  this.m_next = null;
  this.m_proxy = null;
  this.m_shape = null;
  this.m_filter = new Filter_0;
}

defineSeed(307, 1, {}, Fixture_0);
_.m_body = null;
_.m_density = 0;
_.m_filter = null;
_.m_friction = 0;
_.m_isSensor = false;
_.m_next = null;
_.m_proxy = null;
_.m_restitution = 0;
_.m_shape = null;
_.m_userData = null;
function FixtureDef_0(){
  this.shape = null;
  this.userData = null;
  this.friction = 0.20000000298023224;
  this.restitution = 0;
  this.density = 0;
  this.filter = new Filter_0;
  this.filter.categoryBits = 1;
  this.filter.maskBits = 65535;
  this.filter.groupIndex = 0;
  this.isSensor = false;
}

defineSeed(308, 1, {}, FixtureDef_0);
_.density = 0;
_.filter = null;
_.friction = 0;
_.isSensor = false;
_.restitution = 0;
_.shape = null;
_.userData = null;
function $add_6(this$static, body){
  this$static.m_bodies[this$static.m_bodyCount++] = body;
}

function $add_7(this$static, contact){
  setCheck(this$static.m_contacts, this$static.m_contactCount++, contact);
}

function $clear_1(this$static){
  this$static.m_bodyCount = 0;
  this$static.m_contactCount = 0;
  this$static.m_jointCount = 0;
}

--></script>
<script><!--
function $init(this$static, bodyCapacity, contactCapacity, jointCapacity){
  var i;
  this$static.m_bodyCapacity = bodyCapacity;
  this$static.m_contactCapacity = contactCapacity;
  this$static.m_jointCapacity = jointCapacity;
  this$static.m_bodyCount = 0;
  this$static.m_contactCount = 0;
  this$static.m_jointCount = 0;
  (this$static.m_bodies == null || this$static.m_bodyCapacity > this$static.m_bodies.length) && (this$static.m_bodies = initDim(_3Lorg_jbox2d_dynamics_Body_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Body, this$static.m_bodyCapacity, 0));
  (this$static.m_joints == null || this$static.m_jointCapacity > this$static.m_joints.length) && (this$static.m_joints = initDim(_3Lorg_jbox2d_dynamics_joints_Joint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Joint, this$static.m_jointCapacity, 0));
  (this$static.m_contacts == null || this$static.m_contactCapacity > this$static.m_contacts.length) && (this$static.m_contacts = initDim(_3Lorg_jbox2d_dynamics_contacts_Contact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Contact, this$static.m_contactCapacity, 0));
  if (this$static.m_velocities == null || this$static.m_bodyCapacity > this$static.m_velocities.length) {
    this$static.m_velocities = initDim(_3Lorg_jbox2d_dynamics_Velocity_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Velocity, this$static.m_bodyCapacity, 0);
    for (i = 0; i < this$static.m_velocities.length; ++i) {
      this$static.m_velocities[i] = new Velocity_0;
    }
  }
  if (this$static.m_positions == null || this$static.m_bodyCapacity > this$static.m_positions.length) {
    this$static.m_positions = initDim(_3Lorg_jbox2d_dynamics_Position_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Position, this$static.m_bodyCapacity, 0);
    for (i = 0; i < this$static.m_positions.length; ++i) {
      this$static.m_positions[i] = new Position_0;
    }
  }
}

function $solve(this$static, step, gravity, allowSleep){
  var a, a1, a2, angTolSqr, b, b1, bodyA, bodyB, contactsOkay, fixtureA, fixtureB, i, i1, i2, j, jointOkay, jointsOkay, linTolSqr, minSleepTime, nonStatic, ratio, rotation, temp;
  for (i = 0; i < this$static.m_bodyCount; ++i) {
    b = this$static.m_bodies[i];
    if (b.m_type != ($clinit_BodyType() , DYNAMIC)) {
      continue;
    }
    b.m_linearVelocity.x += (b.m_force.x * b.m_invMass + gravity.x) * step.dt;
    b.m_linearVelocity.y += (b.m_force.y * b.m_invMass + gravity.y) * step.dt;
    b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
    a = 1 - step.dt * b.m_linearDamping;
    a1 = 0 > (a < 1?a:1)?0:a < 1?a:1;
    b.m_linearVelocity.x *= a1;
    b.m_linearVelocity.y *= a1;
    a2 = 1 - step.dt * b.m_angularDamping;
    b1 = a2 < 1?a2:1;
    b.m_angularVelocity *= 0 > b1?0:b1;
  }
  i1 = -1;
  for (i2 = 0; i2 < this$static.m_contactCount; ++i2) {
    fixtureA = this$static.m_contacts[i2].m_fixtureA;
    fixtureB = this$static.m_contacts[i2].m_fixtureB;
    bodyA = fixtureA.m_body;
    bodyB = fixtureB.m_body;
    nonStatic = bodyA.m_type != ($clinit_BodyType() , STATIC_0) && bodyB.m_type != STATIC_0;
    if (nonStatic) {
      ++i1;
      temp = this$static.m_contacts[i1];
      setCheck(this$static.m_contacts, i1, this$static.m_contacts[i2]);
      setCheck(this$static.m_contacts, i2, temp);
    }
  }
  $init_1(this$static.contactSolver, this$static.m_contacts, this$static.m_contactCount, step.dtRatio);
  $warmStart(this$static.contactSolver);
  for (i = 0; i < this$static.m_jointCount; ++i) {
    null.nullMethod();
  }
  for (i = 0; i < step.velocityIterations; ++i) {
    for (j = 0; j < this$static.m_jointCount; ++j) {
      null.nullMethod();
    }
    $solveVelocityConstraints(this$static.contactSolver);
  }
  $storeImpulses(this$static.contactSolver);
  for (i = 0; i < this$static.m_bodyCount; ++i) {
    b = this$static.m_bodies[i];
    if (b.m_type == ($clinit_BodyType() , STATIC_0)) {
      continue;
    }
    $mulLocal($set_14(this$static.translation, b.m_linearVelocity), step.dt);
    if (dot_0(this$static.translation, this$static.translation) > ($clinit_Settings() , 4)) {
      ratio = 2 / $length(this$static.translation);
      $mulLocal(b.m_linearVelocity, ratio);
    }
    rotation = step.dt * b.m_angularVelocity;
    if (rotation * rotation > 2.4674012660980225) {
      ratio = 1.5707963705062866 / abs(rotation);
      b.m_angularVelocity *= ratio;
    }
    $set_14(b.m_sweep.c0, b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a_0;
    $mulLocal($set_14(this$static.temp, b.m_linearVelocity), step.dt);
    $addLocal(b.m_sweep.c, this$static.temp);
    b.m_sweep.a_0 += step.dt * b.m_angularVelocity;
    $synchronizeTransform(b);
  }
  for (i = 0; i < step.positionIterations; ++i) {
    contactsOkay = $solvePositionConstraints(this$static.contactSolver, ($clinit_Settings() , 0.20000000298023224));
    jointsOkay = true;
    for (j = 0; j < this$static.m_jointCount; ++j) {
      jointOkay = null.nullMethod($clinit_Settings());
      jointsOkay = jointsOkay && jointOkay;
    }
    if (contactsOkay && jointsOkay) {
      break;
    }
  }
  if (allowSleep) {
    minSleepTime = 3.4028234663852886E38;
    linTolSqr = ($clinit_Settings() , 0.009999999776482582) * 0.009999999776482582;
    angTolSqr = 0.03490658849477768 * 0.03490658849477768;
    for (i = 0; i < this$static.m_bodyCount; ++i) {
      b = this$static.m_bodies[i];
      if (b.m_type == ($clinit_BodyType() , STATIC_0)) {
        continue;
      }
      if ((b.m_flags & 4) == 0) {
        b.m_sleepTime = 0;
        minSleepTime = 0;
      }
      if ((b.m_flags & 4) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || dot_0(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
        b.m_sleepTime = 0;
        minSleepTime = 0;
      }
       else {
        b.m_sleepTime += step.dt;
        minSleepTime = min_0(minSleepTime, b.m_sleepTime);
      }
    }
    if (minSleepTime >= 0.5) {
      for (i = 0; i < this$static.m_bodyCount; ++i) {
        b = this$static.m_bodies[i];
        $setAwake(b, false);
      }
    }
  }
}

function Island_0(){
  this.temp = new Vec2_0;
  this.contactSolver = new ContactSolver_0;
  this.translation = new Vec2_0;
  new ContactImpulse_0;
}

defineSeed(309, 1, {}, Island_0);
_.m_bodies = null;
_.m_bodyCapacity = 0;
_.m_bodyCount = 0;
_.m_contactCapacity = 0;
_.m_contactCount = 0;
_.m_contacts = null;
_.m_jointCapacity = 0;
_.m_jointCount = 0;
_.m_joints = null;
_.m_positions = null;
_.m_velocities = null;
function Position_0(){
  new Vec2_0;
}

defineSeed(310, 1, makeCastMap([Q$Position]), Position_0);
function TimeStep_0(){
}

defineSeed(311, 1, {}, TimeStep_0);
_.dt = 0;
_.dtRatio = 0;
_.inv_dt = 0;
_.positionIterations = 0;
_.velocityIterations = 0;
function Velocity_0(){
  new Vec2_0;
}

defineSeed(312, 1, makeCastMap([Q$Velocity]), Velocity_0);
function $clinit_World(){
  $clinit_World = nullMethod;
  avs = new Vec2Array_0;
  new Integer_0(1234598372);
}

function $addType(this$static, creator, type1, type2){
  var register, register2;
  register = new ContactRegister_0;
  register.creator = creator;
  register.primary = true;
  this$static.contactStacks[type1.intValue][type2.intValue] = register;
  if (type1 != type2) {
    register2 = new ContactRegister_0;
    register2.creator = creator;
    register2.primary = false;
    this$static.contactStacks[type2.intValue][type1.intValue] = register2;
  }
}

function $clearForces(this$static){
  var body;
  for (body = this$static.m_bodyList; body; body = body.m_next) {
    $setZero(body.m_force);
    body.m_torque = 0;
  }
}

function $createBody(this$static, def){
  var b;
  if ((this$static.m_flags & 2) == 2) {
    return null;
  }
  b = new Body_0(def, this$static);
  b.m_next = this$static.m_bodyList;
  this$static.m_bodyList = b;
  ++this$static.m_bodyCount;
  return b;
}

function $drawDebugData(this$static){
  var aabb, b, c, f, fixtureA, fixtureB, flags, vs;
  if (!this$static.m_debugDraw) {
    return;
  }
  flags = this$static.m_debugDraw.m_drawFlags;
  if ((flags & 1) == 1) {
    for (b = this$static.m_bodyList; b; b = b.m_next) {
      $set_12(this$static.xf, b.m_xf);
      for (f = b.m_fixtureList; f; f = f.m_next) {
        (b.m_flags & 32) == 32?b.m_type == ($clinit_BodyType() , STATIC_0)?$drawShape(this$static, f, this$static.xf):b.m_type == KINEMATIC?$drawShape(this$static, f, this$static.xf):(b.m_flags & 2) == 2?$drawShape(this$static, f, this$static.xf):$drawShape(this$static, f, this$static.xf):$drawShape(this$static, f, this$static.xf);
      }
    }
  }
  if ((flags & 8) == 8) {
    for (c = this$static.m_contactManager.m_contactList; c; c = c.m_next) {
      fixtureA = c.m_fixtureA;
      fixtureB = c.m_fixtureB;
      $getCenterToOut(fixtureA.m_aabb, this$static.cA);
      $getCenterToOut(fixtureB.m_aabb, this$static.cB);
    }
  }
  if ((flags & 4) == 4) {
    for (b = this$static.m_bodyList; b; b = b.m_next) {
      if ((b.m_flags & 32) != 32) {
        continue;
      }
      for (f = b.m_fixtureList; f; f = f.m_next) {
        aabb = f.m_proxy.aabb;
        vs = $get_7(avs, 4);
        $set_13(vs[0], aabb.lowerBound.x, aabb.lowerBound.y);
        $set_13(vs[1], aabb.upperBound.x, aabb.lowerBound.y);
        $set_13(vs[2], aabb.upperBound.x, aabb.upperBound.y);
        $set_13(vs[3], aabb.lowerBound.x, aabb.upperBound.y);
        $drawPolygon();
        (b.m_flags & 64) == 64 && b.m_sweep;
      }
    }
  }
  if ((flags & 16) == 16) {
    for (b = this$static.m_bodyList; b; b = b.m_next) {
      $set_12(this$static.xf, b.m_xf);
      $set_14(this$static.xf.position_0, b.m_sweep.c);
    }
  }
  (flags & 32) == 32 && $drawTree(this$static.m_contactManager.m_broadPhase, this$static.m_debugDraw);
}

function $drawShape(this$static, fixture, xf){
  var b, circle, i, linVelLength, radius, vertexCount, vertices;
  switch (fixture.m_shape.m_type.ordinal) {
    case 1:
      {
        circle = fixture.m_shape;
        mulToOut_0(xf, circle.m_p, this$static.center);
        radius = circle.m_radius;
        this$static.axis.x = xf.R.m11;
        this$static.axis.y = xf.R.m12;
        if (fixture.m_userData != null && fixture.m_userData.nullMethod()) {
          b = fixture.m_body;
          $set_14(this$static.liquidOffset, b.m_linearVelocity);
          linVelLength = $length(b.m_linearVelocity);
          this$static.averageLinearVel == -1?(this$static.averageLinearVel = linVelLength):(this$static.averageLinearVel = 0.9800000190734863 * this$static.averageLinearVel + 0.019999999552965164 * linVelLength);
          $mulLocal(this$static.liquidOffset, 0.11999999731779099 / this$static.averageLinearVel / 2);
          $addLocal($set_14(this$static.circCenterMoved, this$static.center), this$static.liquidOffset);
          $subLocal(this$static.center, this$static.liquidOffset);
          return;
        }
        $drawCircle_0(this$static.m_debugDraw, this$static.center, radius);
      }

      break;
    case 2:
      {
        fixture.m_shape;
        vertexCount = null.nullField;
        vertices = $get_7(this$static.tlvertices, ($clinit_Settings() , 8));
        for (i = 0; i < vertexCount; ++i) {
          mulToOut_0(xf, null.nullField[i], vertices[i]);
        }
        $drawSolidPolygon(this$static.m_debugDraw, vertices, vertexCount);
      }

  }
}

function $popContact(this$static, fixtureA, fixtureB){
  var c, creator, reg, type1, type2;
  type1 = fixtureA.m_shape.m_type;
  type2 = fixtureB.m_shape.m_type;
  reg = this$static.contactStacks[type1.intValue][type2.intValue];
  creator = reg.creator;
  if (creator) {
    if (reg.primary) {
      c = $pop_0(creator);
      c.init(fixtureA, fixtureB);
      return c;
    }
     else {
      c = $pop_0(creator);
      c.init(fixtureB, fixtureA);
      return c;
    }
  }
   else {
    return null;
  }
}

function $pushContact(this$static, contact){
  var creator, type1, type2;
  if (contact.m_manifold.pointCount > 0) {
    $setAwake(contact.m_fixtureA.m_body, true);
    $setAwake(contact.m_fixtureB.m_body, true);
  }
  type1 = contact.m_fixtureA.m_shape.m_type;
  type2 = contact.m_fixtureB.m_shape.m_type;
  creator = this$static.contactStacks[type1.intValue][type2.intValue].creator;
  setCheck(creator.stack_0, --creator.index_0, contact);
}

function $setDebugDraw(this$static, debugDraw){
  this$static.m_debugDraw = debugDraw;
}

function $solve_0(this$static, step){
  var b, c, ce, contact, i, other, seed, sensorA, sensorB, stackCount, stackSize;
  $init(this$static.island, this$static.m_bodyCount, this$static.m_contactManager.m_contactCount, this$static.m_jointCount);
  for (b = this$static.m_bodyList; b; b = b.m_next) {
    b.m_flags &= -2;
  }
  for (c = this$static.m_contactManager.m_contactList; c; c = c.m_next) {
    c.m_flags &= -2;
  }
  stackSize = this$static.m_bodyCount;
  this$static.stack_0.length < stackSize && (this$static.stack_0 = initDim(_3Lorg_jbox2d_dynamics_Body_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Body, stackSize, 0));
  for (seed = this$static.m_bodyList; seed; seed = seed.m_next) {
    if ((seed.m_flags & 1) == 1) {
      continue;
    }
    if ((seed.m_flags & 2) != 2 || (seed.m_flags & 32) != 32) {
      continue;
    }
    if (seed.m_type == ($clinit_BodyType() , STATIC_0)) {
      continue;
    }
    $clear_1(this$static.island);
    stackCount = 0;
    this$static.stack_0[stackCount++] = seed;
    seed.m_flags |= 1;
    while (stackCount > 0) {
      b = this$static.stack_0[--stackCount];
      $add_6(this$static.island, b);
      $setAwake(b, true);
      if (b.m_type == STATIC_0) {
        continue;
      }
      for (ce = b.m_contactList; ce; ce = ce.next) {
        contact = ce.contact;
        if ((contact.m_flags & 1) == 1) {
          continue;
        }
        if ((contact.m_flags & 4) != 4 || (contact.m_flags & 2) != 2) {
          continue;
        }
        sensorA = contact.m_fixtureA.m_isSensor;
        sensorB = contact.m_fixtureB.m_isSensor;
        if (sensorA || sensorB) {
          continue;
        }
        $add_7(this$static.island, contact);
        contact.m_flags |= 1;
        other = ce.other;
        if ((other.m_flags & 1) == 1) {
          continue;
        }
        this$static.stack_0[stackCount++] = other;
        other.m_flags |= 1;
      }
    }
    $solve(this$static.island, step, this$static.m_gravity, this$static.m_allowSleep);
    for (i = 0; i < this$static.island.m_bodyCount; ++i) {
      b = this$static.island.m_bodies[i];
      b.m_type == STATIC_0 && (b.m_flags &= -2);
    }
  }
  for (b = this$static.m_bodyList; b; b = b.m_next) {
    if ((b.m_flags & 1) == 0) {
      continue;
    }
    if (b.m_type == ($clinit_BodyType() , STATIC_0)) {
      continue;
    }
    $synchronizeFixtures(b);
  }
  $findNewContacts(this$static.m_contactManager);
}

function $solveTOI(this$static){
  var body, c;
  for (c = this$static.m_contactManager.m_contactList; c; c = c.m_next) {
    c.m_flags |= 4;
    c.m_toiCount = 0;
  }
  for (body = this$static.m_bodyList; body; body = body.m_next) {
    (body.m_flags & 1) == 0 || body.m_type == ($clinit_BodyType() , KINEMATIC) || body.m_type == ($clinit_BodyType() , STATIC_0)?(body.m_flags |= 64):(body.m_flags &= -65);
  }
  for (body = this$static.m_bodyList; body; body = body.m_next) {
    if ((body.m_flags & 64) == 64) {
      continue;
    }
    if ((body.m_flags & 8) == 8) {
      continue;
    }
    $solveTOI_0(this$static, body);
    body.m_flags |= 64;
  }
  for (body = this$static.m_bodyList; body; body = body.m_next) {
    if ((body.m_flags & 64) == 64) {
      continue;
    }
    if ((body.m_flags & 8) != 8) {
      continue;
    }
    $solveTOI_0(this$static, body);
    body.m_flags |= 64;
  }
}

function $solveTOI_0(this$static, body){
  var bodyA, bodyB, bullet, ce, contact, contactsOkay, count, fixtureA, fixtureB, found, i, iter, other, toi, toiContact, toiOther, type;
  toiContact = null;
  toi = 1;
  toiOther = null;
  iter = 0;
  bullet = (body.m_flags & 8) == 8;
  do {
    count = 0;
    found = false;
    for (ce = body.m_contactList; ce; ce = ce.next) {
      if (ce.contact == toiContact) {
        continue;
      }
      other = ce.other;
      type = other.m_type;
      if (bullet) {
        if ((other.m_flags & 64) == 0) {
          continue;
        }
        if (type != ($clinit_BodyType() , STATIC_0) && (ce.contact.m_flags & 16) != 0) {
          continue;
        }
      }
       else if (type == ($clinit_BodyType() , DYNAMIC)) {
        continue;
      }
      contact = ce.contact;
      if ((contact.m_flags & 4) != 4) {
        continue;
      }
      if (contact.m_toiCount > 10) {
        continue;
      }
      fixtureA = contact.m_fixtureA;
      fixtureB = contact.m_fixtureB;
      if (fixtureA.m_isSensor || fixtureB.m_isSensor) {
        continue;
      }
      bodyA = fixtureA.m_body;
      bodyB = fixtureB.m_body;
      $set_5(this$static.toiInput.proxyA, fixtureA.m_shape);
      $set_5(this$static.toiInput.proxyB, fixtureB.m_shape);
      $set_11(this$static.toiInput.sweepA, bodyA.m_sweep);
      $set_11(this$static.toiInput.sweepB, bodyB.m_sweep);
      this$static.toiInput.tMax = toi;
      $timeOfImpact(this$static.pool.toi, this$static.toiOutput, this$static.toiInput);
      if (this$static.toiOutput.state == ($clinit_TimeOfImpact$TOIOutputState() , TOUCHING) && this$static.toiOutput.t < toi) {
        toiContact = contact;
        toi = this$static.toiOutput.t;
        toiOther = other;
        found = true;
      }
      ++count;
    }
    ++iter;
  }
   while (found && count > 1 && iter < 50);
  if (!toiContact) {
    $advance_0(body, 1);
    return;
  }
  $set_11(this$static.backup, body.m_sweep);
  $advance_0(body, toi);
  $update(toiContact);
  if ((toiContact.m_flags & 4) != 4) {
    $set_11(body.m_sweep, this$static.backup);
    $solveTOI_0(this$static, body);
  }
  ++toiContact.m_toiCount;
  (this$static.m_contacts == null || this$static.m_contacts.length < ($clinit_Settings() , 32)) && (this$static.m_contacts = initDim(_3Lorg_jbox2d_dynamics_contacts_Contact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Contact, ($clinit_Settings() , 32), 0));
  count = 0;
  for (ce = body.m_contactList; !!ce && count < ($clinit_Settings() , 32); ce = ce.next) {
    other = ce.other;
    type = other.m_type;
    if (type == ($clinit_BodyType() , DYNAMIC)) {
      continue;
    }
    contact = ce.contact;
    if ((contact.m_flags & 4) != 4) {
      continue;
    }
    fixtureA = contact.m_fixtureA;
    fixtureB = contact.m_fixtureB;
    if (fixtureA.m_isSensor || fixtureB.m_isSensor) {
      continue;
    }
    contact != toiContact && $update(contact);
    if ((contact.m_flags & 4) != 4) {
      continue;
    }
    if ((contact.m_flags & 2) != 2) {
      continue;
    }
    setCheck(this$static.m_contacts, count, contact);
    ++count;
  }
  $initialize_2(this$static.toiSolver, this$static.m_contacts, count, body);
  for (i = 0; i < 20; ++i) {
    contactsOkay = $solve_1(this$static.toiSolver);
    if (contactsOkay) {
      break;
    }
  }
  toiOther.m_type != ($clinit_BodyType() , STATIC_0) && (toiContact.m_flags |= 16);
}

function $step(this$static, dt){
  if ((this$static.m_flags & 1) == 1) {
    $findNewContacts(this$static.m_contactManager);
    this$static.m_flags &= -2;
  }
  this$static.m_flags |= 2;
  this$static.step.dt = dt;
  this$static.step.velocityIterations = 10;
  this$static.step.positionIterations = 10;
  dt > 0?(this$static.step.inv_dt = 1 / dt):(this$static.step.inv_dt = 0);
  this$static.step.dtRatio = this$static.m_inv_dt0 * dt;
  $collide(this$static.m_contactManager);
  this$static.step.dt > 0 && $solve_0(this$static, this$static.step);
  this$static.m_continuousPhysics && this$static.step.dt > 0 && $solveTOI(this$static);
  this$static.step.dt > 0 && (this$static.m_inv_dt0 = this$static.step.inv_dt);
  (this$static.m_flags & 4) == 4 && $clearForces(this$static);
  this$static.m_flags &= -3;
}

function World_0(gravity){
  $clinit_World();
  World_1.call(this, gravity, new WorldPool_0);
}

function World_1(gravity, argPool){
  this.m_gravity = new Vec2_0;
  this.contactStacks = initDims([_3_3Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit, _3Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit], [makeCastMap([Q$Serializable, Q$Object_$1]), makeCastMap([Q$Serializable, Q$Object_$1, Q$ContactRegister_$1])], [Q$ContactRegister_$1, Q$ContactRegister], [2, 2], 2, 0);
  this.step = new TimeStep_0;
  this.xf = new Transform_0;
  this.cA = new Vec2_0;
  this.cB = new Vec2_0;
  new WorldRayCastWrapper_0;
  new RayCastInput_0;
  this.island = new Island_0;
  this.stack_0 = initDim(_3Lorg_jbox2d_dynamics_Body_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Body, 10, 0);
  this.toiInput = new TimeOfImpact$TOIInput_0;
  this.toiOutput = new TimeOfImpact$TOIOutput_0;
  this.backup = new Sweep_0;
  this.toiSolver = new TOISolver_0;
  this.m_contacts = initDim(_3Lorg_jbox2d_dynamics_contacts_Contact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Contact, ($clinit_Settings() , 32), 0);
  this.liquidOffset = new Vec2_0;
  this.circCenterMoved = new Vec2_0;
  this.center = new Vec2_0;
  this.axis = new Vec2_0;
  this.tlvertices = new Vec2Array_0;
  this.pool = argPool;
  this.m_debugDraw = null;
  this.m_bodyList = null;
  this.m_bodyCount = 0;
  this.m_jointCount = 0;
  this.m_continuousPhysics = true;
  this.m_allowSleep = true;
  $set_14(this.m_gravity, gravity);
  this.m_flags = 4;
  this.m_inv_dt0 = 0;
  this.m_contactManager = new ContactManager_0(this);
  $addType(this, this.pool.ccstack, ($clinit_ShapeType() , CIRCLE), CIRCLE);
  $addType(this, this.pool.cpstack, POLYGON, CIRCLE);
  $addType(this, this.pool.pcstack, POLYGON, POLYGON);
}

defineSeed(313, 1, {}, World_0);
_.averageLinearVel = -1;
_.m_allowSleep = false;
_.m_bodyCount = 0;
_.m_bodyList = null;
_.m_contactManager = null;
_.m_continuousPhysics = false;
_.m_debugDraw = null;
_.m_flags = 0;
_.m_inv_dt0 = 0;
_.m_jointCount = 0;
_.pool = null;
var avs;
function WorldRayCastWrapper_0(){
  new RayCastOutput_0;
  new Vec2_0;
  new Vec2_0;
}

defineSeed(314, 1, {}, WorldRayCastWrapper_0);
function $clinit_Contact(){
  $clinit_Contact = nullMethod;
  tloldManifold = new TLManifold_0;
}

function $init_0(this$static, fA, fB){
  this$static.m_flags = 0;
  this$static.m_fixtureA = fA;
  this$static.m_fixtureB = fB;
  this$static.m_manifold.pointCount = 0;
  this$static.m_prev = null;
  this$static.m_next = null;
  this$static.m_nodeA.contact = null;
  this$static.m_nodeA.prev = null;
  this$static.m_nodeA.next = null;
  this$static.m_nodeA.other = null;
  this$static.m_nodeB.contact = null;
  this$static.m_nodeB.prev = null;
  this$static.m_nodeB.next = null;
  this$static.m_nodeB.other = null;
  this$static.m_toiCount = 0;
}

function $update(this$static){
  var bodyA, bodyB, i, id2, j, mp1, mp2, oldManifold, sensor, sensorA, sensorB, shapeA, shapeB, touching, wasTouching, xfA, xfB;
  oldManifold = $get_1(tloldManifold);
  $set_7(oldManifold, this$static.m_manifold);
  this$static.m_flags |= 4;
  wasTouching = (this$static.m_flags & 2) == 2;
  sensorA = this$static.m_fixtureA.m_isSensor;
  sensorB = this$static.m_fixtureB.m_isSensor;
  sensor = sensorA || sensorB;
  bodyA = this$static.m_fixtureA.m_body;
  bodyB = this$static.m_fixtureB.m_body;
  xfA = bodyA.m_xf;
  xfB = bodyB.m_xf;
  if (sensor) {
    shapeA = this$static.m_fixtureA.m_shape;
    shapeB = this$static.m_fixtureB.m_shape;
    touching = $testOverlap(this$static.pool.collision, shapeA, shapeB, xfA, xfB);
    this$static.m_manifold.pointCount = 0;
  }
   else {
    this$static.evaluate(this$static.m_manifold, xfA, xfB);
    touching = this$static.m_manifold.pointCount > 0;
    for (i = 0; i < this$static.m_manifold.pointCount; ++i) {
      mp2 = this$static.m_manifold.points[i];
      mp2.normalImpulse = 0;
      mp2.tangentImpulse = 0;
      id2 = mp2.id_0;
      for (j = 0; j < oldManifold.pointCount; ++j) {
        mp1 = oldManifold.points[j];
        if ($isEqual(mp1.id_0, id2)) {
          mp2.normalImpulse = mp1.normalImpulse;
          mp2.tangentImpulse = mp1.tangentImpulse;
          break;
        }
      }
    }
    if (touching != wasTouching) {
      $setAwake(bodyA, true);
      $setAwake(bodyB, true);
    }
  }
  touching?(this$static.m_flags |= 2):(this$static.m_flags &= -3);
  return;
}

function Contact_0(argPool){
  this.m_fixtureA = null;
  this.m_fixtureB = null;
  this.m_nodeA = new ContactEdge_0;
  this.m_nodeB = new ContactEdge_0;
  this.m_manifold = new Manifold_0;
  this.pool = argPool;
}

defineSeed(316, 1, makeCastMap([Q$Contact]));
_.init = function init_0(fA, fB){
  $init_0(this, fA, fB);
}
;
_.m_fixtureA = null;
_.m_fixtureB = null;
_.m_flags = 0;
_.m_manifold = null;
_.m_next = null;
_.m_nodeA = null;
_.m_nodeB = null;
_.m_prev = null;
_.m_toiCount = 0;
_.pool = null;
var tloldManifold;
function CircleContact_0(argPool){
  $clinit_Contact();
  Contact_0.call(this, argPool);
}

defineSeed(315, 316, makeCastMap([Q$CircleContact, Q$Contact]), CircleContact_0);
_.evaluate = function evaluate(manifold, xfA, xfB){
  $collideCircles(this.pool.collision, manifold, this.m_fixtureA.m_shape, xfA, this.m_fixtureB.m_shape, xfB);
}
;
_.init = function init_1(fixtureA, fixtureB){
  $init_0(this, fixtureA, fixtureB);
}
;
function ContactConstraint_0(){
  var i;
  this.points = initDim(_3Lorg_jbox2d_dynamics_contacts_ContactConstraintPoint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ContactConstraintPoint, ($clinit_Settings() , 2), 0);
  for (i = 0; i < 2; ++i) {
    this.points[i] = new ContactConstraintPoint_0;
  }
  this.pointCount = 0;
  this.localNormal = new Vec2_0;
  this.localPoint = new Vec2_0;
  this.normal = new Vec2_0;
  this.normalMass = new Mat22_0;
  this.K = new Mat22_0;
}

defineSeed(317, 1, makeCastMap([Q$ContactConstraint]), ContactConstraint_0);
_.K = null;
_.bodyA = null;
_.bodyB = null;
_.friction = 0;
_.localNormal = null;
_.localPoint = null;
_.manifold = null;
_.normal = null;
_.normalMass = null;
_.pointCount = 0;
_.points = null;
_.radius = 0;
_.type_0 = null;
function ContactConstraintPoint_0(){
  this.localPoint = new Vec2_0;
  this.rA = new Vec2_0;
  this.rB = new Vec2_0;
}

defineSeed(318, 1, makeCastMap([Q$ContactConstraintPoint]), ContactConstraintPoint_0);
_.localPoint = null;
_.normalImpulse = 0;
_.normalMass = 0;
_.rA = null;
_.rB = null;
_.tangentImpulse = 0;
_.tangentMass = 0;
_.velocityBias = 0;
function ContactEdge_0(){
}

defineSeed(319, 1, {}, ContactEdge_0);
_.contact = null;
_.next = null;
_.other = null;
_.prev = null;
function ContactRegister_0(){
}

defineSeed(320, 1, makeCastMap([Q$ContactRegister]), ContactRegister_0);
_.creator = null;
_.primary = false;
--></script>
<script><!--
function $init_1(this$static, contacts, contactCount, impulseRatio){
  var a, bodyA, bodyB, cc, ccp, ccp1, ccp2, contact, cp, fixtureA, fixtureB, friction, i, invIA, invIB, invMassA, invMassB, j, k11, k12, k22, kNormal, kTangent, manifold, newConstraints, radiusA, radiusB, restitution, rn1A, rn1B, rn2A, rn2B, rnA, rnB, rtA, rtB, shapeA, shapeB, vA, vB, vRel, wA, wB;
  this$static.m_constraintCount = contactCount;
  if (this$static.m_constraints.length <= contactCount) {
    newConstraints = initDim(_3Lorg_jbox2d_dynamics_contacts_ContactConstraint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ContactConstraint, this$static.m_constraintCount * 2, 0);
    for (i = 0; i < newConstraints.length; ++i) {
      i < this$static.m_constraints.length?(newConstraints[i] = this$static.m_constraints[i]):(newConstraints[i] = new ContactConstraint_0);
    }
    this$static.m_constraints = newConstraints;
  }
  for (i = 0; i < this$static.m_constraintCount; ++i) {
    contact = contacts[i];
    fixtureA = contact.m_fixtureA;
    fixtureB = contact.m_fixtureB;
    shapeA = fixtureA.m_shape;
    shapeB = fixtureB.m_shape;
    radiusA = shapeA.m_radius;
    radiusB = shapeB.m_radius;
    bodyA = fixtureA.m_body;
    bodyB = fixtureB.m_body;
    manifold = contact.m_manifold;
    friction = mixFriction(fixtureA.m_friction, fixtureB.m_friction);
    restitution = mixRestitution(fixtureA.m_restitution, fixtureB.m_restitution);
    vA = bodyA.m_linearVelocity;
    vB = bodyB.m_linearVelocity;
    wA = bodyA.m_angularVelocity;
    wB = bodyB.m_angularVelocity;
    $initialize_0(this$static.worldManifold, manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
    cc = this$static.m_constraints[i];
    cc.bodyA = bodyA;
    cc.bodyB = bodyB;
    cc.manifold = manifold;
    cc.normal.x = this$static.worldManifold.normal.x;
    cc.normal.y = this$static.worldManifold.normal.y;
    cc.pointCount = manifold.pointCount;
    cc.friction = friction;
    cc.localNormal.x = manifold.localNormal.x;
    cc.localNormal.y = manifold.localNormal.y;
    cc.localPoint.x = manifold.localPoint.x;
    cc.localPoint.y = manifold.localPoint.y;
    cc.radius = radiusA + radiusB;
    cc.type_0 = manifold.type_0;
    for (j = 0; j < cc.pointCount; ++j) {
      cp = manifold.points[j];
      ccp = cc.points[j];
      ccp.normalImpulse = impulseRatio * cp.normalImpulse;
      ccp.tangentImpulse = impulseRatio * cp.tangentImpulse;
      ccp.localPoint.x = cp.localPoint.x;
      ccp.localPoint.y = cp.localPoint.y;
      ccp.rA.x = this$static.worldManifold.points[j].x - bodyA.m_sweep.c.x;
      ccp.rA.y = this$static.worldManifold.points[j].y - bodyA.m_sweep.c.y;
      ccp.rB.x = this$static.worldManifold.points[j].x - bodyB.m_sweep.c.x;
      ccp.rB.y = this$static.worldManifold.points[j].y - bodyB.m_sweep.c.y;
      rnA = ccp.rA.x * cc.normal.y - ccp.rA.y * cc.normal.x;
      rnB = ccp.rB.x * cc.normal.y - ccp.rB.y * cc.normal.x;
      rnA *= rnA;
      rnB *= rnB;
      kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
      ccp.normalMass = 1 / kNormal;
      this$static.tangent.x = cc.normal.y;
      this$static.tangent.y = -cc.normal.x;
      rtA = ccp.rA.x * this$static.tangent.y - ccp.rA.y * this$static.tangent.x;
      rtB = ccp.rB.x * this$static.tangent.y - ccp.rB.y * this$static.tangent.x;
      rtA *= rtA;
      rtB *= rtB;
      kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
      ccp.tangentMass = 1 / kTangent;
      ccp.velocityBias = 0;
      this$static.temp2.x = -wA * ccp.rA.y;
      this$static.temp2.y = wA * ccp.rA.x;
      this$static.temp1.x = -wB * ccp.rB.y + vB.x - vA.x - this$static.temp2.x;
      this$static.temp1.y = wB * ccp.rB.x + vB.y - vA.y - this$static.temp2.y;
      a = cc.normal;
      vRel = a.x * this$static.temp1.x + a.y * this$static.temp1.y;
      vRel < -($clinit_Settings() , 1) && (ccp.velocityBias = -restitution * vRel);
    }
    if (cc.pointCount == 2) {
      ccp1 = cc.points[0];
      ccp2 = cc.points[1];
      invMassA = bodyA.m_invMass;
      invIA = bodyA.m_invI;
      invMassB = bodyB.m_invMass;
      invIB = bodyB.m_invI;
      rn1A = cross(ccp1.rA, cc.normal);
      rn1B = cross(ccp1.rB, cc.normal);
      rn2A = cross(ccp2.rA, cc.normal);
      rn2B = cross(ccp2.rB, cc.normal);
      k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
      k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
      k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
      if (k11 * k11 < 100 * (k11 * k22 - k12 * k12)) {
        cc.K.m11 = k11;
        cc.K.m12 = k12;
        cc.K.m21 = k12;
        cc.K.m22 = k22;
        cc.normalMass.m11 = cc.K.m11;
        cc.normalMass.m12 = cc.K.m12;
        cc.normalMass.m21 = cc.K.m21;
        cc.normalMass.m22 = cc.K.m22;
        $invertLocal(cc.normalMass);
      }
       else {
        cc.pointCount = 1;
      }
    }
  }
}

function $solvePositionConstraints(this$static, baumgarte){
  var C, K, bodyA, bodyB, c, i, impulse, invIA, invIB, invMassA, invMassB, j, minSeparation, normal, point, psm, rnA, rnB, separation;
  minSeparation = 0;
  for (i = 0; i < this$static.m_constraintCount; ++i) {
    c = this$static.m_constraints[i];
    bodyA = c.bodyA;
    bodyB = c.bodyB;
    invMassA = bodyA.m_mass * bodyA.m_invMass;
    invIA = bodyA.m_mass * bodyA.m_invI;
    invMassB = bodyB.m_mass * bodyB.m_invMass;
    invIB = bodyB.m_mass * bodyB.m_invI;
    for (j = 0; j < c.pointCount; ++j) {
      psm = this$static.psolver;
      $initialize_1(psm, c, j);
      normal = psm.normal;
      point = psm.point;
      separation = psm.separation;
      $subLocal($set_14(this$static.rA, point), bodyA.m_sweep.c);
      $subLocal($set_14(this$static.rB, point), bodyB.m_sweep.c);
      minSeparation = ($clinit_MathUtils() , minSeparation < separation?minSeparation:separation);
      C = clamp(baumgarte * (separation + ($clinit_Settings() , 0.004999999888241291)), -0.20000000298023224, 0);
      rnA = cross(this$static.rA, normal);
      rnB = cross(this$static.rB, normal);
      K = invMassA + invMassB + invIA * rnA * rnA + invIB * rnB * rnB;
      impulse = K > 0?-C / K:0;
      $mulLocal($set_14(this$static.P, normal), impulse);
      $mulLocal($set_14(this$static.temp1, this$static.P), invMassA);
      $subLocal(bodyA.m_sweep.c, this$static.temp1);
      bodyA.m_sweep.a_0 -= invIA * cross(this$static.rA, this$static.P);
      $synchronizeTransform(bodyA);
      $mulLocal($set_14(this$static.temp1, this$static.P), invMassB);
      $addLocal(bodyB.m_sweep.c, this$static.temp1);
      bodyB.m_sweep.a_0 += invIB * cross(this$static.rB, this$static.P);
      $synchronizeTransform(bodyB);
    }
  }
  return minSeparation >= -1.5 * ($clinit_Settings() , 0.004999999888241291);
}

function $solveVelocityConstraints(this$static){
  var Px, Py, a, a1, b, bodyA, bodyB, c, ccp, cp1, cp2, friction, i, invIA, invIB, invMassA, invMassB, j, lambda, maxFriction, newImpulse, vA, vB, vn, vn1, vn2, vt, wA, wB;
  for (i = 0; i < this$static.m_constraintCount; ++i) {
    c = this$static.m_constraints[i];
    bodyA = c.bodyA;
    bodyB = c.bodyB;
    wA = bodyA.m_angularVelocity;
    wB = bodyB.m_angularVelocity;
    vA = bodyA.m_linearVelocity;
    vB = bodyB.m_linearVelocity;
    invMassA = bodyA.m_invMass;
    invIA = bodyA.m_invI;
    invMassB = bodyB.m_invMass;
    invIB = bodyB.m_invI;
    this$static.tangent.x = c.normal.y;
    this$static.tangent.y = -c.normal.x;
    friction = c.friction;
    for (j = 0; j < c.pointCount; ++j) {
      ccp = c.points[j];
      a = ccp.rA;
      this$static.dv.x = -wB * ccp.rB.y + vB.x - vA.x + wA * a.y;
      this$static.dv.y = wB * ccp.rB.x + vB.y - vA.y - wA * a.x;
      vt = this$static.dv.x * this$static.tangent.x + this$static.dv.y * this$static.tangent.y;
      lambda = ccp.tangentMass * -vt;
      maxFriction = friction * ccp.normalImpulse;
      newImpulse = clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction);
      lambda = newImpulse - ccp.tangentImpulse;
      Px = this$static.tangent.x * lambda;
      Py = this$static.tangent.y * lambda;
      vA.x -= Px * invMassA;
      vA.y -= Py * invMassA;
      wA -= invIA * (ccp.rA.x * Py - ccp.rA.y * Px);
      vB.x += Px * invMassB;
      vB.y += Py * invMassB;
      wB += invIB * (ccp.rB.x * Py - ccp.rB.y * Px);
      ccp.tangentImpulse = newImpulse;
    }
    if (c.pointCount == 1) {
      ccp = c.points[0];
      a1 = ccp.rA;
      this$static.dv.x = -wB * ccp.rB.y + vB.x - vA.x + wA * a1.y;
      this$static.dv.y = wB * ccp.rB.x + vB.y - vA.y - wA * a1.x;
      b = c.normal;
      vn = this$static.dv.x * b.x + this$static.dv.y * b.y;
      lambda = -ccp.normalMass * (vn - ccp.velocityBias);
      a = ccp.normalImpulse + lambda;
      newImpulse = a > 0?a:0;
      lambda = newImpulse - ccp.normalImpulse;
      Px = c.normal.x * lambda;
      Py = c.normal.y * lambda;
      vA.x -= Px * invMassA;
      vA.y -= Py * invMassA;
      wA -= invIA * (ccp.rA.x * Py - ccp.rA.y * Px);
      vB.x += Px * invMassB;
      vB.y += Py * invMassB;
      wB += invIB * (ccp.rB.x * Py - ccp.rB.y * Px);
      ccp.normalImpulse = newImpulse;
    }
     else {
      cp1 = c.points[0];
      cp2 = c.points[1];
      this$static.a_0.x = cp1.normalImpulse;
      this$static.a_0.y = cp2.normalImpulse;
      this$static.dv1.x = -wB * cp1.rB.y + vB.x - vA.x + wA * cp1.rA.y;
      this$static.dv1.y = wB * cp1.rB.x + vB.y - vA.y - wA * cp1.rA.x;
      this$static.dv2.x = -wB * cp2.rB.y + vB.x - vA.x + wA * cp2.rA.y;
      this$static.dv2.y = wB * cp2.rB.x + vB.y - vA.y - wA * cp2.rA.x;
      vn1 = this$static.dv1.x * c.normal.x + this$static.dv1.y * c.normal.y;
      vn2 = this$static.dv2.x * c.normal.x + this$static.dv2.y * c.normal.y;
      this$static.b.x = vn1 - cp1.velocityBias;
      this$static.b.y = vn2 - cp2.velocityBias;
      this$static.temp2.x = c.K.m11 * this$static.a_0.x + c.K.m21 * this$static.a_0.y;
      this$static.temp2.y = c.K.m12 * this$static.a_0.x + c.K.m22 * this$static.a_0.y;
      this$static.b.x -= this$static.temp2.x;
      this$static.b.y -= this$static.temp2.y;
      for (;;) {
        mulToOut(c.normalMass, this$static.b, this$static.x);
        $mulLocal(this$static.x, -1);
        if (this$static.x.x >= 0 && this$static.x.y >= 0) {
          $subLocal($set_14(this$static.d, this$static.x), this$static.a_0);
          $mulLocal($set_14(this$static.P1, c.normal), this$static.d.x);
          $mulLocal($set_14(this$static.P2, c.normal), this$static.d.y);
          $addLocal($set_14(this$static.temp1, this$static.P1), this$static.P2);
          $mulLocal($set_14(this$static.temp2, this$static.temp1), invMassA);
          $subLocal(vA, this$static.temp2);
          $mulLocal($set_14(this$static.temp2, this$static.temp1), invMassB);
          $addLocal(vB, this$static.temp2);
          wA -= invIA * (cross(cp1.rA, this$static.P1) + cross(cp2.rA, this$static.P2));
          wB += invIB * (cross(cp1.rB, this$static.P1) + cross(cp2.rB, this$static.P2));
          cp1.normalImpulse = this$static.x.x;
          cp2.normalImpulse = this$static.x.y;
          break;
        }
        this$static.x.x = -cp1.normalMass * this$static.b.x;
        this$static.x.y = 0;
        vn2 = c.K.m12 * this$static.x.x + this$static.b.y;
        if (this$static.x.x >= 0 && vn2 >= 0) {
          $subLocal($set_14(this$static.d, this$static.x), this$static.a_0);
          $mulLocal($set_14(this$static.P1, c.normal), this$static.d.x);
          $mulLocal($set_14(this$static.P2, c.normal), this$static.d.y);
          $addLocal($set_14(this$static.temp1, this$static.P1), this$static.P2);
          $mulLocal($set_14(this$static.temp2, this$static.temp1), invMassA);
          $subLocal(vA, this$static.temp2);
          $mulLocal($set_14(this$static.temp2, this$static.temp1), invMassB);
          $addLocal(vB, this$static.temp2);
          wA -= invIA * (cross(cp1.rA, this$static.P1) + cross(cp2.rA, this$static.P2));
          wB += invIB * (cross(cp1.rB, this$static.P1) + cross(cp2.rB, this$static.P2));
          cp1.normalImpulse = this$static.x.x;
          cp2.normalImpulse = this$static.x.y;
          break;
        }
        this$static.x.x = 0;
        this$static.x.y = -cp2.normalMass * this$static.b.y;
        vn1 = c.K.m21 * this$static.x.y + this$static.b.x;
        if (this$static.x.y >= 0 && vn1 >= 0) {
          $subLocal($set_14(this$static.d, this$static.x), this$static.a_0);
          $mulLocal($set_14(this$static.P1, c.normal), this$static.d.x);
          $mulLocal($set_14(this$static.P2, c.normal), this$static.d.y);
          $addLocal($set_14(this$static.temp1, this$static.P1), this$static.P2);
          $mulLocal($set_14(this$static.temp2, this$static.temp1), invMassA);
          $subLocal(vA, this$static.temp2);
          $mulLocal($set_14(this$static.temp2, this$static.temp1), invMassB);
          $addLocal(vB, this$static.temp2);
          wA -= invIA * (cross(cp1.rA, this$static.P1) + cross(cp2.rA, this$static.P2));
          wB += invIB * (cross(cp1.rB, this$static.P1) + cross(cp2.rB, this$static.P2));
          cp1.normalImpulse = this$static.x.x;
          cp2.normalImpulse = this$static.x.y;
          break;
        }
        this$static.x.x = 0;
        this$static.x.y = 0;
        vn1 = this$static.b.x;
        vn2 = this$static.b.y;
        if (vn1 >= 0 && vn2 >= 0) {
          $subLocal($set_14(this$static.d, this$static.x), this$static.a_0);
          $mulLocal($set_14(this$static.P1, c.normal), this$static.d.x);
          $mulLocal($set_14(this$static.P2, c.normal), this$static.d.y);
          $addLocal($set_14(this$static.temp1, this$static.P1), this$static.P2);
          $mulLocal($set_14(this$static.temp2, this$static.temp1), invMassA);
          $subLocal(vA, this$static.temp2);
          $mulLocal($set_14(this$static.temp2, this$static.temp1), invMassB);
          $addLocal(vB, this$static.temp2);
          wA -= invIA * (cross(cp1.rA, this$static.P1) + cross(cp2.rA, this$static.P2));
          wB += invIB * (cross(cp1.rB, this$static.P1) + cross(cp2.rB, this$static.P2));
          cp1.normalImpulse = this$static.x.x;
          cp2.normalImpulse = this$static.x.y;
          break;
        }
        break;
      }
    }
    $set_14(bodyA.m_linearVelocity, vA);
    bodyA.m_angularVelocity = wA;
    $set_14(bodyB.m_linearVelocity, vB);
    bodyB.m_angularVelocity = wB;
  }
}

function $storeImpulses(this$static){
  var c, i, j, m_0;
  for (i = 0; i < this$static.m_constraintCount; ++i) {
    c = this$static.m_constraints[i];
    m_0 = c.manifold;
    for (j = 0; j < c.pointCount; ++j) {
      m_0.points[j].normalImpulse = c.points[j].normalImpulse;
      m_0.points[j].tangentImpulse = c.points[j].tangentImpulse;
    }
  }
}

function $warmStart(this$static){
  var Px, Py, bodyA, bodyB, c, ccp, i, invIA, invIB, invMassA, invMassB, j, normal;
  for (i = 0; i < this$static.m_constraintCount; ++i) {
    c = this$static.m_constraints[i];
    bodyA = c.bodyA;
    bodyB = c.bodyB;
    invMassA = bodyA.m_invMass;
    invIA = bodyA.m_invI;
    invMassB = bodyB.m_invMass;
    invIB = bodyB.m_invI;
    normal = c.normal;
    crossToOut_0(normal, 1, this$static.tangent);
    for (j = 0; j < c.pointCount; ++j) {
      ccp = c.points[j];
      Px = ccp.normalImpulse * normal.x + ccp.tangentImpulse * this$static.tangent.x;
      Py = ccp.normalImpulse * normal.y + ccp.tangentImpulse * this$static.tangent.y;
      bodyA.m_angularVelocity -= invIA * (ccp.rA.x * Py - ccp.rA.y * Px);
      bodyA.m_linearVelocity.x -= Px * invMassA;
      bodyA.m_linearVelocity.y -= Py * invMassA;
      bodyB.m_angularVelocity += invIB * (ccp.rB.x * Py - ccp.rB.y * Px);
      bodyB.m_linearVelocity.x += Px * invMassB;
      bodyB.m_linearVelocity.y += Py * invMassB;
    }
  }
}

function ContactSolver_0(){
  var i;
  this.worldManifold = new WorldManifold_0;
  this.tangent = new Vec2_0;
  this.temp1 = new Vec2_0;
  this.temp2 = new Vec2_0;
  this.P = new Vec2_0;
  this.dv = new Vec2_0;
  this.a_0 = new Vec2_0;
  this.b = new Vec2_0;
  this.dv1 = new Vec2_0;
  this.dv2 = new Vec2_0;
  this.x = new Vec2_0;
  this.d = new Vec2_0;
  this.P1 = new Vec2_0;
  this.P2 = new Vec2_0;
  this.psolver = new PositionSolverManifold_0;
  this.rA = new Vec2_0;
  this.rB = new Vec2_0;
  this.m_constraints = initDim(_3Lorg_jbox2d_dynamics_contacts_ContactConstraint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ContactConstraint, 256, 0);
  for (i = 0; i < this.m_constraints.length; ++i) {
    this.m_constraints[i] = new ContactConstraint_0;
  }
}

defineSeed(321, 1, {}, ContactSolver_0);
_.m_constraintCount = 0;
_.m_constraints = null;
function PolygonAndCircleContact_0(argPool){
  $clinit_Contact();
  Contact_0.call(this, argPool);
}

defineSeed(322, 316, makeCastMap([Q$Contact, Q$PolygonAndCircleContact]), PolygonAndCircleContact_0);
_.evaluate = function evaluate_0(manifold, xfA, xfB){
  $collidePolygonAndCircle(this.pool.collision, this.m_manifold, (this.m_fixtureA.m_shape , xfA), this.m_fixtureB.m_shape, xfB);
}
;
_.init = function init_2(fixtureA, fixtureB){
  $init_0(this, fixtureA, fixtureB);
}
;
function PolygonContact_0(argPool){
  $clinit_Contact();
  Contact_0.call(this, argPool);
}

defineSeed(323, 316, makeCastMap([Q$Contact, Q$PolygonContact]), PolygonContact_0);
_.evaluate = function evaluate_1(manifold, xfA, xfB){
  $collidePolygons(this.pool.collision, this.m_manifold, (this.m_fixtureA.m_shape , xfA), (this.m_fixtureB.m_shape , xfB));
}
;
_.init = function init_3(fixtureA, fixtureB){
  $init_0(this, fixtureA, fixtureB);
}
;
function $initialize_1(this$static, cc, index){
  switch (cc.type_0.ordinal) {
    case 0:
      {
        $getWorldPointToOut(cc.bodyA, cc.localPoint, this$static.pointA);
        $getWorldPointToOut(cc.bodyB, cc.points[0].localPoint, this$static.pointB);
        if (distanceSquared(this$static.pointA, this$static.pointB) > 1.4210854715202004E-14) {
          $subLocal($set_14(this$static.normal, this$static.pointB), this$static.pointA);
          $normalize_0(this$static.normal);
        }
         else {
          $set_13(this$static.normal, 1, 0);
        }
        $mulLocal($addLocal($set_14(this$static.point, this$static.pointA), this$static.pointB), 0.5);
        $subLocal($set_14(this$static.temp, this$static.pointB), this$static.pointA);
        this$static.separation = dot_0(this$static.temp, this$static.normal) - cc.radius;
        break;
      }

    case 1:
      {
        $getWorldVectorToOut(cc.bodyA, cc.localNormal, this$static.normal);
        $getWorldPointToOut(cc.bodyA, cc.localPoint, this$static.planePoint);
        $getWorldPointToOut(cc.bodyB, cc.points[index].localPoint, this$static.clipPoint);
        $subLocal($set_14(this$static.temp, this$static.clipPoint), this$static.planePoint);
        this$static.separation = dot_0(this$static.temp, this$static.normal) - cc.radius;
        $set_14(this$static.point, this$static.clipPoint);
        break;
      }

    case 2:
      {
        $getWorldVectorToOut(cc.bodyB, cc.localNormal, this$static.normal);
        $getWorldPointToOut(cc.bodyB, cc.localPoint, this$static.planePoint);
        $getWorldPointToOut(cc.bodyA, cc.points[index].localPoint, this$static.clipPoint);
        $subLocal($set_14(this$static.temp, this$static.clipPoint), this$static.planePoint);
        this$static.separation = dot_0(this$static.temp, this$static.normal) - cc.radius;
        $set_14(this$static.point, this$static.clipPoint);
        $negateLocal(this$static.normal);
      }

  }
}

function PositionSolverManifold_0(){
  this.normal = new Vec2_0;
  this.point = new Vec2_0;
  this.pointA = new Vec2_0;
  this.pointB = new Vec2_0;
  this.temp = new Vec2_0;
  this.planePoint = new Vec2_0;
  this.clipPoint = new Vec2_0;
}

defineSeed(324, 1, {}, PositionSolverManifold_0);
_.separation = 0;
function TOIConstraint_0(){
  var i;
  this.localPoints = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, ($clinit_Settings() , 2), 0);
  this.localNormal = new Vec2_0;
  this.localPoint = new Vec2_0;
  for (i = 0; i < this.localPoints.length; ++i) {
    this.localPoints[i] = new Vec2_0;
  }
}

defineSeed(325, 1, makeCastMap([Q$TOIConstraint]), TOIConstraint_0);
_.bodyA = null;
_.bodyB = null;
_.pointCount = 0;
_.radius = 0;
_.type_0 = null;
function $initialize_2(this$static, contacts, count, toiBody){
  var bodyA, bodyB, constraint, contact, cp, fixtureA, fixtureB, i, j, manifold, old, radiusA, radiusB, shapeA, shapeB;
  this$static.m_count = count;
  this$static.m_toiBody = toiBody;
  if (this$static.m_count >= this$static.m_constraints.length) {
    old = this$static.m_constraints;
    this$static.m_constraints = initDim(_3Lorg_jbox2d_dynamics_contacts_TOIConstraint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$TOIConstraint, old.length * 2, 0);
    arraycopy(old, 0, this$static.m_constraints, 0, old.length);
    for (i = old.length; i < this$static.m_constraints.length; ++i) {
      this$static.m_constraints[i] = new TOIConstraint_0;
    }
  }
  for (i = 0; i < this$static.m_count; ++i) {
    contact = contacts[i];
    fixtureA = contact.m_fixtureA;
    fixtureB = contact.m_fixtureB;
    shapeA = fixtureA.m_shape;
    shapeB = fixtureB.m_shape;
    radiusA = shapeA.m_radius;
    radiusB = shapeB.m_radius;
    bodyA = fixtureA.m_body;
    bodyB = fixtureB.m_body;
    manifold = contact.m_manifold;
    constraint = this$static.m_constraints[i];
    constraint.bodyA = bodyA;
    constraint.bodyB = bodyB;
    $set_14(constraint.localNormal, manifold.localNormal);
    $set_14(constraint.localPoint, manifold.localPoint);
    constraint.type_0 = manifold.type_0;
    constraint.pointCount = manifold.pointCount;
    constraint.radius = radiusA + radiusB;
    for (j = 0; j < constraint.pointCount; ++j) {
      cp = manifold.points[j];
      constraint.localPoints[j] = cp.localPoint;
    }
  }
}

function $solve_1(this$static){
  var C, K, bodyA, bodyB, c, i, impulse, invIA, invIB, invMassA, invMassB, j, massA, massB, minSeparation, normal, point, rnA, rnB, separation;
  minSeparation = 0;
  for (i = 0; i < this$static.m_count; ++i) {
    c = this$static.m_constraints[i];
    bodyA = c.bodyA;
    bodyB = c.bodyB;
    massA = bodyA.m_mass;
    massB = bodyB.m_mass;
    bodyA == this$static.m_toiBody?(massB = 0):(massA = 0);
    invMassA = massA * bodyA.m_invMass;
    invIA = massA * bodyA.m_invI;
    invMassB = massB * bodyB.m_invMass;
    invIB = massB * bodyB.m_invI;
    for (j = 0; j < c.pointCount; ++j) {
      $initialize_3(this$static.psm, c, j);
      normal = this$static.psm.normal;
      point = this$static.psm.point;
      separation = this$static.psm.separation;
      $subLocal($set_14(this$static.rA, point), bodyA.m_sweep.c);
      $subLocal($set_14(this$static.rB, point), bodyB.m_sweep.c);
      minSeparation = ($clinit_MathUtils() , minSeparation < separation?minSeparation:separation);
      C = clamp(0.75 * (separation + ($clinit_Settings() , 0.004999999888241291)), -0.20000000298023224, 0);
      rnA = cross(this$static.rA, normal);
      rnB = cross(this$static.rB, normal);
      K = invMassA + invMassB + invIA * rnA * rnA + invIB * rnB * rnB;
      impulse = K > 0?-C / K:0;
      $mulLocal($set_14(this$static.P, normal), impulse);
      $mulLocal($set_14(this$static.temp, this$static.P), invMassA);
      $subLocal(bodyA.m_sweep.c, this$static.temp);
      bodyA.m_sweep.a_0 -= invIA * cross(this$static.rA, this$static.P);
      $synchronizeTransform(bodyA);
      $mulLocal($set_14(this$static.temp, this$static.P), invMassB);
      $addLocal(bodyB.m_sweep.c, this$static.temp);
      bodyB.m_sweep.a_0 += invIB * cross(this$static.rB, this$static.P);
      $synchronizeTransform(bodyB);
    }
  }
  return minSeparation >= -1.5 * ($clinit_Settings() , 0.004999999888241291);
}

function TOISolver_0(){
  var i;
  this.m_constraints = initDim(_3Lorg_jbox2d_dynamics_contacts_TOIConstraint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$TOIConstraint, 4, 0);
  this.psm = new TOISolverManifold_0;
  this.rA = new Vec2_0;
  this.rB = new Vec2_0;
  this.P = new Vec2_0;
  this.temp = new Vec2_0;
  this.m_count = 0;
  this.m_toiBody = null;
  for (i = 0; i < this.m_constraints.length; ++i) {
    this.m_constraints[i] = new TOIConstraint_0;
  }
}

defineSeed(326, 1, {}, TOISolver_0);
_.m_count = 0;
_.m_toiBody = null;
function $initialize_3(this$static, cc, index){
  switch (cc.type_0.ordinal) {
    case 0:
      {
        $getWorldPointToOut(cc.bodyA, cc.localPoint, this$static.pointA);
        $getWorldPointToOut(cc.bodyB, cc.localPoints[0], this$static.pointB);
        if (distanceSquared(this$static.pointA, this$static.pointB) > 1.4210854715202004E-14) {
          $subLocal($set_14(this$static.normal, this$static.pointB), this$static.pointA);
          $normalize_0(this$static.normal);
        }
         else {
          $set_13(this$static.normal, 1, 0);
        }
        $mulLocal($addLocal($set_14(this$static.point, this$static.pointA), this$static.pointB), 0.5);
        $subLocal($set_14(this$static.temp, this$static.pointB), this$static.pointA);
        this$static.separation = dot_0(this$static.temp, this$static.normal) - cc.radius;
        break;
      }

    case 1:
      {
        $getWorldVectorToOut(cc.bodyA, cc.localNormal, this$static.normal);
        $getWorldPointToOut(cc.bodyA, cc.localPoint, this$static.planePoint);
        $getWorldPointToOut(cc.bodyB, cc.localPoints[index], this$static.clipPoint);
        $subLocal($set_14(this$static.temp, this$static.clipPoint), this$static.planePoint);
        this$static.separation = dot_0(this$static.temp, this$static.normal) - cc.radius;
        $set_14(this$static.point, this$static.clipPoint);
        break;
      }

    case 2:
      {
        $getWorldVectorToOut(cc.bodyB, cc.localNormal, this$static.normal);
        $getWorldPointToOut(cc.bodyB, cc.localPoint, this$static.planePoint);
        $getWorldPointToOut(cc.bodyA, cc.localPoints[index], this$static.clipPoint);
        $subLocal($set_14(this$static.temp, this$static.clipPoint), this$static.planePoint);
        this$static.separation = dot_0(this$static.temp, this$static.normal) - cc.radius;
        $set_14(this$static.point, this$static.clipPoint);
        $negateLocal(this$static.normal);
      }

  }
}

function TOISolverManifold_0(){
  this.normal = new Vec2_0;
  this.point = new Vec2_0;
  this.pointA = new Vec2_0;
  this.pointB = new Vec2_0;
  this.temp = new Vec2_0;
  this.planePoint = new Vec2_0;
  this.clipPoint = new Vec2_0;
}

defineSeed(327, 1, {}, TOISolverManifold_0);
_.separation = 0;
function $initStack(this$static){
  this$static.index_0 = 9;
  this$static.size = 10;
  this$static.stack_0 = this$static.createArray(10, null);
}

function $pop_0(this$static){
  if (this$static.index_0 >= this$static.size) {
    this$static.stack_0 = this$static.createArray(this$static.size * 2, this$static.stack_0);
    this$static.size = this$static.stack_0.length;
  }
  return this$static.stack_0[this$static.index_0++];
}

function MutableStack_0(){
  this.index_0 = 0;
  this.size = 0;
}

defineSeed(329, 1, {});
_.index_0 = 0;
_.size = 0;
_.stack_0 = null;
function $createArray(this$static, argSize, argOld){
  var i, sk;
  if (argOld != null) {
    sk = initDim(_3Lorg_jbox2d_dynamics_contacts_CircleContact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$CircleContact, argSize, 0);
    for (i = 0; i < argOld.length; ++i) {
      sk[i] = argOld[i];
    }
    for (i = argOld.length; i < argSize; ++i) {
      sk[i] = new CircleContact_0(this$static.pool);
    }
    return sk;
  }
   else {
    sk = initDim(_3Lorg_jbox2d_dynamics_contacts_CircleContact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$CircleContact, argSize, 0);
    for (i = 0; i < argSize; ++i) {
      sk[i] = new CircleContact_0(this$static.pool);
    }
    return sk;
  }
}

function CircleContactStack_0(argPool){
  MutableStack_0.call(this);
  this.pool = argPool;
  $initStack(this);
}

defineSeed(328, 329, {}, CircleContactStack_0);
_.createArray = function createArray(argSize, argOld){
  return $createArray(this, argSize, argOld);
}
;
_.pool = null;
function $pop_1(this$static){
  return this$static.pool[this$static.index_0++];
}

function OrderedStack_0(){
  this.index_0 = 0;
}

defineSeed(330, 1, {});
_.container = null;
_.index_0 = 0;
_.pool = null;
function OrderedStackAABB_0(){
  var i;
  OrderedStack_0.call(this);
  this.pool = initDim(_3Lorg_jbox2d_collision_AABB_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$AABB, 100, 0);
  for (i = 0; i < 100; ++i) {
    this.pool[i] = new AABB_0;
  }
  this.container = initDim(_3Lorg_jbox2d_collision_AABB_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$AABB, 10, 0);
  for (i = 0; i < 10; ++i) {
    this.container[i] = new AABB_0;
  }
}

defineSeed(331, 330, {}, OrderedStackAABB_0);
function OrderedStackMat22_0(){
  var i;
  OrderedStack_0.call(this);
  this.pool = initDim(_3Lorg_jbox2d_common_Mat22_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Mat22, 100, 0);
  for (i = 0; i < 100; ++i) {
    this.pool[i] = new Mat22_0;
  }
  this.container = initDim(_3Lorg_jbox2d_common_Mat22_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Mat22, 10, 0);
  for (i = 0; i < 10; ++i) {
    this.container[i] = new Mat22_0;
  }
}

defineSeed(332, 330, {}, OrderedStackMat22_0);
--></script>
<script><!--
function OrderedStackVec2_0(argStackSize){
  var i;
  OrderedStack_0.call(this);
  this.pool = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, argStackSize, 0);
  for (i = 0; i < argStackSize; ++i) {
    this.pool[i] = new Vec2_0;
  }
  this.container = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 10, 0);
  for (i = 0; i < 10; ++i) {
    this.container[i] = new Vec2_0;
  }
}

defineSeed(333, 330, {}, OrderedStackVec2_0);
function OrderedStackVec3_0(){
  var i;
  OrderedStack_0.call(this);
  this.pool = initDim(_3Lorg_jbox2d_common_Vec3_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec3, 100, 0);
  for (i = 0; i < 100; ++i) {
    this.pool[i] = new Vec3_0;
  }
  this.container = initDim(_3Lorg_jbox2d_common_Vec3_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec3, 10, 0);
  for (i = 0; i < 10; ++i) {
    this.container[i] = new Vec3_0;
  }
}

defineSeed(334, 330, {}, OrderedStackVec3_0);
function $createArray_0(this$static, argSize, argOld){
  var i, sk;
  if (argOld != null) {
    sk = initDim(_3Lorg_jbox2d_dynamics_contacts_PolygonAndCircleContact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$PolygonAndCircleContact, argSize, 0);
    for (i = 0; i < argOld.length; ++i) {
      sk[i] = argOld[i];
    }
    for (i = argOld.length; i < argSize; ++i) {
      sk[i] = new PolygonAndCircleContact_0(this$static.pool);
    }
    return sk;
  }
   else {
    sk = initDim(_3Lorg_jbox2d_dynamics_contacts_PolygonAndCircleContact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$PolygonAndCircleContact, argSize, 0);
    for (i = 0; i < argSize; ++i) {
      sk[i] = new PolygonAndCircleContact_0(this$static.pool);
    }
    return sk;
  }
}

function PolygonAndCircleContactStack_0(argPool){
  MutableStack_0.call(this);
  this.pool = argPool;
  $initStack(this);
}

defineSeed(335, 329, {}, PolygonAndCircleContactStack_0);
_.createArray = function createArray_0(argSize, argOld){
  return $createArray_0(this, argSize, argOld);
}
;
_.pool = null;
function $createArray_1(this$static, argSize, argOld){
  var i, sk;
  if (argOld != null) {
    sk = initDim(_3Lorg_jbox2d_dynamics_contacts_PolygonContact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$PolygonContact, argSize, 0);
    for (i = 0; i < argOld.length; ++i) {
      sk[i] = argOld[i];
    }
    for (i = argOld.length; i < argSize; ++i) {
      sk[i] = new PolygonContact_0(this$static.pool);
    }
    return sk;
  }
   else {
    sk = initDim(_3Lorg_jbox2d_dynamics_contacts_PolygonContact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$PolygonContact, argSize, 0);
    for (i = 0; i < argSize; ++i) {
      sk[i] = new PolygonContact_0(this$static.pool);
    }
    return sk;
  }
}

function PolygonContactStack_0(argPool){
  MutableStack_0.call(this);
  this.pool = argPool;
  $initStack(this);
}

defineSeed(336, 329, {}, PolygonContactStack_0);
_.createArray = function createArray_1(argSize, argOld){
  return $createArray_1(this, argSize, argOld);
}
;
_.pool = null;
function TLManifold_0(){
}

defineSeed(337, 227, {}, TLManifold_0);
_.initialValue = function initialValue_0(){
  return new Manifold_0;
}
;
function WorldPool_0(){
  new HashMap_0;
  new HashMap_0;
  new HashMap_0;
  this.pcstack = new PolygonContactStack_0(this);
  this.ccstack = new CircleContactStack_0(this);
  this.cpstack = new PolygonAndCircleContactStack_0(this);
  this.vecs = new OrderedStackVec2_0(100);
  new OrderedStackVec3_0;
  new OrderedStackMat22_0;
  new OrderedStackAABB_0;
  this.dist = new Distance_0;
  this.collision = new Collision_0(this);
  this.toi = new TimeOfImpact_0(this);
}

defineSeed(338, 1, {}, WorldPool_0);
_.collision = null;
_.dist = null;
_.toi = null;
_.vecs = null;
function $get_7(this$static, argLength){
  var map;
  map = $get_1(this$static.tlMap);
  $containsKey_0(map, valueOf(argLength)) || $put_2(map, valueOf(argLength), $getInitializedArray(argLength));
  return $get_6(map, valueOf(argLength));
}

defineSeed(339, 1, {});
function DynamicTLArray$TLHashMap_0(){
}

defineSeed(340, 227, {}, DynamicTLArray$TLHashMap_0);
_.initialValue = function initialValue_1(){
  return new HashMap_0;
}
;
function $getInitializedArray(argLength){
  var i, ray;
  ray = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, argLength, 0);
  for (i = 0; i < ray.length; ++i) {
    ray[i] = new Vec2_0;
  }
  return ray;
}

function Vec2Array_0(){
  this.tlMap = new DynamicTLArray$TLHashMap_0;
}

defineSeed(341, 339, {}, Vec2Array_0);
defineSeed(342, 1, {});
function $interact(){
  return;
}

function $isSet(this$static, flag){
  return (this$static.flags & flag.bitmask) != 0;
}

function $onAdd(this$static){
  if ($isSet(this$static, ($clinit_AbstractLayer$Flag() , DESTROYED)))
    throw new IllegalStateException_1('Illegal to use destroyed layer: ' + this$static);
}

function $setFlag(this$static, flag, active){
  active?(this$static.flags |= flag.bitmask):(this$static.flags &= ~flag.bitmask);
}

function $setScale(this$static, sx, sy){
  initValues(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Object, [new Float_0(sx), new Float_0(sy)]);
  if (sx != this$static.scaleX || sy != this$static.scaleY) {
    this$static.scaleX = sx;
    this$static.scaleY = sy;
    $setFlag(this$static, ($clinit_AbstractLayer$Flag() , XFDIRTY), true);
  }
  return this$static;
}

function $transform_0(this$static){
  var cosa, m00, m01, m10, m11, sina, tx, ty;
  if ($isSet(this$static, ($clinit_AbstractLayer$Flag() , XFDIRTY))) {
    sina = Math.sin(0);
    cosa = Math.cos(0);
    m00 = cosa * this$static.scaleX;
    m01 = sina * this$static.scaleY;
    m10 = -sina * this$static.scaleX;
    m11 = cosa * this$static.scaleY;
    tx = this$static.transform_0.tx_0();
    ty = this$static.transform_0.ty_0();
    this$static.transform_0.setTransform(m00, m01, m10, m11, tx, ty);
    $setFlag(this$static, XFDIRTY, false);
  }
  return this$static.transform_0;
}

function AbstractLayer_0(transform){
  this.transform_0 = transform;
  $setFlag(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1), true);
}

defineSeed(343, 1, {});
_.height_1 = function height_0(){
  return 0;
}
;
_.hitTest = function hitTest(p){
  return this.hitTestDefault(p);
}
;
_.hitTestDefault = function hitTestDefault(p){
  return p.x >= 0 && p.y >= 0 && p.x < this.width_1() && p.y < this.height_1()?this:null;
}
;
_.interactive = function interactive_0(){
  return $isSet(this, ($clinit_AbstractLayer$Flag() , INTERACTIVE));
}
;
_.onAdd = function onAdd(){
  $onAdd(this);
}
;
_.onRemove = function onRemove(){
}
;
_.originX_0 = function originX_0(){
  return this.originX;
}
;
_.originY_0 = function originY_0(){
  return this.originY;
}
;
_.parent_1 = function parent_1(){
  return this.parent_0;
}
;
_.setInteractive = function setInteractive(interactive){
  if ($isSet(this, ($clinit_AbstractLayer$Flag() , INTERACTIVE)) != interactive) {
    interactive && !!this.parent_0 && this.parent_0.setInteractive(true);
    $setFlag(this, INTERACTIVE, interactive);
  }
  return this;
}
;
_.setScale = function setScale(s){
  return $setScale(this, s, s);
}
;
_.toString$ = function toString_32(){
  var bldr, cname;
  cname = this.___clazz$.typeName;
  bldr = new StringBuilder_1($substring(cname, cname.lastIndexOf('.') + 1));
  $append_9((bldr.impl.string += ' [hashCode=' , bldr), getHashCode(this));
  $append_10((bldr.impl.string += ', tx=' , bldr), $transform_0(this));
  return bldr.impl.string;
}
;
_.transform_1 = function transform_0(){
  return $transform_0(this);
}
;
_.width_1 = function width_0(){
  return 0;
}
;
_.depth = 0;
_.flags = 0;
_.originX = 0;
_.originY = 0;
_.parent_0 = null;
_.scaleX = 1;
_.scaleY = 1;
_.transform_0 = null;
function $clinit_AbstractLayer$Flag(){
  $clinit_AbstractLayer$Flag = nullMethod;
  DESTROYED = new AbstractLayer$Flag_0('DESTROYED', 0, 1);
  VISIBLE_1 = new AbstractLayer$Flag_0('VISIBLE', 1, 2);
  INTERACTIVE = new AbstractLayer$Flag_0('INTERACTIVE', 2, 4);
  SHOWN = new AbstractLayer$Flag_0('SHOWN', 3, 8);
  XFDIRTY = new AbstractLayer$Flag_0('XFDIRTY', 4, 16);
  $VALUES_12 = initValues(_3Lplayn_core_AbstractLayer$Flag_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$AbstractLayer$Flag, [DESTROYED, VISIBLE_1, INTERACTIVE, SHOWN, XFDIRTY]);
}

function AbstractLayer$Flag_0(enum$name, enum$ordinal, bitmask){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.bitmask = bitmask;
}

function values_12(){
  $clinit_AbstractLayer$Flag();
  return $VALUES_12;
}

defineSeed(344, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$AbstractLayer$Flag]), AbstractLayer$Flag_0);
_.bitmask = 0;
var $VALUES_12, DESTROYED, INTERACTIVE, SHOWN, VISIBLE_1, XFDIRTY;
function AbstractPlatform_0(log){
  this.log_0 = log;
  this.runQueue = new RunQueue_0;
}

defineSeed(345, 1, {});
_.log_0 = null;
_.runQueue = null;
function $addCallback(this$static, callback){
  this$static.impl?++callback.this$0.successCount:this$static.error?$onFailure(callback):(this$static.callbacks = createAdd(this$static.callbacks, callback));
}

function $onLoadError(this$static, error){
  this$static.error = error;
  this$static.callbacks = dispatchFailureClear(this$static.callbacks, error);
}

function $onLoaded(this$static, impl){
  this$static.impl = impl;
  this$static.callbacks = dispatchSuccessClear(this$static.callbacks, this$static);
  this$static.impl.setVolume_0(100);
  $setLoopingImpl(this$static, this$static.looping);
  this$static.playing && this$static.impl.play_0();
}

defineSeed(346, 1, {});
_.callbacks = null;
_.error = null;
_.impl = null;
_.looping = false;
_.playing = false;
function $getImage(this$static, path){
  var object;
  if ((object = $get_6(this$static.cache, path)) == null) {
    object = $getImage_1(this$static.delegate, path, ($clinit_Scale() , ONE));
    $put_2(this$static.cache, path, object);
  }
  return object;
}

function $getSound(this$static, path){
  var object;
  if ((object = $get_6(this$static.cache, path)) == null) {
    object = $getSound_1(this$static.delegate, path);
    $put_2(this$static.cache, path, object);
  }
  return object;
}

function CachingAssets_0(delegate){
  this.cache = new HashMap_0;
  this.delegate = delegate;
}

defineSeed(347, 1, {}, CachingAssets_0);
_.delegate = null;
function CanvasSurface_0(canvas){
  this.canvas = canvas;
}

defineSeed(348, 1, {}, CanvasSurface_0);
_.clear_0 = function clear(){
  $clear_3(this.canvas);
  return this;
}
;
_.drawLine = function drawLine(x0, y0, x1, y1, width){
  this.canvas.ctx.save();
  $setStrokeWidth(this.canvas, width);
  $drawLine(this.canvas, x0, y0, x1, y1);
  this.canvas.ctx.restore();
  return this;
}
;
_.fillTriangles = function fillTriangles(xys, indices){
  var a, b, c, ii, path;
  path = new HtmlPath_0;
  for (ii = 0; ii < indices.length; ii += 3) {
    a = 2 * indices[ii];
    b = 2 * indices[ii + 1];
    c = 2 * indices[ii + 2];
    $push_1(path.list, 0);
    $push_1(path.list, xys[a]);
    $push_1(path.list, xys[a + 1]);
    $lineTo_0(path, xys[b], xys[b + 1]);
    $lineTo_0(path, xys[c], xys[c + 1]);
    $push_1(path.list, 4);
  }
  $fillPath(this.canvas, path);
  return this;
}
;
_.restore_0 = function restore_0(){
  this.canvas.ctx.restore();
  return this;
}
;
_.save_0 = function save(){
  this.canvas.ctx.save();
  return this;
}
;
_.scale_1 = function scale_0(sx, sy){
  $scale_3(this.canvas, sx, sy);
  return this;
}
;
_.setFillColor = function setFillColor(color){
  $setFillColor(this.canvas, color);
  $setStrokeColor(this.canvas, color);
  return this;
}
;
_.transform_2 = function transform_1(m11, m12, m21, m22, dx, dy){
  $transform_3(this.canvas, m11, m12, m21, m22, dx, dy);
  return this;
}
;
_.translate_0 = function translate(x, y){
  $translate_1(this.canvas, x, y);
  return this;
}
;
_.canvas = null;
function $dispatch(layer, event_0, interaction){
  var $e0, localized, t;
  localized = event_0.localize(layer);
  try {
    $interact(layer);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      t = $e0;
      $warn_0(platform_1.log_0, 'Interaction failure [layer=' + layer + ', iact=' + interaction + ', event=' + localized + ']', t);
    }
     else 
      throw $e0;
  }
}

function $clinit_Events(){
  $clinit_Events = nullMethod;
  scratchPoint = new Point_0;
}

var scratchPoint;
function $setPreventDefault(this$static, preventDefault){
  this$static.preventDefault_0 = preventDefault;
}

function Events$Flags$Impl_0(){
}

defineSeed(351, 1, {}, Events$Flags$Impl_0);
_.toString$ = function toString_33(){
  return this.preventDefault_0?'preventDefault':'normal';
}
;
_.preventDefault_0 = false;
function Events$Input$Impl_0(flags, time){
  this.flags = flags;
  this.time = time;
}

defineSeed(352, 1, makeCastMap([Q$Events$Input, Q$Events$Input$Impl]));
_.addFields = function addFields(builder){
  $append_10($append_11($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
}
;
_.name_1 = function name_1(){
  return 'Events.Input';
}
;
_.toString$ = function toString_34(){
  var builder;
  builder = $append_6(new StringBuilder_1(this.name_1()), 91);
  this.addFields(builder);
  return (builder.impl.string += ']' , builder).impl.string;
}
;
_.flags = null;
_.time = 0;
function Events$Position$Impl_0(hit, flags, time, x, y){
  Events$Input$Impl_0.call(this, flags, time);
  this.hit = hit;
  this.x = x;
  this.y = y;
  if (!hit)
  ;
  else {
    screenToLayer(hit, $set_17(($clinit_Events() , scratchPoint), x, y), scratchPoint);
  }
}

defineSeed(353, 352, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]));
_.addFields = function addFields_0(builder){
  $append_10($append_11($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_10($append_11($append_8($append_11($append_8((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
}
;
_.name_1 = function name_2(){
  return 'Events.Position';
}
;
_.hit = null;
_.x = 0;
_.y = 0;
function $tick(this$static, elapsed){
  var alpha, nextUpdate, updateRate, updates;
  nextUpdate = this$static.nextUpdate;
  updateRate = this$static.updateRate;
  updates = 0;
  while (elapsed >= nextUpdate) {
    nextUpdate += updateRate;
    ++updates;
  }
  if (updates > 0) {
    !!this$static.screen_0 && this$static.screen_0.update_0(33);
    elapsed = $tick_0(platform_1);
  }
  alpha = 1 - (nextUpdate - elapsed) / updateRate;
  !!this$static.screen_0 && this$static.screen_0.paint_2(alpha);
  this$static.nextUpdate = nextUpdate;
}

defineSeed(354, 1, {});
_.nextUpdate = 0;
_.updateRate = 0;
function $add_8(this$static, self_0, child){
  var count, index, parent_0;
  parent_0 = child.parent_0;
  if (parent_0 == self_0) {
    return $findChild(this$static, child, child.depth);
  }
  count = this$static.children.size;
  count == 0 || $get(this$static.children, count - 1).depth <= child.depth?(index = count):(index = $findInsertion(this$static, child.depth));
  !!parent_0 && child.parent_0.remove_4(child);
  $add(this$static.children, index, child);
  child.parent_0 = self_0;
  child.onAdd();
  $isSet(child, ($clinit_AbstractLayer$Flag() , INTERACTIVE)) && self_0.setInteractive(true);
  return index;
}

function $findChild(this$static, child, depth){
  var c, ii, ll, startIdx;
  startIdx = $findInsertion(this$static, depth);
  for (ii = startIdx - 1; ii >= 0; --ii) {
    c = $get(this$static.children, ii);
    if (c == child) {
      return ii;
    }
    if (c.depth != depth) {
      break;
    }
  }
  for (ii = startIdx , ll = this$static.children.size; ii < ll; ++ii) {
    c = $get(this$static.children, ii);
    if (c == child) {
      return ii;
    }
    if (c.depth != depth) {
      break;
    }
  }
  return -1;
}

function $findInsertion(this$static, depth){
  var high, low, mid, midDepth;
  low = 0;
  high = this$static.children.size - 1;
  while (low <= high) {
    mid = ~~(low + high) >>> 1;
    midDepth = $get(this$static.children, mid).depth;
    if (depth > midDepth) {
      low = mid + 1;
    }
     else if (depth < midDepth) {
      high = mid - 1;
    }
     else {
      return mid;
    }
  }
  return low;
}

function $hitTest(this$static, self_0, point){
  var child, ii, l_0, sawInteractiveChild, x, y;
  x = point.x;
  y = point.y;
  sawInteractiveChild = false;
  for (ii = this$static.children.size - 1; ii >= 0; --ii) {
    child = $get(this$static.children, ii);
    if (!$isSet(child, ($clinit_AbstractLayer$Flag() , INTERACTIVE)))
      continue;
    sawInteractiveChild = true;
    if (!$isSet(child, VISIBLE_1))
      continue;
    $transform_0(child).inverseTransform_0($set_17(point, x, y), point);
    point.x += child.originX;
    point.y += child.originY;
    l_0 = child.hitTestDefault(point);
    if (l_0)
      return l_0;
  }
  !sawInteractiveChild && self_0.setInteractive(false);
  return null;
}

function $onAdd_0(this$static){
  var ii, ll;
  for (ii = 0 , ll = this$static.children.size; ii < ll; ++ii) {
    $get(this$static.children, ii).onAdd();
  }
}

function $onRemove(this$static){
  var ii, ll;
  for (ii = 0 , ll = this$static.children.size; ii < ll; ++ii) {
    $get(this$static.children, ii).onRemove();
  }
}

function $remove_10(this$static, child){
  var index, child_0;
  index = $findChild(this$static, child, child.depth);
  if (index < 0) {
    throw new UnsupportedOperationException_1('Could not remove Layer because it is not a child of the GroupLayer');
  }
  child_0 = $remove(this$static.children, index);
  child_0.onRemove();
  child_0.parent_0 = null;
}

function GroupLayerImpl_0(){
  this.children = new ArrayList_0;
}

defineSeed(355, 1, {}, GroupLayerImpl_0);
function $clinit_Key(){
  $clinit_Key = nullMethod;
  A = new Key_0('A', 0);
  B = new Key_0('B', 1);
  C_0 = new Key_0('C', 2);
  D = new Key_0('D', 3);
  E = new Key_0('E', 4);
  F = new Key_0('F', 5);
  G = new Key_0('G', 6);
  H = new Key_0('H', 7);
  I = new Key_0('I', 8);
  J = new Key_0('J', 9);
  K_0 = new Key_0('K', 10);
  L = new Key_0('L', 11);
  M = new Key_0('M', 12);
  N = new Key_0('N', 13);
  O = new Key_0('O', 14);
  P = new Key_0('P', 15);
  Q = new Key_0('Q', 16);
  R_0 = new Key_0('R', 17);
  S = new Key_0('S', 18);
  T_0 = new Key_0('T', 19);
  U = new Key_0('U', 20);
  V = new Key_0('V', 21);
  W = new Key_0('W', 22);
  X = new Key_0('X', 23);
  Y = new Key_0('Y', 24);
  Z = new Key_0('Z', 25);
  K0 = new Key_0('K0', 26);
  K1 = new Key_0('K1', 27);
  K2 = new Key_0('K2', 28);
  K3 = new Key_0('K3', 29);
  K4 = new Key_0('K4', 30);
  K5 = new Key_0('K5', 31);
  K6 = new Key_0('K6', 32);
  K7 = new Key_0('K7', 33);
  K8 = new Key_0('K8', 34);
  K9 = new Key_0('K9', 35);
  NP0 = new Key_0('NP0', 36);
  NP1 = new Key_0('NP1', 37);
  NP2 = new Key_0('NP2', 38);
  NP3 = new Key_0('NP3', 39);
  NP4 = new Key_0('NP4', 40);
  NP5 = new Key_0('NP5', 41);
  NP6 = new Key_0('NP6', 42);
  NP7 = new Key_0('NP7', 43);
  NP8 = new Key_0('NP8', 44);
  NP9 = new Key_0('NP9', 45);
  NP_ADD = new Key_0('NP_ADD', 46);
  NP_DECIMAL = new Key_0('NP_DECIMAL', 47);
  NP_DELETE = new Key_0('NP_DELETE', 48);
  NP_DIVIDE = new Key_0('NP_DIVIDE', 49);
  NP_MULTIPLY = new Key_0('NP_MULTIPLY', 50);
  NP_NUM_LOCK = new Key_0('NP_NUM_LOCK', 51);
  NP_SUBTRACT = new Key_0('NP_SUBTRACT', 52);
  NP_DOWN = new Key_0('NP_DOWN', 53);
  NP_LEFT = new Key_0('NP_LEFT', 54);
  NP_RIGHT = new Key_0('NP_RIGHT', 55);
  NP_UP = new Key_0('NP_UP', 56);
  F1 = new Key_0('F1', 57);
  F2 = new Key_0('F2', 58);
  F3 = new Key_0('F3', 59);
  F4 = new Key_0('F4', 60);
  F5 = new Key_0('F5', 61);
  F6 = new Key_0('F6', 62);
  F7 = new Key_0('F7', 63);
  F8 = new Key_0('F8', 64);
  F9 = new Key_0('F9', 65);
  F10 = new Key_0('F10', 66);
  F11 = new Key_0('F11', 67);
  F12 = new Key_0('F12', 68);
  AMPERSAND = new Key_0('AMPERSAND', 69);
  ASTERISK = new Key_0('ASTERISK', 70);
  AT = new Key_0('AT', 71);
  BACKQUOTE = new Key_0('BACKQUOTE', 72);
  BACKSLASH = new Key_0('BACKSLASH', 73);
  BANG = new Key_0('BANG', 74);
  CIRCUMFLEX = new Key_0('CIRCUMFLEX', 75);
  COLON = new Key_0('COLON', 76);
  COMMA = new Key_0('COMMA', 77);
  DOLLAR = new Key_0('DOLLAR', 78);
  DOUBLE_QUOTE = new Key_0('DOUBLE_QUOTE', 79);
  EQUALS = new Key_0('EQUALS', 80);
  GREATER = new Key_0('GREATER', 81);
  HASH = new Key_0('HASH', 82);
  LEFT_BRACE = new Key_0('LEFT_BRACE', 83);
  LEFT_BRACKET = new Key_0('LEFT_BRACKET', 84);
  LEFT_PAREN = new Key_0('LEFT_PAREN', 85);
  LESS = new Key_0('LESS', 86);
  MINUS = new Key_0('MINUS', 87);
  MULTIPLY = new Key_0('MULTIPLY', 88);
  PERCENT = new Key_0('PERCENT', 89);
  PERIOD = new Key_0('PERIOD', 90);
  PLUS = new Key_0('PLUS', 91);
  QUOTE = new Key_0('QUOTE', 92);
  RIGHT_BRACE = new Key_0('RIGHT_BRACE', 93);
  RIGHT_BRACKET = new Key_0('RIGHT_BRACKET', 94);
  RIGHT_PAREN = new Key_0('RIGHT_PAREN', 95);
  SEMICOLON = new Key_0('SEMICOLON', 96);
  SLASH = new Key_0('SLASH', 97);
  SPACE = new Key_0('SPACE', 98);
  TILDE = new Key_0('TILDE', 99);
  QUESTION_MARK = new Key_0('QUESTION_MARK', 100);
  UNDERSCORE = new Key_0('UNDERSCORE', 101);
  VERTICAL_BAR = new Key_0('VERTICAL_BAR', 102);
  ALT = new Key_0('ALT', 103);
  CONTROL = new Key_0('CONTROL', 104);
  CAPS_LOCK = new Key_0('CAPS_LOCK', 105);
  SHIFT = new Key_0('SHIFT', 106);
  META = new Key_0('META', 107);
  DOWN = new Key_0('DOWN', 108);
  END = new Key_0('END', 109);
  HOME = new Key_0('HOME', 110);
  LEFT = new Key_0('LEFT', 111);
  PAGE_UP = new Key_0('PAGE_UP', 112);
  PAGE_DOWN = new Key_0('PAGE_DOWN', 113);
  RIGHT = new Key_0('RIGHT', 114);
  UP = new Key_0('UP', 115);
  BACKSPACE = new Key_0('BACKSPACE', 116);
  DELETE = new Key_0('DELETE', 117);
  ENTER = new Key_0('ENTER', 118);
  INSERT = new Key_0('INSERT', 119);
  TAB = new Key_0('TAB', 120);
  ESCAPE = new Key_0('ESCAPE', 121);
  PAUSE = new Key_0('PAUSE', 122);
  PRINT_SCREEN = new Key_0('PRINT_SCREEN', 123);
  SCROLL_LOCK = new Key_0('SCROLL_LOCK', 124);
  WINDOWS = new Key_0('WINDOWS', 125);
  MEDIA_CLOSE = new Key_0('MEDIA_CLOSE', 126);
  MEDIA_EJECT = new Key_0('MEDIA_EJECT', 127);
  MEDIA_FAST_FORWARD = new Key_0('MEDIA_FAST_FORWARD', 128);
  MEDIA_NEXT = new Key_0('MEDIA_NEXT', 129);
  MEDIA_PAUSE = new Key_0('MEDIA_PAUSE', 130);
  MEDIA_PLAY = new Key_0('MEDIA_PLAY', 131);
  MEDIA_PLAY_PAUSE = new Key_0('MEDIA_PLAY_PAUSE', 132);
  MEDIA_PREVIOUS = new Key_0('MEDIA_PREVIOUS', 133);
  MEDIA_RECORD = new Key_0('MEDIA_RECORD', 134);
  MEDIA_REWIND = new Key_0('MEDIA_REWIND', 135);
  MEDIA_STOP = new Key_0('MEDIA_STOP', 136);
  BLUE = new Key_0('BLUE', 137);
  GREEN = new Key_0('GREEN', 138);
  RED = new Key_0('RED', 139);
  YELLOW = new Key_0('YELLOW', 140);
  APP_SWITCH = new Key_0('APP_SWITCH', 141);
  AVR_INPUT = new Key_0('AVR_INPUT', 142);
  AVR_POWER = new Key_0('AVR_POWER', 143);
  BACK = new Key_0('BACK', 144);
  BOOKMARK = new Key_0('BOOKMARK', 145);
  BREAK = new Key_0('BREAK', 146);
  BUTTON_1 = new Key_0('BUTTON_1', 147);
  BUTTON_2 = new Key_0('BUTTON_2', 148);
  BUTTON_3 = new Key_0('BUTTON_3', 149);
  BUTTON_4 = new Key_0('BUTTON_4', 150);
  BUTTON_5 = new Key_0('BUTTON_5', 151);
  BUTTON_6 = new Key_0('BUTTON_6', 152);
  BUTTON_7 = new Key_0('BUTTON_7', 153);
  BUTTON_8 = new Key_0('BUTTON_8', 154);
  BUTTON_9 = new Key_0('BUTTON_9', 155);
  BUTTON_10 = new Key_0('BUTTON_10', 156);
  BUTTON_11 = new Key_0('BUTTON_11', 157);
  BUTTON_12 = new Key_0('BUTTON_12', 158);
  BUTTON_13 = new Key_0('BUTTON_13', 159);
  BUTTON_14 = new Key_0('BUTTON_14', 160);
  BUTTON_15 = new Key_0('BUTTON_15', 161);
  BUTTON_16 = new Key_0('BUTTON_16', 162);
  BUTTON_A = new Key_0('BUTTON_A', 163);
  BUTTON_B = new Key_0('BUTTON_B', 164);
  BUTTON_C = new Key_0('BUTTON_C', 165);
  BUTTON_L1 = new Key_0('BUTTON_L1', 166);
  BUTTON_L2 = new Key_0('BUTTON_L2', 167);
  BUTTON_MODE = new Key_0('BUTTON_MODE', 168);
  BUTTON_R1 = new Key_0('BUTTON_R1', 169);
  BUTTON_R2 = new Key_0('BUTTON_R2', 170);
  BUTTON_SELECT = new Key_0('BUTTON_SELECT', 171);
  BUTTON_START = new Key_0('BUTTON_START', 172);
  BUTTON_THUMBL = new Key_0('BUTTON_THUMBL', 173);
  BUTTON_THUMBR = new Key_0('BUTTON_THUMBR', 174);
  BUTTON_X = new Key_0('BUTTON_X', 175);
  BUTTON_Y = new Key_0('BUTTON_Y', 176);
  BUTTON_Z = new Key_0('BUTTON_Z', 177);
  CALL = new Key_0('CALL', 178);
  CAMERA = new Key_0('CAMERA', 179);
  CAPTIONS = new Key_0('CAPTIONS', 180);
  CHANNEL_DOWN = new Key_0('CHANNEL_DOWN', 181);
  CHANNEL_UP = new Key_0('CHANNEL_UP', 182);
  CLEAR = new Key_0('CLEAR', 183);
  DPAD_CENTER = new Key_0('DPAD_CENTER', 184);
  DPAD_DOWN = new Key_0('DPAD_DOWN', 185);
  DPAD_LEFT = new Key_0('DPAD_LEFT', 186);
  DPAD_RIGHT = new Key_0('DPAD_RIGHT', 187);
  DPAD_UP = new Key_0('DPAD_UP', 188);
  DVR = new Key_0('DVR', 189);
  ENDCALL = new Key_0('ENDCALL', 190);
  ENVELOPE = new Key_0('ENVELOPE', 191);
  EXPLORER = new Key_0('EXPLORER', 192);
  FOCUS = new Key_0('FOCUS', 193);
  FORWARD = new Key_0('FORWARD', 194);
  FORWARD_DEL = new Key_0('FORWARD_DEL', 195);
  FUNCTION = new Key_0('FUNCTION', 196);
  GUIDE = new Key_0('GUIDE', 197);
  HEADSETHOOK = new Key_0('HEADSETHOOK', 198);
  INFO = new Key_0('INFO', 199);
  MENU = new Key_0('MENU', 200);
  MUTE = new Key_0('MUTE', 201);
  NOTIFICATION = new Key_0('NOTIFICATION', 202);
  NUM = new Key_0('NUM', 203);
  PICTSYMBOLS = new Key_0('PICTSYMBOLS', 204);
  POWER = new Key_0('POWER', 205);
  SEARCH = new Key_0('SEARCH', 206);
  SETTINGS = new Key_0('SETTINGS', 207);
  SOFT_LEFT = new Key_0('SOFT_LEFT', 208);
  SOFT_RIGHT = new Key_0('SOFT_RIGHT', 209);
  STAR = new Key_0('STAR', 210);
  STB_INPUT = new Key_0('STB_INPUT', 211);
  STB_POWER = new Key_0('STB_POWER', 212);
  SWITCH_CHARSET = new Key_0('SWITCH_CHARSET', 213);
  SYM = new Key_0('SYM', 214);
  SYSRQ = new Key_0('SYSRQ', 215);
  TV = new Key_0('TV', 216);
  TV_INPUT = new Key_0('TV_INPUT', 217);
  TV_POWER = new Key_0('TV_POWER', 218);
  VOLUME_DOWN = new Key_0('VOLUME_DOWN', 219);
  VOLUME_MUTE = new Key_0('VOLUME_MUTE', 220);
  VOLUME_UP = new Key_0('VOLUME_UP', 221);
  WINDOW = new Key_0('WINDOW', 222);
  ZOOM_IN = new Key_0('ZOOM_IN', 223);
  ZOOM_OUT = new Key_0('ZOOM_OUT', 224);
  UNKNOWN_1 = new Key_0('UNKNOWN', 225);
  $VALUES_13 = initValues(_3Lplayn_core_Key_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Key, [A, B, C_0, D, E, F, G, H, I, J, K_0, L, M, N, O, P, Q, R_0, S, T_0, U, V, W, X, Y, Z, K0, K1, K2, K3, K4, K5, K6, K7, K8, K9, NP0, NP1, NP2, NP3, NP4, NP5, NP6, NP7, NP8, NP9, NP_ADD, NP_DECIMAL, NP_DELETE, NP_DIVIDE, NP_MULTIPLY, NP_NUM_LOCK, NP_SUBTRACT, NP_DOWN, NP_LEFT, NP_RIGHT, NP_UP, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, AMPERSAND, ASTERISK, AT, BACKQUOTE, BACKSLASH, BANG, CIRCUMFLEX, COLON, COMMA, DOLLAR, DOUBLE_QUOTE, EQUALS, GREATER, HASH, LEFT_BRACE, LEFT_BRACKET, LEFT_PAREN, LESS, MINUS, MULTIPLY, PERCENT, PERIOD, PLUS, QUOTE, RIGHT_BRACE, RIGHT_BRACKET, RIGHT_PAREN, SEMICOLON, SLASH, SPACE, TILDE, QUESTION_MARK, UNDERSCORE, VERTICAL_BAR, ALT, CONTROL, CAPS_LOCK, SHIFT, META, DOWN, END, HOME, LEFT, PAGE_UP, PAGE_DOWN, RIGHT, UP, BACKSPACE, DELETE, ENTER, INSERT, TAB, ESCAPE, PAUSE, PRINT_SCREEN, SCROLL_LOCK, WINDOWS, MEDIA_CLOSE, MEDIA_EJECT, MEDIA_FAST_FORWARD, MEDIA_NEXT, MEDIA_PAUSE, MEDIA_PLAY, MEDIA_PLAY_PAUSE, MEDIA_PREVIOUS, MEDIA_RECORD, MEDIA_REWIND, MEDIA_STOP, BLUE, GREEN, RED, YELLOW, APP_SWITCH, AVR_INPUT, AVR_POWER, BACK, BOOKMARK, BREAK, BUTTON_1, BUTTON_2, BUTTON_3, BUTTON_4, BUTTON_5, BUTTON_6, BUTTON_7, BUTTON_8, BUTTON_9, BUTTON_10, BUTTON_11, BUTTON_12, BUTTON_13, BUTTON_14, BUTTON_15, BUTTON_16, BUTTON_A, BUTTON_B, BUTTON_C, BUTTON_L1, BUTTON_L2, BUTTON_MODE, BUTTON_R1, BUTTON_R2, BUTTON_SELECT, BUTTON_START, BUTTON_THUMBL, BUTTON_THUMBR, BUTTON_X, BUTTON_Y, BUTTON_Z, CALL, CAMERA, CAPTIONS, CHANNEL_DOWN, CHANNEL_UP, CLEAR, DPAD_CENTER, DPAD_DOWN, DPAD_LEFT, DPAD_RIGHT, DPAD_UP, DVR, ENDCALL, ENVELOPE, EXPLORER, FOCUS, FORWARD, FORWARD_DEL, FUNCTION, GUIDE, HEADSETHOOK, INFO, MENU, MUTE, NOTIFICATION, NUM, PICTSYMBOLS, POWER, SEARCH, SETTINGS, SOFT_LEFT, SOFT_RIGHT, STAR, STB_INPUT, STB_POWER, SWITCH_CHARSET, SYM, SYSRQ, TV, TV_INPUT, TV_POWER, VOLUME_DOWN, VOLUME_MUTE, VOLUME_UP, WINDOW, ZOOM_IN, ZOOM_OUT, UNKNOWN_1]);
}

function Key_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_13(){
  $clinit_Key();
  return $VALUES_13;
}

defineSeed(356, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Key]), Key_0);
--></script>
<script><!--
var $VALUES_13, A, ALT, AMPERSAND, APP_SWITCH, ASTERISK, AT, AVR_INPUT, AVR_POWER, B, BACK, BACKQUOTE, BACKSLASH, BACKSPACE, BANG, BLUE, BOOKMARK, BREAK, BUTTON_1, BUTTON_10, BUTTON_11, BUTTON_12, BUTTON_13, BUTTON_14, BUTTON_15, BUTTON_16, BUTTON_2, BUTTON_3, BUTTON_4, BUTTON_5, BUTTON_6, BUTTON_7, BUTTON_8, BUTTON_9, BUTTON_A, BUTTON_B, BUTTON_C, BUTTON_L1, BUTTON_L2, BUTTON_MODE, BUTTON_R1, BUTTON_R2, BUTTON_SELECT, BUTTON_START, BUTTON_THUMBL, BUTTON_THUMBR, BUTTON_X, BUTTON_Y, BUTTON_Z, C_0, CALL, CAMERA, CAPS_LOCK, CAPTIONS, CHANNEL_DOWN, CHANNEL_UP, CIRCUMFLEX, CLEAR, COLON, COMMA, CONTROL, D, DELETE, DOLLAR, DOUBLE_QUOTE, DOWN, DPAD_CENTER, DPAD_DOWN, DPAD_LEFT, DPAD_RIGHT, DPAD_UP, DVR, E, END, ENDCALL, ENTER, ENVELOPE, EQUALS, ESCAPE, EXPLORER, F, F1, F10, F11, F12, F2, F3, F4, F5, F6, F7, F8, F9, FOCUS, FORWARD, FORWARD_DEL, FUNCTION, G, GREATER, GREEN, GUIDE, H, HASH, HEADSETHOOK, HOME, I, INFO, INSERT, J, K_0, K0, K1, K2, K3, K4, K5, K6, K7, K8, K9, L, LEFT, LEFT_BRACE, LEFT_BRACKET, LEFT_PAREN, LESS, M, MEDIA_CLOSE, MEDIA_EJECT, MEDIA_FAST_FORWARD, MEDIA_NEXT, MEDIA_PAUSE, MEDIA_PLAY, MEDIA_PLAY_PAUSE, MEDIA_PREVIOUS, MEDIA_RECORD, MEDIA_REWIND, MEDIA_STOP, MENU, META, MINUS, MULTIPLY, MUTE, N, NOTIFICATION, NP0, NP1, NP2, NP3, NP4, NP5, NP6, NP7, NP8, NP9, NP_ADD, NP_DECIMAL, NP_DELETE, NP_DIVIDE, NP_DOWN, NP_LEFT, NP_MULTIPLY, NP_NUM_LOCK, NP_RIGHT, NP_SUBTRACT, NP_UP, NUM, O, P, PAGE_DOWN, PAGE_UP, PAUSE, PERCENT, PERIOD, PICTSYMBOLS, PLUS, POWER, PRINT_SCREEN, Q, QUESTION_MARK, QUOTE, R_0, RED, RIGHT, RIGHT_BRACE, RIGHT_BRACKET, RIGHT_PAREN, S, SCROLL_LOCK, SEARCH, SEMICOLON, SETTINGS, SHIFT, SLASH, SOFT_LEFT, SOFT_RIGHT, SPACE, STAR, STB_INPUT, STB_POWER, SWITCH_CHARSET, SYM, SYSRQ, T_0, TAB, TILDE, TV, TV_INPUT, TV_POWER, U, UNDERSCORE, UNKNOWN_1, UP, V, VERTICAL_BAR, VOLUME_DOWN, VOLUME_MUTE, VOLUME_UP, W, WINDOW, WINDOWS, X, Y, YELLOW, Z, ZOOM_IN, ZOOM_OUT;
function Keyboard$Event$Impl_0(flags, time, key){
  Events$Input$Impl_0.call(this, flags, time);
  this.key_0 = key;
}

defineSeed(357, 352, makeCastMap([Q$Events$Input, Q$Events$Input$Impl]), Keyboard$Event$Impl_0);
_.addFields = function addFields_1(builder){
  $append_10($append_11($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_10((builder.impl.string += ', key=' , builder), this.key_0);
}
;
_.name_1 = function name_3(){
  return 'Keyboard.Event';
}
;
_.key_0 = null;
function Keyboard$TypedEvent$Impl_0(flags, time, typedChar){
  Events$Input$Impl_0.call(this, flags, time);
  this.typedChar = typedChar;
}

defineSeed(358, 352, makeCastMap([Q$Events$Input, Q$Events$Input$Impl]), Keyboard$TypedEvent$Impl_0);
_.addFields = function addFields_2(builder){
  $append_10($append_11($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_6((builder.impl.string += ', typedChar=' , builder), this.typedChar);
}
;
_.name_1 = function name_4(){
  return 'Keyboard.TypedEvent';
}
;
_.typedChar = 0;
function screenToLayer(layer, point, into){
  var cur, parent_0;
  parent_0 = layer.parent_1();
  cur = !parent_0?point:screenToLayer(parent_0, point, into);
  return layer.transform_1().inverseTransform_0(cur, into) , into.x += layer.originX_0() , into.y += layer.originY_0() , into;
}

function $clinit_Log$Level(){
  $clinit_Log$Level = nullMethod;
  DEBUG = new Log$Level_0('DEBUG', 0);
  INFO_0 = new Log$Level_0('INFO', 1);
  WARN = new Log$Level_0('WARN', 2);
  ERROR = new Log$Level_0('ERROR', 3);
  $VALUES_14 = initValues(_3Lplayn_core_Log$Level_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Log$Level, [DEBUG, INFO_0, WARN, ERROR]);
}

function Log$Level_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_14(){
  $clinit_Log$Level();
  return $VALUES_14;
}

defineSeed(360, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Log$Level]), Log$Level_0);
var $VALUES_14, DEBUG, ERROR, INFO_0, WARN;
function $debug(this$static, msg){
  $log(this$static, ($clinit_Log$Level() , DEBUG), msg, null);
}

function $error(this$static, msg){
  $log(this$static, ($clinit_Log$Level() , ERROR), msg, null);
}

function $error_0(this$static, msg, e){
  $log(this$static, ($clinit_Log$Level() , ERROR), msg, e);
}

function $info(this$static, msg){
  $log(this$static, ($clinit_Log$Level() , INFO_0), msg, null);
}

function $log(this$static, level, msg, e){
  var lmsg;
  level.ordinal >= this$static.minLevel.ordinal && (lmsg = level + ': ' + msg , !!e && $printStackTrace(e) , $wnd.console && $wnd.console.info && (e != null?$wnd.console.info(lmsg, e):$wnd.console.info(lmsg)) , undefined);
}

function $warn(this$static, msg){
  $log(this$static, ($clinit_Log$Level() , WARN), msg, null);
}

function $warn_0(this$static, msg, e){
  $log(this$static, ($clinit_Log$Level() , WARN), msg, e);
}

defineSeed(361, 1, {});
function Mouse$ButtonEvent$Impl_0(flags, time, x, y, button){
  Events$Position$Impl_0.call(this, null, flags, time, x, y);
  this.button_0 = button;
}

function Mouse$ButtonEvent$Impl_1(hit, flags, time, x, y, button){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.button_0 = button;
}

defineSeed(362, 353, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Mouse$ButtonEvent$Impl_0, Mouse$ButtonEvent$Impl_1);
_.addFields = function addFields_3(builder){
  $append_10($append_11($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_10($append_11($append_8($append_11($append_8((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
  $append_9((builder.impl.string += ', button=' , builder), this.button_0);
}
;
_.localize = function localize(hit){
  return new Mouse$ButtonEvent$Impl_1(hit, this.flags, this.time, this.x, this.y, this.button_0);
}
;
_.name_1 = function name_5(){
  return 'ButtonEvent';
}
;
_.button_0 = 0;
function Mouse$MotionEvent$Impl_0(flags, time, x, y, dx, dy){
  Events$Position$Impl_0.call(this, null, flags, time, x, y);
  this.dx = dx;
  this.dy = dy;
}

function Mouse$MotionEvent$Impl_1(hit, flags, time, x, y, dx, dy){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.dx = dx;
  this.dy = dy;
}

defineSeed(363, 353, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Mouse$MotionEvent$Impl_0, Mouse$MotionEvent$Impl_1);
_.localize = function localize_0(hit){
  return new Mouse$MotionEvent$Impl_1(hit, this.flags, this.time, this.x, this.y, this.dx, this.dy);
}
;
_.name_1 = function name_6(){
  return 'MotionEvent';
}
;
_.dx = 0;
_.dy = 0;
function Mouse$WheelEvent$Impl_0(flags, time, x, y, velocity){
  Events$Position$Impl_0.call(this, null, flags, time, x, y);
  this.velocity = velocity;
}

function Mouse$WheelEvent$Impl_1(hit, flags, time, x, y, velocity){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.velocity = velocity;
}

defineSeed(364, 353, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Mouse$WheelEvent$Impl_0, Mouse$WheelEvent$Impl_1);
_.addFields = function addFields_4(builder){
  $append_10($append_11($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_10($append_11($append_8($append_11($append_8((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
  $append_8((builder.impl.string += ', velocity=' , builder), this.velocity);
}
;
_.localize = function localize_1(hit){
  return new Mouse$WheelEvent$Impl_1(hit, this.flags, this.time, this.x, this.y, this.velocity);
}
;
_.name_1 = function name_7(){
  return 'WheelEvent';
}
;
_.velocity = 0;
function $onMouseDown(this$static, event_0){
  var p, root;
  event_0.flags.preventDefault_0 = false;
  !!this$static.listener && $onMouseDown_0(this$static.listener, event_0);
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    p = new Point_1(event_0.x, event_0.y);
    root.transform_1().inverseTransform_0(p, p);
    p.x += root.originX_0();
    p.y += root.originY_0();
    this$static.activeLayer = root.hitTest(p);
    !!this$static.activeLayer && $dispatch(this$static.activeLayer, event_0, this$static.DOWN);
  }
  return event_0.flags.preventDefault_0;
}

function $onMouseMove(this$static, event_0){
  var lastHoverLayer, p, root;
  event_0.flags.preventDefault_0 = false;
  !!this$static.listener && $onMouseMove_0(this$static.listener, event_0);
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    p = new Point_1(event_0.x, event_0.y);
    root.transform_1().inverseTransform_0(p, p);
    p.x += root.originX_0();
    p.y += root.originY_0();
    lastHoverLayer = this$static.hoverLayer;
    this$static.hoverLayer = root.hitTest(p);
    this$static.activeLayer?$dispatch(this$static.activeLayer, event_0, this$static.DRAG):!!this$static.hoverLayer && $dispatch(this$static.hoverLayer, event_0, this$static.MOVE);
    lastHoverLayer != this$static.hoverLayer && !!lastHoverLayer && $dispatch(lastHoverLayer, event_0, this$static.OUT);
    this$static.hoverLayer != lastHoverLayer && !!this$static.hoverLayer && $dispatch(this$static.hoverLayer, event_0, this$static.OVER);
  }
  return event_0.flags.preventDefault_0;
}

function $onMouseUp(this$static, event_0){
  event_0.flags.preventDefault_0 = false;
  !!this$static.listener && $onMouseUp_0(this$static.listener, event_0);
  if (this$static.activeLayer) {
    $dispatch(this$static.activeLayer, event_0, this$static.UP);
    this$static.activeLayer = null;
  }
  return event_0.flags.preventDefault_0;
}

function $onMouseWheelScroll(this$static, event_0){
  var target;
  !!this$static.listener && $onMouseWheelScroll_0(this$static.listener, event_0);
  target = this$static.activeLayer?this$static.activeLayer:this$static.hoverLayer;
  !!target && $dispatch(target, event_0, this$static.WHEEL_SCROLL);
  return event_0.flags.preventDefault_0;
}

function $setListener(this$static, listener){
  this$static.listener = listener;
}

defineSeed(365, 1, {});
_.activeLayer = null;
_.hoverLayer = null;
_.listener = null;
function MouseImpl$1_0(){
}

defineSeed(366, 1, {}, MouseImpl$1_0);
function MouseImpl$2_0(){
}

defineSeed(367, 1, {}, MouseImpl$2_0);
function MouseImpl$3_0(){
}

defineSeed(368, 1, {}, MouseImpl$3_0);
function MouseImpl$4_0(){
}

defineSeed(369, 1, {}, MouseImpl$4_0);
function MouseImpl$5_0(){
}

defineSeed(370, 1, {}, MouseImpl$5_0);
function MouseImpl$6_0(){
}

defineSeed(371, 1, {}, MouseImpl$6_0);
function MouseImpl$7_0(){
}

defineSeed(372, 1, {}, MouseImpl$7_0);
function run(game){
  $run(platform_1, game);
}

var platform_1 = null;
function Pointer$Event$Impl_0(flags, time, x, y, isTouch){
  Pointer$Event$Impl_1.call(this, null, flags, time, x, y, isTouch);
}

function Pointer$Event$Impl_1(hit, flags, time, x, y, isTouch){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.isTouch = isTouch;
}

defineSeed(374, 353, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Pointer$Event$Impl_0, Pointer$Event$Impl_1);
_.localize = function localize_2(hit){
  return new Pointer$Event$Impl_1(hit, this.flags, this.time, this.x, this.y, this.isTouch);
}
;
_.name_1 = function name_8(){
  return 'Pointer.Event';
}
;
_.isTouch = false;
function $onPointerDrag(this$static, event_0, preventDefault){
  $setPreventDefault(event_0.flags, preventDefault);
  !!this$static.listener && $onPointerDrag_0(this$static.listener, event_0);
  !!this$static.activeLayer && $dispatch(this$static.activeLayer, event_0, this$static.DRAG);
  return event_0.flags.preventDefault_0;
}

function $onPointerEnd(this$static, event_0, preventDefault){
  $setPreventDefault(event_0.flags, preventDefault);
  !!this$static.listener && $onPointerEnd_0(this$static.listener, event_0);
  if (this$static.activeLayer) {
    $dispatch(this$static.activeLayer, event_0, this$static.END);
    this$static.activeLayer = null;
  }
  return event_0.flags.preventDefault_0;
}

function $onPointerStart(this$static, event_0){
  var p, root;
  event_0.flags.preventDefault_0 = true;
  !!this$static.listener && $onPointerStart_0(this$static.listener, event_0);
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    p = new Point_1(event_0.x, event_0.y);
    root.transform_1().inverseTransform_0(p, p);
    p.x += root.originX_0();
    p.y += root.originY_0();
    this$static.activeLayer = root.hitTest(p);
    !!this$static.activeLayer && $dispatch(this$static.activeLayer, event_0, this$static.START);
  }
  return event_0.flags.preventDefault_0;
}

function $setListener_0(this$static, listener){
  this$static.listener = listener;
}

defineSeed(375, 1, {});
_.activeLayer = null;
_.listener = null;
function PointerImpl$1_0(){
}

defineSeed(376, 1, {}, PointerImpl$1_0);
function PointerImpl$2_0(){
}

defineSeed(377, 1, {}, PointerImpl$2_0);
function PointerImpl$3_0(){
}

defineSeed(378, 1, {}, PointerImpl$3_0);
function $scale_0(this$static, scaleX, scaleY){
  this$static.scaleX_0(scaleX);
  this$static.scaleY_0(scaleY);
  return this$static;
}

defineSeed(381, 1, {});
_.scale_2 = function scale_1(scaleX, scaleY){
  return $scale_0(this, scaleX, scaleY);
}
;
_.scaleX_0 = function scaleX_0(scaleX){
  throw new UnsupportedOperationException_0;
}
;
_.scaleY_0 = function scaleY_0(scaleY){
  throw new UnsupportedOperationException_0;
}
;
_.setTransform = function setTransform(m00, m01, m10, m11, tx, ty){
  throw new UnsupportedOperationException_0;
}
;
_.translate_1 = function translate_0(tx, ty){
  this.translateX(tx);
  this.translateY(ty);
  return this;
}
;
_.translateX = function translateX(tx){
  throw new UnsupportedOperationException_0;
}
;
_.translateY = function translateY(ty){
  throw new UnsupportedOperationException_0;
}
;
_.uniformScale = function uniformScale(scale){
  throw new UnsupportedOperationException_0;
}
;
function $inverseTransform(this$static, p, into){
  var det, rdet, x, y;
  x = p.x - this$static.tx;
  y = p.y - this$static.ty;
  det = this$static.m00 * this$static.m11 - this$static.m01 * this$static.m10;
  if (abs(det) == 0) {
    throw new NoninvertibleTransformException_0('affine [' + toString_47(this$static.m00) + ' ' + toString_47(this$static.m01) + ' ' + toString_47(this$static.m10) + ' ' + toString_47(this$static.m11) + ' ' + new Vector_2(this$static.tx, this$static.ty) + ']');
  }
  rdet = 1 / det;
  return $set_17(into, (x * this$static.m11 - y * this$static.m10) * rdet, (y * this$static.m00 - x * this$static.m01) * rdet);
}

function $rotate(this$static, angle){
  var cosa, sina;
  sina = Math.sin(angle);
  cosa = Math.cos(angle);
  return multiply_1(this$static.m00, this$static.m01, this$static.m10, this$static.m11, this$static.tx, this$static.ty, cosa, sina, -sina, cosa, 0, 0, this$static);
}

function $scale_1(this$static, scaleX, scaleY){
  return multiply_1(this$static.m00, this$static.m01, this$static.m10, this$static.m11, this$static.tx, this$static.ty, scaleX, 0, 0, scaleY, 0, 0, this$static);
}

function $setRotation(this$static, angle){
  var cosa, sina, sx, sy;
  sx = sqrt(this$static.m00 * this$static.m00 + this$static.m01 * this$static.m01);
  sy = sqrt(this$static.m10 * this$static.m10 + this$static.m11 * this$static.m11);
  sina = Math.sin(angle);
  cosa = Math.cos(angle);
  this$static.m00 = cosa * sx;
  this$static.m01 = sina * sx;
  this$static.m10 = -sina * sy;
  this$static.m11 = cosa * sy;
  return this$static;
}

function $setTransform(this$static, m00, m01, m10, m11, tx, ty){
  this$static.m00 = m00;
  this$static.m01 = m01;
  this$static.m10 = m10;
  this$static.m11 = m11;
  this$static.tx = tx;
  this$static.ty = ty;
  return this$static;
}

function $setTranslation(this$static, tx, ty){
  this$static.tx = tx;
  this$static.ty = ty;
  return this$static;
}

function $setUniformScale(this$static, scale){
  var mult, mult_0;
  return mult = scale / sqrt(this$static.m00 * this$static.m00 + this$static.m01 * this$static.m01) , this$static.m00 *= mult , this$static.m01 *= mult , mult_0 = scale / sqrt(this$static.m10 * this$static.m10 + this$static.m11 * this$static.m11) , this$static.m10 *= mult_0 , this$static.m11 *= mult_0 , this$static;
}

function $transform_1(this$static, p, into){
  var x, y;
  x = p.x;
  y = p.y;
  return $set_17(into, this$static.m00 * x + this$static.m10 * y + this$static.tx, this$static.m01 * x + this$static.m11 * y + this$static.ty);
}

function $transform_2(this$static, v, into){
  var x, y;
  x = v.x;
  y = v.y;
  return $set_19(into, this$static.m00 * x + this$static.m10 * y, this$static.m01 * x + this$static.m11 * y);
}

function $translate_0(this$static, tx, ty){
  return multiply_1(this$static.m00, this$static.m01, this$static.m10, this$static.m11, this$static.tx, this$static.ty, 1, 0, 0, 1, tx, ty, this$static);
}

function $uniformScale(this$static){
  var cp;
  cp = this$static.m00 * this$static.m11 - this$static.m01 * this$static.m10;
  return cp < 0?-Math.sqrt(-cp):Math.sqrt(cp);
}

function $uniformScale_0(this$static, scale){
  return multiply_1(this$static.m00, this$static.m01, this$static.m10, this$static.m11, this$static.tx, this$static.ty, scale, 0, 0, scale, 0, 0, this$static);
}

function AffineTransform_0(){
  this.m00 = 1;
  this.m01 = 0;
  this.m10 = 0;
  this.m11 = 1;
  this.tx = 0;
  this.ty = 0;
}

defineSeed(380, 381, {}, AffineTransform_0);
_.inverseTransform_0 = function inverseTransform(p, into){
  return $inverseTransform(this, p, into);
}
;
_.scale_2 = function scale_2(scaleX, scaleY){
  return $scale_1(this, scaleX, scaleY);
}
;
_.scaleX_0 = function scaleX_1(scaleX){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, scaleX, 0, 0, 1, 0, 0, this);
}
;
_.scaleY_0 = function scaleY_1(scaleY){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, 1, 0, 0, scaleY, 0, 0, this);
}
;
_.setTransform = function setTransform_0(m00, m01, m10, m11, tx, ty){
  return $setTransform(this, m00, m01, m10, m11, tx, ty);
}
;
_.toString$ = function toString_35(){
  return 'affine [' + toString_47(this.m00) + ' ' + toString_47(this.m01) + ' ' + toString_47(this.m10) + ' ' + toString_47(this.m11) + ' ' + new Vector_2(this.tx, this.ty) + ']';
}
;
_.translate_1 = function translate_1(tx, ty){
  return $translate_0(this, tx, ty);
}
;
_.translateX = function translateX_0(tx){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, 1, 0, 0, 1, tx, 0, this);
}
;
_.translateY = function translateY_0(ty){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, 1, 0, 0, 1, 0, ty, this);
}
;
_.tx_0 = function tx_0(){
  return this.tx;
}
;
_.ty_0 = function ty_0(){
  return this.ty;
}
;
_.uniformScale = function uniformScale_0(scale){
  return $uniformScale_0(this, scale);
}
;
_.m00 = 0;
_.m01 = 0;
_.m10 = 0;
_.m11 = 0;
_.tx = 0;
_.ty = 0;
function $clinit_StockInternalTransform(){
  $clinit_StockInternalTransform = nullMethod;
  new StockInternalTransform_0;
}

function StockInternalTransform_0(){
  $clinit_StockInternalTransform();
  AffineTransform_0.call(this);
}

defineSeed(379, 380, {}, StockInternalTransform_0);
_.concatenate = function concatenate(m00, m01, m10, m11, tx, ty, originX, originY){
  return multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, m00, m01, m10, m11, tx, ty, this) , multiply_1(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, 1, 0, 0, 1, -originX, -originY, this) , this;
}
;
_.m00_0 = function m00_0(){
  return this.m00;
}
;
_.m01_0 = function m01_0(){
  return this.m01;
}
;
_.m10_0 = function m10_0(){
  return this.m10;
}
;
_.m11_0 = function m11_0(){
  return this.m11;
}
;
function combine(curTint){
  var newA;
  newA = ((~~curTint >> 24 & 255) * 256 & 65280) << 16;
  return newA | curTint & 16777215;
}

function Touch$Event$Impl_0(flags, time, x, y, id){
  Touch$Event$Impl_1.call(this, null, flags, time, x, y, id, -1, -1);
}

function Touch$Event$Impl_1(hit, flags, time, x, y, id, pressure, size){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.id_0 = id;
  this.pressure = pressure;
  this.size = size;
}

defineSeed(383, 353, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl, Q$Touch$Event, Q$Touch$Event$Impl]), Touch$Event$Impl_0, Touch$Event$Impl_1);
_.addFields = function addFields_5(builder){
  $append_10($append_11($append_7((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_10($append_11($append_8($append_11($append_8((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
  $append_8($append_11($append_8($append_11($append_9((builder.impl.string += ', id=' , builder), this.id_0), ', pressure='), this.pressure), ', size='), this.size);
}
;
_.localize = function localize_3(hit){
  return new Touch$Event$Impl_1(hit, this.flags, this.time, this.x, this.y, this.id_0, this.pressure, this.size);
}
;
_.name_1 = function name_9(){
  return 'Touch.Event';
}
;
_.id_0 = 0;
_.pressure = 0;
_.size = 0;
function $clinit_TouchImpl(){
  $clinit_TouchImpl = nullMethod;
  START = new TouchImpl$1_0;
  MOVE = new TouchImpl$2_0;
  END_0 = new TouchImpl$3_0;
}

function $onTouchEnd(this$static, touches){
  var activeLayer, event_0, event$index, event$max;
  for (event$index = 0 , event$max = touches.length; event$index < event$max; ++event$index) {
    event_0 = touches[event$index];
    activeLayer = $get_6(this$static.activeLayers, valueOf(event_0.id_0));
    if (activeLayer) {
      $dispatch(activeLayer, event_0, END_0);
      $remove_6(this$static.activeLayers, valueOf(event_0.id_0));
    }
  }
}

function $onTouchMove(this$static, touches){
  var activeLayer, event_0, event$index, event$max;
  for (event$index = 0 , event$max = touches.length; event$index < event$max; ++event$index) {
    event_0 = touches[event$index];
    activeLayer = $get_6(this$static.activeLayers, valueOf(event_0.id_0));
    !!activeLayer && $dispatch(activeLayer, event_0, MOVE);
  }
}

function $onTouchStart(this$static, touches){
  var event_0, event$index, event$max, hitLayer, p, root;
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    for (event$index = 0 , event$max = touches.length; event$index < event$max; ++event$index) {
      event_0 = touches[event$index];
      p = new Point_1(event_0.x, event_0.y);
      root.transform_1().inverseTransform_0(p, p);
      p.x += root.originX_0();
      p.y += root.originY_0();
      hitLayer = root.hitTest(p);
      if (hitLayer) {
        $put_2(this$static.activeLayers, valueOf(event_0.id_0), hitLayer);
        $dispatch(hitLayer, event_0, START);
      }
    }
  }
}

defineSeed(384, 1, {});
var END_0, MOVE, START;
function TouchImpl$1_0(){
}

defineSeed(385, 1, {}, TouchImpl$1_0);
function TouchImpl$2_0(){
}

defineSeed(386, 1, {}, TouchImpl$2_0);
function TouchImpl$3_0(){
}

defineSeed(387, 1, {}, TouchImpl$3_0);
function $getImage_0(this$static, path){
  var image;
  ++this$static.totalRequestsCount;
  image = $getImage(this$static.delegate, path);
  $addCallback_0(image, this$static.callback);
  return image;
}

function $getPendingRequestCount(this$static){
  return this$static.totalRequestsCount - this$static.errorsCount - this$static.successCount;
}

function $getSound_0(this$static, path){
  var sound;
  ++this$static.totalRequestsCount;
  sound = $getSound(this$static.delegate, path);
  $addCallback(sound, this$static.callback);
  return sound;
}

function WatchedAssets_0(delegate){
  this.callback = new WatchedAssets$1_0(this);
  this.delegate = delegate;
}

defineSeed(388, 1, {}, WatchedAssets_0);
_.delegate = null;
_.errorsCount = 0;
_.successCount = 0;
_.totalRequestsCount = 0;
function $onFailure(this$static){
  ++this$static.this$0.errorsCount;
}

function WatchedAssets$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(389, 1, {}, WatchedAssets$1_0);
_.onFailure = function onFailure(e){
  $onFailure(this);
}
;
_.onSuccess = function onSuccess(resource){
  ++this.this$0.successCount;
}
;
_.this$0 = null;
function $scale_2(this$static, sx, sy){
  $get(this$static.transformStack, this$static.transformStack.size - 1).scale_2(sx, sy);
  return this$static;
}

defineSeed(390, 1, {});
_.clear_0 = function clear_0(){
  $bindFramebuffer_0(this.ctx, this.fbuf, this.texWidth, this.texHeight);
  $clear_2(this.ctx);
  return this;
}
;
_.drawLine = function drawLine_0(x0, y0, x1, y1, width){
  var dx, dy, l_0, length_0, shader, temp, wx, wy;
  $bindFramebuffer_0(this.ctx, this.fbuf, this.texWidth, this.texHeight);
  if (x1 < x0) {
    temp = x0;
    x0 = x1;
    x1 = temp;
    temp = y0;
    y0 = y1;
    y1 = temp;
  }
  dx = x1 - x0;
  dy = y1 - y0;
  length_0 = Math.sqrt(dx * dx + dy * dy);
  wx = dx * (width / 2) / length_0;
  wy = dy * (width / 2) / length_0;
  l_0 = new HtmlInternalTransform_0;
  $setRotation_0(l_0, Math.atan2(dy, dx));
  l_0.matrix[4] = x0 + wy;
  l_0.matrix[5] = y0 - wx;
  $preConcatenate(l_0, $get(this.transformStack, this.transformStack.size - 1));
  shader = $quadShader(this.ctx, this.shader);
  $prepareColor(shader, combine(this.fillColor));
  shader.curCore.addQuad(l_0.matrix[0], l_0.matrix[1], l_0.matrix[2], l_0.matrix[3], l_0.matrix[4], l_0.matrix[5], 0, 0, 0, 0, length_0, 0, 1, 0, 0, width, 0, 1, length_0, width, 1, 1);
  ++shader.ctx.stats.quadsRendered;
  return this;
}
;
_.fillTriangles = function fillTriangles_0(xys, indices){
  var shader;
  $bindFramebuffer_0(this.ctx, this.fbuf, this.texWidth, this.texHeight);
  shader = this.ctx.trisShader;
  $prepareColor(shader, combine(this.fillColor));
  $addTriangles(shader, $get(this.transformStack, this.transformStack.size - 1), xys, indices);
  return this;
}
;
_.restore_0 = function restore_1(){
  $remove(this.transformStack, this.transformStack.size - 1);
  return this;
}
;
_.save_0 = function save_0(){
  $add_0(this.transformStack, $set_16(new HtmlInternalTransform_0, $get(this.transformStack, this.transformStack.size - 1)));
  return this;
}
;
_.scale_1 = function scale_3(sx, sy){
  return $scale_2(this, sx, sy);
}
;
_.setFillColor = function setFillColor_0(color){
  this.fillColor = color;
  return this;
}
;
_.transform_2 = function transform_2(m00, m01, m10, m11, tx, ty){
  $get(this.transformStack, this.transformStack.size - 1).concatenate(m00, m01, m10, m11, tx, ty, 0, 0);
  return this;
}
;
_.translate_0 = function translate_2(x, y){
  $get(this.transformStack, this.transformStack.size - 1).translate_1(x, y);
  return this;
}
;
_.ctx = null;
_.fillColor = 0;
_.shader = null;
function $bind(this$static, target){
  $glBindBuffer(this$static.gl, target, this$static.bufferId);
}

function $destroy_0(this$static){
  $deleteObjects(this$static.gl, initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [this$static.bufferId]), ($clinit_HtmlGL20$WebGLObjectType() , BUFFER));
}

function $send(this$static, target, usage){
  var buffer, byteSize, count;
  buffer = this$static.buffer_1();
  count = buffer.position_0;
  byteSize = this$static.byteSize();
  $position(buffer);
  $glBufferData(this$static.gl, target, byteSize, buffer, usage);
  return count;
}

function GL20Buffer_0(gl){
  var ids;
  this.gl = gl;
  this.bufferId = (ids = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1) , $genObjects(gl, ids, ($clinit_HtmlGL20$WebGLObjectType() , BUFFER)) , ids[0]);
}

defineSeed(391, 1, {});
_.bufferId = 0;
_.gl = null;
function $add_9(this$static, x, y){
  $put_0($put_0(this$static.buffer_0, x), y);
  return this$static;
}

function $add_10(this$static, m00, m01, m10, m11, tx, ty){
  $put_0($put_0($put_0($put_0($put_0($put_0(this$static.buffer_0, m00), m01), m10), m11), tx), ty);
  return this$static;
}

function $expand(this$static, capacity){
  var raw;
  raw = $order(allocateDirect(capacity * 4), ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER));
  this$static.buffer_0 = new FloatBuffer_0($slice(raw));
  $asIntBuffer(raw);
}

function GL20Buffer$FloatImpl_0(gl, capacity){
  GL20Buffer_0.call(this, gl);
  $expand(this, capacity);
}

defineSeed(392, 391, {}, GL20Buffer$FloatImpl_0);
_.buffer_1 = function buffer_0(){
  return this.buffer_0;
}
;
_.byteSize = function byteSize_0(){
  return this.buffer_0.position_0 * 4;
}
;
_.toString$ = function toString_36(){
  return 'floatbuf:' + this.bufferId;
}
;
_.buffer_0 = null;
function $add_11(this$static, value){
  $put_1(this$static.buffer_0, ~~(value << 16) >> 16);
  return this$static;
}

function $add_12(this$static, x, y){
  $put_1($put_1(this$static.buffer_0, ~~(x << 16) >> 16), ~~(y << 16) >> 16);
  return this$static;
}

function $drawElements_0(this$static, count){
  $glDrawElements(this$static.gl, count);
}

function $expand_0(this$static, capacity){
  this$static.buffer_0 = $asShortBuffer($order(allocateDirect(capacity * 2), ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER)));
}

function GL20Buffer$ShortImpl_0(gl, capacity){
  GL20Buffer_0.call(this, gl);
  this.buffer_0 = $asShortBuffer($order(allocateDirect(capacity * 2), ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER)));
}

defineSeed(393, 391, {}, GL20Buffer$ShortImpl_0);
_.buffer_1 = function buffer_1(){
  return this.buffer_0;
}
;
_.byteSize = function byteSize_1(){
  return this.buffer_0.position_0 * 2;
}
;
_.toString$ = function toString_37(){
  return 'shortbuf:' + this.bufferId;
}
;
_.buffer_0 = null;
function $bindFramebuffer_0(this$static, fbuf, width, height){
  if (fbuf != this$static.lastFramebuffer) {
    $checkGLError(this$static, 'bindFramebuffer');
    $flush(this$static);
    $bindFramebufferImpl(this$static, this$static.lastFramebuffer = fbuf, this$static.curFbufWidth = width, this$static.curFbufHeight = height);
  }
}

--></script>
<script><!--
function $createFramebuffer(this$static, tex){
  var fbuf;
  $flush(this$static);
  return fbuf = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1) , $genObjects(this$static.gl, fbuf, ($clinit_HtmlGL20$WebGLObjectType() , FRAME_BUFFER)) , $glBindFramebuffer(this$static.gl, fbuf[0]) , $glFramebufferTexture2D(this$static.gl, tex) , ++this$static.stats.frameBufferCreates , fbuf[0];
}

function $createQuadShader(this$static){
  var $e0, quadShader, t, maxVecs;
  if (maxVecs = this$static.gl.gl.getParameter(36347) - 3 , maxVecs >= 48) {
    try {
      quadShader = new QuadShader_0(this$static);
      quadShader.texCore = new QuadShader$QuadCore_0(quadShader, $replace_0($replace_0('uniform vec2 u_ScreenSize;\nuniform vec4 u_Data[_VEC4S_PER_QUAD_*_MAX_QUADS_];\nattribute vec3 a_Vertex;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nint index = _VEC4S_PER_QUAD_*int(a_Vertex.z);\nvec4 mat = u_Data[index+0];\nvec4 txc = u_Data[index+1];\nvec4 tcs = u_Data[index+2];\nmat3 transform = mat3(\n  mat.x, mat.y, 0,\n  mat.z, mat.w, 0,\n  txc.x, txc.y, 1);\ngl_Position = vec4(transform * vec3(a_Vertex.xy, 1.0), 1.0);\ngl_Position.xy /= u_ScreenSize.xy;\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_Vertex.xy * tcs.xy + txc.zw;\nfloat red = mod(tcs.z, 256.0);\nfloat alpha = (tcs.z - red) / 256.0;\nfloat blue = mod(tcs.w, 256.0);\nfloat green = (tcs.w - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', '_MAX_QUADS_', '' + quadShader.maxQuads), '_VEC4S_PER_QUAD_', '3'), '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_Texture;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\n  vec4 textureColor = texture2D(u_Texture, v_TexCoord);\n  textureColor.rgb *= v_Color.rgb;\n  gl_FragColor = textureColor * v_Color.a;\n}');
      quadShader.texExtras = new GLShader$TextureExtras_0(quadShader, quadShader.texCore.prog);
      quadShader.colorCore = new QuadShader$QuadCore_0(quadShader, $replace_0($replace_0('uniform vec2 u_ScreenSize;\nuniform vec4 u_Data[_VEC4S_PER_QUAD_*_MAX_QUADS_];\nattribute vec3 a_Vertex;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nint index = _VEC4S_PER_QUAD_*int(a_Vertex.z);\nvec4 mat = u_Data[index+0];\nvec4 txc = u_Data[index+1];\nvec4 tcs = u_Data[index+2];\nmat3 transform = mat3(\n  mat.x, mat.y, 0,\n  mat.z, mat.w, 0,\n  txc.x, txc.y, 1);\ngl_Position = vec4(transform * vec3(a_Vertex.xy, 1.0), 1.0);\ngl_Position.xy /= u_ScreenSize.xy;\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_Vertex.xy * tcs.xy + txc.zw;\nfloat red = mod(tcs.z, 256.0);\nfloat alpha = (tcs.z - red) / 256.0;\nfloat blue = mod(tcs.w, 256.0);\nfloat green = (tcs.w - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', '_MAX_QUADS_', '' + quadShader.maxQuads), '_VEC4S_PER_QUAD_', '3'), '#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 v_Color;\nvoid main(void) {\n  gl_FragColor = vec4(v_Color.rgb, 1) * v_Color.a;\n}');
      quadShader.colorExtras = new GLShader$ColorExtras_0;
      return quadShader;
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$Throwable)) {
        t = $e0;
        $warn(this$static.platform.log_0, 'Failed to create QuadShader: ' + t);
      }
       else 
        throw $e0;
    }
  }
  return new IndexedTrisShader_0(this$static);
}

function $flush(this$static){
  if (this$static.curShader) {
    $checkGLError(this$static, 'flush()');
    $flush_0(this$static.curShader);
    this$static.curShader = null;
  }
}

function $popFramebuffer(this$static){
  $bindFramebuffer_0(this$static, this$static.pushedFramebuffer, this$static.pushedWidth, this$static.pushedHeight);
  this$static.pushedFramebuffer = -1;
}

function $pushFramebuffer(this$static, fbuf, width, height){
  this$static.pushedFramebuffer = this$static.lastFramebuffer;
  this$static.pushedWidth = this$static.curFbufWidth;
  this$static.pushedHeight = this$static.curFbufHeight;
  $bindFramebuffer_0(this$static, fbuf, width, height);
}

function $quadShader(this$static, custom){
  return !custom?this$static.quadShader:custom;
}

function $setSize(this$static, width, height){
  this$static.viewWidth = width;
  this$static.viewHeight = height;
  this$static.curFbufWidth = this$static.defaultFbufWidth = iceil($scaled(this$static.scale_0, width));
  this$static.curFbufHeight = this$static.defaultFbufHeight = iceil($scaled(this$static.scale_0, height));
  $bindFramebufferImpl(this$static, 0, this$static.defaultFbufWidth, this$static.defaultFbufHeight);
}

function $useShader(this$static, shader, forceFlush){
  if (this$static.curShader == shader && !forceFlush)
    return false;
  $checkGLError(this$static, 'useShader');
  $flush(this$static);
  this$static.curShader = shader;
  return true;
}

defineSeed(395, 1, {});
_.createTransform = function createTransform(){
  return new StockInternalTransform_0;
}
;
_.curFbufHeight = 0;
_.curFbufWidth = 0;
_.curShader = null;
_.defaultFbufHeight = 0;
_.defaultFbufWidth = 0;
_.epoch = 0;
_.lastFramebuffer = 0;
_.platform = null;
_.pushedFramebuffer = -1;
_.pushedHeight = 0;
_.pushedWidth = 0;
_.scale_0 = null;
_.viewHeight = 0;
_.viewWidth = 0;
function $bindFramebufferImpl(this$static, fbuf, width, height){
  $glBindFramebuffer(this$static.gl, fbuf);
  $glViewport(this$static.gl, width, height);
  ++this$static.stats.frameBufferBinds;
}

function $bindTexture_0(this$static, tex){
  $glBindTexture(this$static.gl, tex);
  ++this$static.stats.texBinds;
}

function $checkGLError(this$static, op){
  var error;
  if (this$static.checkErrors) {
    while ((error = this$static.gl.gl.getError()) != 0) {
      $error(platform_1.log_0, Lplayn_html_HtmlGLContext_2_classLit.typeName + ' -- ' + op + ': glError ' + error);
    }
  }
}

function $clear_2(this$static){
  $glClearColor(this$static.gl, 0, 0, 0, 0);
  $glClear(this$static.gl, 16384);
}

function $createFloatBuffer(this$static, capacity){
  return new GL20Buffer$FloatImpl_0(this$static.gl, capacity);
}

function $createProgram(this$static, vertShader, fragShader){
  ++this$static.stats.shaderCreates;
  return new GL20Program_0(this$static, this$static.gl, vertShader, fragShader);
}

function $createShortBuffer(this$static, capacity){
  return new GL20Buffer$ShortImpl_0(this$static.gl, capacity);
}

function $createTexture(this$static, width, height, repeatX, repeatY, mm){
  var tex;
  tex = $createTexture_0(this$static, repeatX, repeatY, mm);
  $glTexImage2D(this$static.gl, width, height);
  return tex;
}

function $createTexture_0(this$static, repeatX, repeatY, mipmaps){
  var tex;
  tex = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1);
  $genObjects(this$static.gl, tex, ($clinit_HtmlGL20$WebGLObjectType() , TEXTURE));
  $glBindTexture(this$static.gl, tex[0]);
  $glTexParameteri(this$static.gl, 10240, this$static.magFilter);
  $glTexParameteri(this$static.gl, 10241, mipmapify(this$static.minFilter, mipmaps));
  $glTexParameteri(this$static.gl, 10242, repeatX?10497:33071);
  $glTexParameteri(this$static.gl, 10243, repeatY?10497:33071);
  ++this$static.stats.texCreates;
  return tex[0];
}

function $deleteFramebuffer_0(this$static, fbuf){
  $deleteObjects(this$static.gl, initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [fbuf]), ($clinit_HtmlGL20$WebGLObjectType() , FRAME_BUFFER));
}

function $destroyTexture(this$static, tex){
  $flush(this$static);
  $deleteObjects(this$static.gl, initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [tex]), ($clinit_HtmlGL20$WebGLObjectType() , TEXTURE));
}

function $generateMipmap(this$static, tex){
  $glBindTexture(this$static.gl, tex);
  this$static.gl.gl.generateMipmap(3553);
}

function $paint(this$static, rootLayer){
  if (rootLayer.impl.children.size > 0) {
    $checkGLError(this$static, 'paint');
    $bindFramebuffer_0(this$static, 0, this$static.defaultFbufWidth, this$static.defaultFbufHeight);
    $glClear(this$static.gl, 16640);
    $paint_0(rootLayer, this$static.rootXform, -1, null);
    $useShader(this$static, null, false);
  }
  ++this$static.stats.frames_0;
}

function $setTextureFilter(this$static){
  this$static.minFilter = toGL(0);
  this$static.magFilter = toGL(1);
}

function GL20Context_0(platform, gl, checkErrors){
  this.stats = new GLContext$Stats_0;
  new ArrayList_0;
  this.scale_0 = new Scale_0(1);
  this.platform = platform;
  this.gl = gl;
  this.checkErrors = checkErrors;
  this.rootXform = this.createTransform();
  this.rootXform.uniformScale(1);
}

function mipmapify(filter, mipmaps){
  if (!mipmaps)
    return filter;
  switch (filter) {
    case 9728:
      return 9984;
    case 9729:
      return 9985;
    default:return filter;
  }
}

function toGL(filter){
  switch (filter) {
    default:case 0:
      return 9729;
    case 1:
      return 9728;
  }
}

defineSeed(394, 395, {});
_.checkErrors = false;
_.gl = null;
_.magFilter = 9729;
_.minFilter = 9729;
_.quadShader = null;
_.rootXform = null;
_.trisShader = null;
function $bind_0(this$static){
  $glUseProgram(this$static.gl, this$static.program);
}

function $compileShader_0(this$static, type, shaderSource){
  var compiled, log, shader;
  shader = $glCreateShader(this$static.gl, type);
  if (shader == 0)
    throw new RuntimeException_1('Failed to create shader (' + type + '): ' + this$static.gl.gl.getError());
  $glShaderSource(this$static.gl, shader, shaderSource);
  $glCompileShader(this$static.gl, shader);
  compiled = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1);
  $glGetShaderiv(this$static.gl, shader, compiled);
  if (compiled[0] == 0) {
    log = $glGetShaderInfoLog(this$static.gl, shader);
    $deleteObject(this$static.gl, shader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
    throw new RuntimeException_1('Failed to compile shader (' + type + '): ' + log);
  }
  return shader;
}

function $destroy_1(this$static){
  $deleteObject(this$static.gl, this$static.vertexShader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
  $deleteObject(this$static.gl, this$static.fragmentShader, SHADER);
  $deleteObject(this$static.gl, this$static.program, PROGRAM);
}

function $getAttrib(this$static, name_0, size, type){
  var loc;
  loc = $glGetAttribLocation(this$static.gl, this$static.program, name_0);
  return loc < 0?null:new GL20Program$10_0(this$static, loc, size, type);
}

function $getUniform2f(this$static){
  var loc;
  loc = $glGetUniformLocation(this$static.gl, this$static.program, 'u_ScreenSize');
  return loc < 0?null:new GL20Program$2_0(this$static, loc);
}

function $getUniform4fv(this$static){
  var loc;
  loc = $glGetUniformLocation(this$static.gl, this$static.program, 'u_Data');
  return loc < 0?null:new GL20Program$8_0(this$static, loc);
}

function GL20Program_0(ctx, gl, vertexSource, fragmentSource){
  var fragmentShader, linkStatus, log, program, vertexShader;
  this.gl = gl;
  program = 0;
  vertexShader = 0;
  fragmentShader = 0;
  try {
    program = $createObject(gl, gl.gl.createProgram(), ($clinit_HtmlGL20$WebGLObjectType() , PROGRAM));
    if (program == 0) {
      throw new RuntimeException_1('Failed to create program: ' + gl.gl.getError());
    }
    vertexShader = $compileShader_0(this, 35633, vertexSource);
    $attachShader(gl.gl, gl.webGLObjects[program], gl.webGLObjects[vertexShader]);
    $checkGLError(ctx, 'Attached vertex shader');
    fragmentShader = $compileShader_0(this, 35632, fragmentSource);
    $attachShader(gl.gl, gl.webGLObjects[program], gl.webGLObjects[fragmentShader]);
    $checkGLError(ctx, 'Attached fragment shader');
    $linkProgram(gl.gl, gl.webGLObjects[program]);
    linkStatus = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1);
    linkStatus[0] = $getProgramParameterb(gl.gl, gl.webGLObjects[program], 35714)?1:0;
    if (linkStatus[0] == 0) {
      log = $getProgramInfoLog(gl.gl, gl.webGLObjects[program]);
      $deleteObject(gl, program, PROGRAM);
      throw new RuntimeException_1('Failed to link program: ' + log);
    }
    this.program = program;
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    program = vertexShader = fragmentShader = 0;
  }
   finally {
    program != 0 && $deleteObject(gl, program, ($clinit_HtmlGL20$WebGLObjectType() , PROGRAM));
    vertexShader != 0 && $deleteObject(gl, vertexShader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
    fragmentShader != 0 && $deleteObject(gl, fragmentShader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
  }
}

defineSeed(396, 1, {}, GL20Program_0);
_.fragmentShader = 0;
_.gl = null;
_.program = 0;
_.vertexShader = 0;
function $bind_1(this$static, stride, offset){
  $glEnableVertexAttribArray(this$static.this$0.gl, this$static.val$loc);
  $glVertexAttribPointer(this$static.this$0.gl, this$static.val$loc, this$static.val$size, this$static.val$type, stride, offset);
}

function GL20Program$10_0(this$0, val$loc, val$size, val$type){
  this.this$0 = this$0;
  this.val$loc = val$loc;
  this.val$size = val$size;
  this.val$type = val$type;
}

defineSeed(397, 1, {}, GL20Program$10_0);
_.this$0 = null;
_.val$loc = 0;
_.val$size = 0;
_.val$type = 0;
function $bind_2(this$static, a, b){
  $glUniform2f(this$static.this$0.gl, this$static.val$loc, a, b);
}

function GL20Program$2_0(this$0, val$loc){
  this.this$0 = this$0;
  this.val$loc = val$loc;
}

defineSeed(398, 1, {}, GL20Program$2_0);
_.this$0 = null;
_.val$loc = 0;
function $bind_3(this$static){
  $glUniform1i(this$static.this$0.gl, this$static.val$loc);
}

function GL20Program$5_0(this$0, val$loc){
  this.this$0 = this$0;
  this.val$loc = val$loc;
}

defineSeed(399, 1, {}, GL20Program$5_0);
_.this$0 = null;
_.val$loc = 0;
function $bind_4(this$static, data, count){
  var buffer;
  buffer = data.buffer_0;
  $position(buffer);
  $glUniform4fv(this$static.this$0.gl, this$static.val$loc, count, buffer);
}

function GL20Program$8_0(this$0, val$loc){
  this.this$0 = this$0;
  this.val$loc = val$loc;
}

defineSeed(400, 1, {}, GL20Program$8_0);
_.this$0 = null;
_.val$loc = 0;
function GLContext$Stats_0(){
}

defineSeed(401, 1, {}, GLContext$Stats_0);
_.frameBufferBinds = 0;
_.frameBufferCreates = 0;
_.frames_0 = 0;
_.quadsRendered = 0;
_.shaderBinds = 0;
_.shaderCreates = 0;
_.shaderFlushes = 0;
_.texBinds = 0;
_.texCreates = 0;
_.trisRendered = 0;
function $addQuad(this$static, local, left, top_0, right, bottom, sl, st, sr, sb){
  this$static.curCore.addQuad(local.matrix[0], local.matrix[1], local.matrix[2], local.matrix[3], local.matrix[4], local.matrix[5], left, top_0, sl, st, right, top_0, sr, st, left, bottom, sl, sb, right, bottom, sr, sb);
  ++this$static.ctx.stats.quadsRendered;
}

function $addTriangles(this$static, local, xys, indices){
  this$static.curCore.addTriangles(local.m00_0(), local.m01_0(), local.m10_0(), local.m11_0(), local.tx_0(), local.ty_0(), xys, 1, 1, indices);
  this$static.ctx.stats.trisRendered += ~~(indices.length / 3);
}

function $clearProgram(this$static){
  if (this$static.texCore) {
    this$static.texCore.destroy();
    this$static.texCore = null;
    this$static.texExtras = null;
  }
  if (this$static.colorCore) {
    this$static.colorCore.destroy();
    this$static.colorCore = null;
    this$static.colorExtras = null;
  }
  this$static.curCore = null;
  this$static.curExtras = null;
}

function $flush_0(this$static){
  this$static.curExtras.willFlush();
  this$static.curCore.flush();
  ++this$static.ctx.stats.shaderFlushes;
}

function $prepareColor(this$static, tint){
  var justActivated;
  if (this$static.colorEpoch != this$static.ctx.epoch) {
    this$static.colorCore = null;
    this$static.colorExtras = null;
  }
  if (!this$static.colorCore) {
    this$static.colorEpoch = this$static.ctx.epoch;
    this$static.colorCore = this$static.createColorCore();
    this$static.colorExtras = new GLShader$ColorExtras_0;
  }
  justActivated = $useShader(this$static.ctx, this$static, this$static.curCore != this$static.colorCore);
  if (justActivated) {
    this$static.curCore = this$static.colorCore;
    this$static.curExtras = this$static.colorExtras;
    this$static.colorCore.activate(this$static.ctx.curFbufWidth, this$static.ctx.curFbufHeight);
    ++this$static.ctx.stats.shaderBinds;
  }
  this$static.colorCore.prepare(tint, justActivated);
  return this$static;
}

function $prepareTexture(this$static, tex, tint){
  var justActivated;
  if (this$static.texEpoch != this$static.ctx.epoch) {
    this$static.texCore = null;
    this$static.texExtras = null;
  }
  if (!this$static.texCore) {
    this$static.texEpoch = this$static.ctx.epoch;
    this$static.texCore = this$static.createTextureCore();
    this$static.texExtras = new GLShader$TextureExtras_0(this$static, this$static.texCore.prog);
  }
  justActivated = $useShader(this$static.ctx, this$static, this$static.curCore != this$static.texCore);
  if (justActivated) {
    this$static.curCore = this$static.texCore;
    this$static.curExtras = this$static.texExtras;
    this$static.texCore.activate(this$static.ctx.curFbufWidth, this$static.ctx.curFbufHeight);
    ++this$static.ctx.stats.shaderBinds;
  }
  this$static.texCore.prepare(tint, justActivated);
  $prepare(this$static.texExtras, tex, justActivated);
  return this$static;
}

defineSeed(402, 1, {});
_.colorCore = null;
_.colorEpoch = 0;
_.colorExtras = null;
_.ctx = null;
_.curCore = null;
_.curExtras = null;
_.texCore = null;
_.texEpoch = 0;
_.texExtras = null;
defineSeed(404, 1, {});
_.willFlush = function willFlush(){
}
;
function GLShader$ColorExtras_0(){
}

defineSeed(403, 404, {}, GLShader$ColorExtras_0);
function GLShader$Core_0(this$0, vertShader, fragShader){
  this.prog = $createProgram(this$0.ctx, vertShader, fragShader);
}

defineSeed(405, 1, {});
_.addTriangles = function addTriangles(m00, m01, m10, m11, tx, ty, xys, tw, th, indices){
  throw new UnsupportedOperationException_1('Triangles not supported by this shader');
}
;
_.destroy = function destroy(){
  $destroy_1(this.prog);
}
;
_.prog = null;
function $prepare(this$static, tex, justActivated){
  var stateChanged;
  $checkGLError(this$static.this$0.ctx, 'textureShader.prepare start');
  stateChanged = tex != this$static.lastTex;
  if (!justActivated && stateChanged) {
    $flush_0(this$static.this$0);
    $checkGLError(this$static.this$0.ctx, 'textureShader.prepare flush');
  }
  if (stateChanged) {
    this$static.lastTex = tex;
    $checkGLError(this$static.this$0.ctx, 'textureShader.prepare end');
  }
  if (justActivated) {
    this$static.this$0.ctx.gl.gl.activeTexture(33984);
    $bind_3(this$static.uTexture);
  }
}

function GLShader$TextureExtras_0(this$0, prog){
  var loc;
  this.this$0 = this$0;
  this.uTexture = (loc = $glGetUniformLocation(prog.gl, prog.program, 'u_Texture') , loc < 0?null:new GL20Program$5_0(prog, loc));
}

defineSeed(406, 404, {}, GLShader$TextureExtras_0);
_.willFlush = function willFlush_0(){
  $bindTexture_0(this.this$0.ctx, this.lastTex);
}
;
_.lastTex = 0;
_.this$0 = null;
_.uTexture = null;
function nextPowerOfTwo(x){
  var bit, count, highest, i;
  bit = 32768;
  highest = -1;
  count = 0;
  for (i = 15; i >= 0; --i , bit >>= 1) {
    if ((x & bit) != 0) {
      ++count;
      highest == -1 && (highest = i);
    }
  }
  if (count <= 1) {
    return 0;
  }
  return 1 << highest + 1;
}

function LayerGL_0(){
  AbstractLayer_0.call(this, new HtmlInternalTransform_0);
  this.savedLocal = new HtmlInternalTransform_0;
}

defineSeed(409, 343, {});
_.savedLocal = null;
function $paint_0(this$static, curTransform, curTint, curShader){
  if (!$isSet(this$static, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  $render(this$static, ($set_16(this$static.savedLocal, curTransform) , $concatenate_0(this$static.savedLocal, $transform_0(this$static), this$static.originX, this$static.originY)), curTint, curShader);
}

function $render(this$static, xform, curTint, shader){
  var children, ii, ll;
  children = this$static.impl.children;
  for (ii = 0 , ll = children.size; ii < ll; ++ii) {
    (checkIndex(ii, children.size) , children.array[ii]).paint(xform, curTint, shader);
  }
}

function GroupLayerGL_0(){
  LayerGL_0.call(this);
  this.impl = new GroupLayerImpl_0;
}

defineSeed(408, 409, {}, GroupLayerGL_0);
_.add_1 = function add_7(layer){
  $add_8(this.impl, this, layer);
}
;
_.hitTestDefault = function hitTestDefault_0(p){
  return $hitTest(this.impl, this, p);
}
;
_.onAdd = function onAdd_0(){
  $onAdd(this);
  $onAdd_0(this.impl);
}
;
_.onRemove = function onRemove_0(){
  $onRemove(this.impl);
}
;
_.paint = function paint(curTransform, curTint, curShader){
  $paint_0(this, curTransform, curTint, curShader);
}
;
_.remove_4 = function remove_18(layer){
  $remove_10(this.impl, layer);
}
;
function $clearTexture(this$static){
  if (this$static.tex > 0) {
    $destroyTexture(this$static.ctx, this$static.tex);
    this$static.tex = 0;
  }
  if (this$static.reptex > 0) {
    $destroyTexture(this$static.ctx, this$static.reptex);
    this$static.reptex = 0;
  }
}

function $draw(this$static, shader, xform, dw, dh, repeatX, repeatY, tint){
  var sb, sr, tex, texHeight, texWidth;
  tex = $ensureTexture(this$static, repeatX, repeatY);
  if (tex > 0) {
    sr = repeatX?dw:!this$static.img?0:$invScaled(this$static.scale_0, this$static.img.width);
    sb = repeatY?dh:!this$static.img?0:$invScaled(this$static.scale_0, this$static.img.height);
    texWidth = !this$static.img?0:$invScaled(this$static.scale_0, this$static.img.width);
    texHeight = !this$static.img?0:$invScaled(this$static.scale_0, this$static.img.height);
    $addQuad($prepareTexture($quadShader(this$static.ctx, shader), tex, tint), xform, 0, 0, dw, dh, 0 / texWidth, 0 / texHeight, sr / texWidth, sb / texHeight);
  }
}

function $ensureTexture(this$static, repeatX, repeatY){
  if (this$static.img.complete) {
    if (repeatX || repeatY || this$static.mipmapped) {
      $scaleTexture(this$static, repeatX, repeatY);
      return this$static.reptex;
    }
     else {
      $loadTexture(this$static);
      return this$static.tex;
    }
  }
   else {
    return 0;
  }
}

function $loadTexture(this$static){
  if (this$static.tex > 0)
    return;
  this$static.tex = $createTexture_0(this$static.ctx, false, false, false);
  $updateTexture_0(this$static, this$static.tex);
}

function $release(this$static){
  --this$static.refs == 0 && !!this$static.ctx && $clearTexture(this$static);
}

function $scaleTexture(this$static, repeatX, repeatY){
  var fbuf, height, scaledHeight, scaledWidth, shader, width;
  if (this$static.reptex > 0)
    return;
  scaledWidth = $scaledCeil(this$static.scale_0, !this$static.img?0:$invScaled(this$static.scale_0, this$static.img.width));
  scaledHeight = $scaledCeil(this$static.scale_0, !this$static.img?0:$invScaled(this$static.scale_0, this$static.img.height));
  width = nextPowerOfTwo(scaledWidth);
  height = nextPowerOfTwo(scaledHeight);
  if (width == 0 && height == 0) {
    this$static.reptex = $createTexture(this$static.ctx, scaledWidth, scaledHeight, repeatX, repeatY, this$static.mipmapped);
    $updateTexture_0(this$static, this$static.reptex);
    this$static.mipmapped && $generateMipmap(this$static.ctx, this$static.reptex);
    return;
  }
  $loadTexture(this$static);
  width == 0 && (width = scaledWidth);
  height == 0 && (height = scaledHeight);
  this$static.reptex = $createTexture(this$static.ctx, width, height, repeatX, repeatY, this$static.mipmapped);
  fbuf = $createFramebuffer(this$static.ctx, this$static.reptex);
  $pushFramebuffer(this$static.ctx, fbuf, width, height);
  try {
    $clear_2(this$static.ctx);
    shader = $prepareTexture($quadShader(this$static.ctx, null), this$static.tex, -1);
    $addQuad(shader, new HtmlInternalTransform_0, 0, height, width, 0, 0, 0, 1, 1);
    $flush_0(shader);
    this$static.mipmapped && $generateMipmap(this$static.ctx, this$static.reptex);
  }
   finally {
    $popFramebuffer(this$static.ctx);
    $deleteFramebuffer_0(this$static.ctx, fbuf);
  }
}

defineSeed(410, 1, {});
_.ctx = null;
_.mipmapped = false;
_.refs = 0;
_.reptex = 0;
_.scale_0 = null;
_.tex = 0;
function $setImage(this$static, img){
  if (this$static.img == img)
    return;
  !!this$static.img && $release(this$static.img);
  this$static.img = img;
  !!this$static.img && ++this$static.img.refs;
}

function ImageLayerGL_0(img){
  LayerGL_0.call(this);
  $setImage(this, img);
}

defineSeed(411, 409, {}, ImageLayerGL_0);
_.height_1 = function height_1(){
  return this.heightSet?this.height_0:$height(this.img);
}
;
_.paint = function paint_0(curTransform, curTint, curShader){
  if (!$isSet(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1)) || !this.img)
    return;
  $draw(this.img, curShader, ($set_16(this.savedLocal, curTransform) , $concatenate_0(this.savedLocal, $transform_0(this), this.originX, this.originY)), this.widthSet?this.width_0:$width(this.img), this.heightSet?this.height_0:$height(this.img), this.repeatX, this.repeatY, curTint);
}
;
_.width_1 = function width_1(){
  return this.widthSet?this.width_0:$width(this.img);
}
;
_.height_0 = 0;
_.heightSet = false;
_.img = null;
_.repeatX = false;
_.repeatY = false;
_.width_0 = 0;
_.widthSet = false;
function IndexedTrisShader_0(ctx){
  this.ctx = ctx;
}

defineSeed(412, 402, {}, IndexedTrisShader_0);
_.createColorCore = function createColorCore(){
  return new IndexedTrisShader$ITCore_0(this, '#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 v_Color;\nvoid main(void) {\n  gl_FragColor = vec4(v_Color.rgb, 1) * v_Color.a;\n}');
}
;
_.createTextureCore = function createTextureCore(){
  return new IndexedTrisShader$ITCore_0(this, '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_Texture;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\n  vec4 textureColor = texture2D(u_Texture, v_TexCoord);\n  textureColor.rgb *= v_Color.rgb;\n  gl_FragColor = textureColor * v_Color.a;\n}');
}
;
_.toString$ = function toString_38(){
  return 'itris/' + this.texCore + '/' + this.colorCore;
}
;
function $addExtraVertexAttribs(this$static, vertices){
  $add_9(vertices, this$static.arTint, this$static.gbTint);
}

function $beginPrimitive(this$static, vertexCount, elemCount){
  var availElems, availVerts, elems, vertIdx, verts;
  vertIdx = ~~(this$static.vertices.buffer_0.position_0 / 12);
  verts = vertIdx + vertexCount;
  elems = this$static.elements.buffer_0.position_0 + elemCount;
  availVerts = ~~(this$static.vertices.buffer_0.capacity / 12);
  availElems = this$static.elements.buffer_0.capacity;
  if (verts > availVerts || elems > availElems) {
    $flush_0(this$static.this$0);
    verts > availVerts && $expandVerts(this$static, verts);
    elems > availElems && $expandElems(this$static, elems);
    return 0;
  }
  return vertIdx;
}

function $expandElems(this$static, elemCount){
  var newElems;
  newElems = this$static.elements.buffer_0.capacity;
  while (newElems < elemCount)
    newElems += 96;
  $expand_0(this$static.elements, newElems);
}

function $expandVerts(this$static, vertCount){
  var newVerts;
  newVerts = ~~(this$static.vertices.buffer_0.capacity / 12);
  while (newVerts < vertCount)
    newVerts += 64;
  $expand(this$static.vertices, newVerts * 12);
}

function IndexedTrisShader$ITCore_0(this$0, fragShader){
  this.this$0 = this$0;
  GLShader$Core_0.call(this, this$0, 'uniform vec2 u_ScreenSize;\nattribute vec4 a_Matrix;\nattribute vec2 a_Translation;\nattribute vec2 a_Position;\nattribute vec2 a_TexCoord;\nattribute vec2 a_Color;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nmat3 transform = mat3(\n  a_Matrix[0], a_Matrix[1], 0,\n  a_Matrix[2], a_Matrix[3], 0,\n  a_Translation[0], a_Translation[1], 1);\ngl_Position = vec4(transform * vec3(a_Position, 1.0), 1);\ngl_Position.xy /= (u_ScreenSize.xy / 2.0);\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_TexCoord;\nfloat red = mod(a_Color.x, 256.0);\nfloat alpha = (a_Color.x - red) / 256.0;\nfloat blue = mod(a_Color.y, 256.0);\nfloat green = (a_Color.y - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', fragShader);
  this.uScreenSize = $getUniform2f(this.prog);
  this.aMatrix = $getAttrib(this.prog, 'a_Matrix', 4, 5126);
  this.aTranslation = $getAttrib(this.prog, 'a_Translation', 2, 5126);
  this.aPosition = $getAttrib(this.prog, 'a_Position', 2, 5126);
  this.aTexCoord = $getAttrib(this.prog, 'a_TexCoord', 2, 5126);
  this.aColor = $getAttrib(this.prog, 'a_Color', 2, 5126);
  this.vertices = $createFloatBuffer(this$0.ctx, 768);
  this.elements = $createShortBuffer(this$0.ctx, 96);
}

defineSeed(413, 405, {}, IndexedTrisShader$ITCore_0);
_.activate = function activate(fbufWidth, fbufHeight){
  $bind_0(this.prog);
  $bind_2(this.uScreenSize, fbufWidth, fbufHeight);
  $bind(this.vertices, 34962);
  $bind_1(this.aMatrix, 48, 0);
  $bind_1(this.aTranslation, 48, 16);
  $bind_1(this.aPosition, 48, 24);
  !!this.aTexCoord && $bind_1(this.aTexCoord, 48, 32);
  $bind_1(this.aColor, 48, 40);
  $bind(this.elements, 34963);
  $checkGLError(this.this$0.ctx, 'Shader.prepare bind');
}
;
--></script>
<script><!--
_.addQuad = function addQuad(m00, m01, m10, m11, tx, ty, x1, y1, sx1, sy1, x2, y2, sx2, sy2, x3, y3, sx3, sy3, x4, y4, sx4, sy4){
  var vertIdx;
  vertIdx = $beginPrimitive(this, 4, 6);
  $add_9($add_9($add_10(this.vertices, m00, m01, m10, m11, tx, ty), x1, y1), sx1, sy1);
  $addExtraVertexAttribs(this, this.vertices);
  $add_9($add_9($add_10(this.vertices, m00, m01, m10, m11, tx, ty), x2, y2), sx2, sy2);
  $addExtraVertexAttribs(this, this.vertices);
  $add_9($add_9($add_10(this.vertices, m00, m01, m10, m11, tx, ty), x3, y3), sx3, sy3);
  $addExtraVertexAttribs(this, this.vertices);
  $add_9($add_9($add_10(this.vertices, m00, m01, m10, m11, tx, ty), x4, y4), sx4, sy4);
  $addExtraVertexAttribs(this, this.vertices);
  $add_11(this.elements, vertIdx);
  $add_11(this.elements, vertIdx + 1);
  $add_11(this.elements, vertIdx + 2);
  $add_11(this.elements, vertIdx + 1);
  $add_11(this.elements, vertIdx + 3);
  $add_11(this.elements, vertIdx + 2);
}
;
_.addTriangles = function addTriangles_0(m00, m01, m10, m11, tx, ty, xys, tw, th, indices){
  var ii, ll, vertIdx, x, y;
  vertIdx = $beginPrimitive(this, ~~(xys.length / 2), indices.length);
  for (ii = 0 , ll = xys.length; ii < ll; ii += 2) {
    x = xys[ii];
    y = xys[ii + 1];
    $add_9($add_9($add_10(this.vertices, m00, m01, m10, m11, tx, ty), x, y), x / tw, y / th);
    $addExtraVertexAttribs(this, this.vertices);
  }
  for (ii = 0 , ll = indices.length; ii < ll; ++ii)
    $add_11(this.elements, vertIdx + indices[ii]);
}
;
_.destroy = function destroy_0(){
  $destroy_1(this.prog);
  $destroy_0(this.vertices);
  $destroy_0(this.elements);
}
;
_.flush = function flush(){
  var elems;
  if (this.vertices.buffer_0.position_0 == 0)
    return;
  $checkGLError(this.this$0.ctx, 'Shader.flush');
  $send(this.vertices, 34962, 35040);
  elems = $send(this.elements, 34963, 35040);
  $checkGLError(this.this$0.ctx, 'Shader.flush BufferData');
  $drawElements_0(this.elements, elems);
  $checkGLError(this.this$0.ctx, 'Shader.flush DrawElements');
}
;
_.prepare = function prepare(tint, justActivated){
  this.arTint = ~~tint >> 16 & 65535;
  this.gbTint = tint & 65535;
}
;
_.toString$ = function toString_39(){
  return 'cq=' + ~~(this.elements.buffer_0.capacity / 6);
}
;
_.aColor = null;
_.aMatrix = null;
_.aPosition = null;
_.aTexCoord = null;
_.aTranslation = null;
_.arTint = 0;
_.elements = null;
_.gbTint = 0;
_.this$0 = null;
_.uScreenSize = null;
_.vertices = null;
function QuadShader_0(ctx){
  var maxVecs;
  this.ctx = ctx;
  maxVecs = ctx.gl.gl.getParameter(36347) - 3;
  if (maxVecs < 3)
    throw new RuntimeException_1('GL_MAX_VERTEX_UNIFORM_VECTORS too low: have ' + maxVecs + ', need at least 3');
  this.maxQuads = ~~(maxVecs / 3);
}

defineSeed(414, 402, {}, QuadShader_0);
_.createColorCore = function createColorCore_0(){
  return new QuadShader$QuadCore_0(this, $replace_0($replace_0('uniform vec2 u_ScreenSize;\nuniform vec4 u_Data[_VEC4S_PER_QUAD_*_MAX_QUADS_];\nattribute vec3 a_Vertex;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nint index = _VEC4S_PER_QUAD_*int(a_Vertex.z);\nvec4 mat = u_Data[index+0];\nvec4 txc = u_Data[index+1];\nvec4 tcs = u_Data[index+2];\nmat3 transform = mat3(\n  mat.x, mat.y, 0,\n  mat.z, mat.w, 0,\n  txc.x, txc.y, 1);\ngl_Position = vec4(transform * vec3(a_Vertex.xy, 1.0), 1.0);\ngl_Position.xy /= u_ScreenSize.xy;\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_Vertex.xy * tcs.xy + txc.zw;\nfloat red = mod(tcs.z, 256.0);\nfloat alpha = (tcs.z - red) / 256.0;\nfloat blue = mod(tcs.w, 256.0);\nfloat green = (tcs.w - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', '_MAX_QUADS_', '' + this.maxQuads), '_VEC4S_PER_QUAD_', '3'), '#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 v_Color;\nvoid main(void) {\n  gl_FragColor = vec4(v_Color.rgb, 1) * v_Color.a;\n}');
}
;
_.createTextureCore = function createTextureCore_0(){
  return new QuadShader$QuadCore_0(this, $replace_0($replace_0('uniform vec2 u_ScreenSize;\nuniform vec4 u_Data[_VEC4S_PER_QUAD_*_MAX_QUADS_];\nattribute vec3 a_Vertex;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nint index = _VEC4S_PER_QUAD_*int(a_Vertex.z);\nvec4 mat = u_Data[index+0];\nvec4 txc = u_Data[index+1];\nvec4 tcs = u_Data[index+2];\nmat3 transform = mat3(\n  mat.x, mat.y, 0,\n  mat.z, mat.w, 0,\n  txc.x, txc.y, 1);\ngl_Position = vec4(transform * vec3(a_Vertex.xy, 1.0), 1.0);\ngl_Position.xy /= u_ScreenSize.xy;\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_Vertex.xy * tcs.xy + txc.zw;\nfloat red = mod(tcs.z, 256.0);\nfloat alpha = (tcs.z - red) / 256.0;\nfloat blue = mod(tcs.w, 256.0);\nfloat green = (tcs.w - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', '_MAX_QUADS_', '' + this.maxQuads), '_VEC4S_PER_QUAD_', '3'), '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_Texture;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\n  vec4 textureColor = texture2D(u_Texture, v_TexCoord);\n  textureColor.rgb *= v_Color.rgb;\n  gl_FragColor = textureColor * v_Color.a;\n}');
}
;
_.toString$ = function toString_40(){
  return 'quad/' + this.maxQuads;
}
;
_.maxQuads = 0;
function $addExtraData(this$static, data){
  $add_9(data, this$static.arTint, this$static.gbTint);
}

function QuadShader$QuadCore_0(this$0, vertShader, fragShader){
  var base, ii;
  this.this$0 = this$0;
  GLShader$Core_0.call(this, this$0, vertShader, fragShader);
  this.data = $createFloatBuffer(this$0.ctx, this$0.maxQuads * 3 * 4);
  this.uScreenSize = $getUniform2f(this.prog);
  this.uData = $getUniform4fv(this.prog);
  this.aVertex = $getAttrib(this.prog, 'a_Vertex', 3, 5122);
  this.vertices = $createShortBuffer(this$0.ctx, this$0.maxQuads * 4 * 3);
  this.elements = $createShortBuffer(this$0.ctx, this$0.maxQuads * 6);
  for (ii = 0; ii < this$0.maxQuads; ++ii) {
    $add_11($add_12(this.vertices, 0, 0), ii);
    $add_11($add_12(this.vertices, 1, 0), ii);
    $add_11($add_12(this.vertices, 0, 1), ii);
    $add_11($add_12(this.vertices, 1, 1), ii);
    base = ii * 4;
    $add_11($add_11($add_11(this.elements, base), base + 1), base + 2);
    $add_11($add_11($add_11(this.elements, base + 1), base + 3), base + 2);
  }
  $bind(this.vertices, 34962);
  $send(this.vertices, 34962, 35044);
  $bind(this.elements, 34963);
  $send(this.elements, 34963, 35044);
}

defineSeed(415, 405, {}, QuadShader$QuadCore_0);
_.activate = function activate_0(fbufWidth, fbufHeight){
  $bind_0(this.prog);
  $bind_2(this.uScreenSize, fbufWidth / 2, fbufHeight / 2);
  $bind(this.vertices, 34962);
  $bind_1(this.aVertex, 0, 0);
  $bind(this.elements, 34963);
}
;
_.addQuad = function addQuad_0(m00, m01, m10, m11, tx, ty, x1, y1, sx1, sy1, x2, y2, sx2, sy2, x3, y3, sx3, sy3, x4, y4, sx4, sy4){
  var dh, dw;
  dw = x2 - x1;
  dh = y3 - y1;
  $add_10(this.data, m00 * dw, m01 * dw, m10 * dh, m11 * dh, tx + m00 * x1 + m10 * y1, ty + m01 * x1 + m11 * y1);
  $add_9(this.data, sx1, sy1);
  $add_9(this.data, sx2 - sx1, sy3 - sy1);
  $addExtraData(this, this.data);
  ++this.quadCounter;
  this.quadCounter >= this.this$0.maxQuads && $flush_0(this.this$0);
}
;
_.destroy = function destroy_1(){
  $destroy_1(this.prog);
  $destroy_0(this.vertices);
  $destroy_0(this.elements);
  $destroy_0(this.data);
}
;
_.flush = function flush_0(){
  if (this.quadCounter == 0)
    return;
  $bind_4(this.uData, this.data, this.quadCounter * 3);
  $drawElements_0(this.elements, 6 * this.quadCounter);
  this.quadCounter = 0;
}
;
_.prepare = function prepare_0(tint, justActivated){
  this.arTint = ~~tint >> 16 & 65535;
  this.gbTint = tint & 65535;
}
;
_.aVertex = null;
_.arTint = 0;
_.data = null;
_.elements = null;
_.gbTint = 0;
_.quadCounter = 0;
_.this$0 = null;
_.uData = null;
_.uScreenSize = null;
_.vertices = null;
function $clinit_Scale(){
  $clinit_Scale = nullMethod;
  ONE = new Scale_0(1);
}

function $invScaled(this$static, length_0){
  return length_0 / this$static.factor;
}

function $scaled(this$static, length_0){
  return this$static.factor * length_0;
}

function $scaledCeil(this$static, length_0){
  return iceil(this$static.factor * length_0);
}

function Scale_0(factor){
  $clinit_Scale();
  this.factor = factor;
}

defineSeed(416, 1, {}, Scale_0);
_.toString$ = function toString_41(){
  return 'x' + this.factor;
}
;
_.factor = 0;
var ONE;
function $paint_1(this$static, xform, curTint, shader){
  $addQuad($prepareTexture($quadShader(this$static.ctx, shader), this$static.tex, curTint), xform, 0, this$static.height_0, this$static.width_0, 0, 0, 0, 1, 1);
}

function SurfaceGL_0(ctx, width, height){
  this.transformStack = new ArrayList_0;
  this.ctx = ctx;
  $add_0(this.transformStack, new HtmlInternalTransform_0);
  this.width_0 = width;
  this.height_0 = height;
  this.texWidth = $scaledCeil(ctx.scale_0, width);
  this.texHeight = $scaledCeil(ctx.scale_0, height);
  this.tex = $createTexture(this.ctx, this.texWidth, this.texHeight, false, false, false);
  this.fbuf = $createFramebuffer(this.ctx, this.tex);
  $clear_2(this.ctx);
  $scale_2(this, ctx.scale_0.factor, ctx.scale_0.factor);
}

defineSeed(417, 390, {}, SurfaceGL_0);
_.fbuf = 0;
_.height_0 = 0;
_.tex = 0;
_.texHeight = 0;
_.texWidth = 0;
_.width_0 = 0;
function SurfaceLayerGL_0(ctx, width, height){
  SurfaceLayerGL_1.call(this, new SurfaceGL_0(ctx, width, height));
}

function SurfaceLayerGL_1(surface){
  LayerGL_0.call(this);
  this.surface = surface;
}

defineSeed(418, 409, {}, SurfaceLayerGL_0);
_.height_1 = function height_2(){
  return this.surface.height_0;
}
;
_.paint = function paint_1(parentTransform, curTint, curShader){
  if (!$isSet(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  $paint_1(this.surface, ($set_16(this.savedLocal, parentTransform) , $concatenate_0(this.savedLocal, $transform_0(this), this.originX, this.originY)), curTint, curShader);
}
;
_.surface_0 = function surface_0(){
  return this.surface;
}
;
_.width_1 = function width_2(){
  return this.surface.width_0;
}
;
_.surface = null;
function getElementSize_3(){
  throw new RuntimeException_1('Unrecognized buffer type: ' + null.nullMethod());
}

function createAdd(list, callback){
  !list && (list = new ArrayList_0);
  list.add(callback);
  return list;
}

function dispatchFailureClear(list, cause){
  var ii, ll;
  if (list) {
    for (ii = 0 , ll = list.size_0(); ii < ll; ++ii)
      list.get(ii).onFailure(cause);
  }
  return null;
}

function dispatchSuccessClear(list, result){
  var ii, ll;
  if (list) {
    for (ii = 0 , ll = list.size_0(); ii < ll; ++ii)
      list.get(ii).onSuccess(result);
  }
  return null;
}

function RunQueue_0(){
}

defineSeed(421, 1, {}, RunQueue_0);
_.head = null;
function $init_2(this$static){
  this$static.random_0 = getRandom();
  $debug(($clinit_HtmlPlatform() , log_0), 'Analytics random = ' + this$static.random_0);
}

function HtmlAnalytics_0(){
}

defineSeed(422, 1, {}, HtmlAnalytics_0);
_.random_0 = 0;
function $getBundle(this$static, collection){
  var clientBundle, entry, entry$iterator, regExp;
  clientBundle = null;
  for (entry$iterator = new AbstractHashMap$EntrySetIterator_0((new AbstractHashMap$EntrySet_0(this$static.clientBundles)).this$0); $hasNext(entry$iterator.iter);) {
    entry = entry$iterator.last = $next_2(entry$iterator.iter);
    regExp = entry.getKey();
    !!$exec(new RegExp(regExp), collection) && (clientBundle = entry.getValue());
  }
  return clientBundle;
}

function $getImage_1(this$static, path, scale){
  var url, img;
  url = this$static.pathPrefix + path;
  $getBundle(this$static, path);
  return img = $doc.createElement('img') , 'crossOrigin' in img && img.setAttribute('crossOrigin', 'anonymous') , img.src = url , new HtmlImage_0(this$static.platform.graphics.ctx_1(), scale, img);
}

function $getSound_1(this$static, path){
  var url, audio, sound;
  url = this$static.pathPrefix + path;
  $getBundle(this$static, path);
  url += '.mp3';
  return audio = platform_1.audio , sound = $createSound(audio.soundController, url) , new HtmlSound_0(sound);
}

function HtmlAssets_0(platform){
  this.clientBundles = new HashMap_0;
  this.platform = platform;
}

defineSeed(423, 342, {}, HtmlAssets_0);
_.pathPrefix = '';
_.platform = null;
function HtmlAudio_0(){
  this.soundController = new SoundController_0;
}

function maybeCreateAudioContext(){
  try {
    return new AudioContext;
  }
   catch (ignore) {
  }
  try {
    return new webkitAudioContext;
  }
   catch (ignore) {
  }
  return null;
}

defineSeed(424, 1, {}, HtmlAudio_0);
function $clear_3(this$static){
  $clearRect(this$static.ctx, 0, 0, this$static.width_0, this$static.height_0);
  return this$static;
}

function $drawLine(this$static, x0, y0, x1, y1){
  this$static.ctx.beginPath();
  $moveTo(this$static.ctx, x0, y0);
  $lineTo(this$static.ctx, x1, y1);
  this$static.ctx.stroke();
  return this$static;
}

function $fillPath(this$static, path){
  $replay(path, this$static.ctx);
  this$static.ctx.fill();
  return this$static;
}

function $scale_3(this$static, x, y){
  $scale(this$static.ctx, x, y);
  return this$static;
}

function $setFillColor(this$static, color){
  $setFillStyleWeb(this$static.ctx, cssColorString(color));
  return this$static;
}

function $setStrokeColor(this$static, color){
  $setStrokeStyleWeb(this$static.ctx, cssColorString(color));
  return this$static;
}

function $setStrokeWidth(this$static, w){
  $setLineWidth(this$static.ctx, w);
  return this$static;
}

function $transform_3(this$static, m11, m12, m21, m22, dx, dy){
  $transform(this$static.ctx, m11, m12, m21, m22, dx, dy);
  return this$static;
}

function $translate_1(this$static, x, y){
  $translate(this$static.ctx, x, y);
  return this$static;
}

function HtmlCanvas_0(width, height){
  HtmlCanvas_1.call(this, $doc.createElement('canvas'), width, height);
}

function HtmlCanvas_1(canvas, width, height){
  HtmlCanvas_2.call(this, canvas, canvas.getContext('2d'), width, height);
  $setWidth(canvas, iceil(width));
  $setHeight(canvas, iceil(height));
}

function HtmlCanvas_2(canvas, ctx, width, height){
  this.canvas = canvas;
  this.width_0 = width;
  this.height_0 = height;
  this.ctx = ctx;
}

defineSeed(425, 1, {}, HtmlCanvas_0, HtmlCanvas_1);
_.canvas = null;
_.ctx = null;
_.height_0 = 0;
_.width_0 = 0;
function $createObject(this$static, object, type){
  $push(this$static.webGLObjects, object);
  $push_0(this$static.webGLObjectTypes, type.ordinal);
  return this$static.webGLObjects.length - 1;
}

function $deleteObject(this$static, index, type){
  var object;
  object = this$static.webGLObjects[index];
  this$static.webGLObjects[index] = null;
  this$static.webGLObjectTypes[index] = ($clinit_HtmlGL20$WebGLObjectType() , NULL).ordinal;
  switch (type.ordinal) {
    case 1:
      $deleteBuffer(this$static.gl, object);
      break;
    case 2:
      $deleteFramebuffer(this$static.gl, object);
      break;
    case 3:
      $deleteProgram(this$static.gl, object);
      break;
    case 4:
      $deleteRenderbuffer(this$static.gl, object);
      break;
    case 5:
      $deleteShader(this$static.gl, object);
      break;
    case 6:
      $deleteTexture(this$static.gl, object);
  }
}

function $deleteObjects(this$static, indices, type){
  var i;
  for (i = 0; i < 1; ++i) {
    $deleteObject(this$static, indices[i], type);
  }
}

function $genObject(this$static, type){
  switch (type.ordinal) {
    case 1:
      return this$static.gl.createBuffer();
    case 2:
      return this$static.gl.createFramebuffer();
    case 3:
      return this$static.gl.createProgram();
    case 4:
      return this$static.gl.createRenderbuffer();
    case 6:
      return this$static.gl.createTexture();
    default:throw new RuntimeException_1('genObject(s) not supported for type ' + type);
  }
}

function $genObjects(this$static, names, type){
  var i, object;
  for (i = 0; i < 1; ++i) {
    object = $genObject(this$static, type);
    names[i] = $createObject(this$static, object, type);
  }
}

function $getTypedArray(buffer, type, byteSize){
  var arrayHolder, bufferElementSize, byteOffset, webGLArray;
  if (!instanceOf(buffer, Q$HasArrayBufferView)) {
    throw new RuntimeException_1('Native buffer required ' + buffer);
  }
  arrayHolder = buffer;
  bufferElementSize = arrayHolder.getElementSize();
  webGLArray = arrayHolder.getTypedArray();
  byteSize == -1 && (byteSize = (buffer.limit - buffer.position_0) * bufferElementSize);
  if (byteSize == buffer.capacity * bufferElementSize && type == arrayHolder.getElementType()) {
    return webGLArray;
  }
  byteOffset = webGLArray.byteOffset + buffer.position_0 * bufferElementSize;
  switch (type) {
    case 5126:
      return create_0(webGLArray.buffer, byteOffset, ~~(byteSize / 4));
    case 5121:
      return create_5(webGLArray.buffer, byteOffset, byteSize);
    case 5123:
      return create_4(webGLArray.buffer, byteOffset, ~~(byteSize / 2));
    case 5124:
      return create_2(webGLArray.buffer, byteOffset, ~~(byteSize / 4));
    case 5122:
      return create_1(webGLArray.buffer, byteOffset, ~~(byteSize / 2));
    case 5120:
      return create_3(webGLArray.buffer, byteOffset, byteSize);
    default:throw new IllegalArgumentException_1('Type: ' + type);
  }
}

function $glBindBuffer(this$static, target, buffer){
  var webGlBuf;
  webGlBuf = this$static.webGLObjects[buffer];
  target == 34962?(this$static.requestedArrayBuffer = webGlBuf):target == 34963?(this$static.requestedElementArrayBuffer = webGlBuf):$bindBuffer(this$static.gl, target, webGlBuf);
}

function $glBindFramebuffer(this$static, framebuffer){
  $bindFramebuffer(this$static.gl, 36160, this$static.webGLObjects[framebuffer]);
}

function $glBindTexture(this$static, textureId){
  $bindTexture(this$static.gl, 3553, this$static.webGLObjects[textureId]);
}

function $glBufferData(this$static, target, byteSize, data, usage){
  if (target == 34962) {
    if (this$static.requestedArrayBuffer != this$static.boundArrayBuffer) {
      $bindBuffer(this$static.gl, 34962, this$static.requestedArrayBuffer);
      this$static.boundArrayBuffer = this$static.requestedArrayBuffer;
    }
  }
   else if (target == 34963) {
    if (this$static.requestedElementArrayBuffer != this$static.boundElementArrayBuffer) {
      $bindBuffer(this$static.gl, 34963, this$static.requestedElementArrayBuffer);
      this$static.boundElementArrayBuffer = this$static.requestedElementArrayBuffer;
    }
  }
  $bufferData(this$static.gl, target, $getTypedArray(data, 5120, byteSize), usage);
}

function $glClear(this$static, mask){
  $clear(this$static.gl, mask);
}

function $glClearColor(this$static, f, g, h_0, i){
  $clearColor(this$static.gl, f, g, h_0, i);
}

function $glCompileShader(this$static, shader){
  $compileShader(this$static.gl, this$static.webGLObjects[shader]);
}

function $glCreateShader(this$static, type){
  return $createObject(this$static, $createShader(this$static.gl, type), ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
}

function $glDrawElements(this$static, count){
  $prepareDraw(this$static);
  if (this$static.requestedElementArrayBuffer != this$static.boundElementArrayBuffer) {
    $bindBuffer(this$static.gl, 34963, this$static.requestedElementArrayBuffer);
    this$static.boundElementArrayBuffer = this$static.requestedElementArrayBuffer;
  }
  $drawElements(this$static.gl, 4, count, 5123, 0);
}

function $glEnableVertexAttribArray(this$static, index){
  this$static.enabledArrays |= 1 << index;
}

function $glFramebufferTexture2D(this$static, texture){
  $framebufferTexture2D(this$static.gl, 36160, 36064, 3553, this$static.webGLObjects[texture], 0);
}

function $glGetAttribLocation(this$static, program, name_0){
  return $getAttribLocation(this$static.gl, this$static.webGLObjects[program], name_0);
}

function $glGetShaderInfoLog(this$static, shader){
  return $getShaderInfoLog(this$static.gl, this$static.webGLObjects[shader]);
}

function $glGetShaderiv(this$static, shader, params){
  params[0] = $getShaderParameterb(this$static.gl, this$static.webGLObjects[shader], 35713)?1:0;
}

function $glGetUniformLocation(this$static, program, name_0){
  return $createObject(this$static, $getUniformLocation(this$static.gl, this$static.webGLObjects[program], name_0), ($clinit_HtmlGL20$WebGLObjectType() , UNIFORM_LOCATION));
}

function $glShaderSource(this$static, shader, string){
  $shaderSource(this$static.gl, this$static.webGLObjects[shader], string);
}

function $glTexImage2D(this$static, width, height){
  $texImage2D(this$static.gl, 3553, 0, 6408, width, height, 0, 6408, 5121, null);
}

function $glTexParameteri(this$static, glTextureMinFilter, glFilterMin){
  $texParameteri(this$static.gl, 3553, glTextureMinFilter, glFilterMin);
}

function $glUniform1i(this$static, location_0){
  $uniform1i(this$static.gl, this$static.webGLObjects[location_0], 0);
}

function $glUniform2f(this$static, location_0, x, y){
  $uniform2f(this$static.gl, this$static.webGLObjects[location_0], x, y);
}

function $glUniform4fv(this$static, location_0, count, v){
  $uniform4fv(this$static.gl, this$static.webGLObjects[location_0], $getTypedArray(v, 5126, 16 * count));
}

function $glUseProgram(this$static, program){
  $useProgram(this$static.gl, this$static.webGLObjects[program]);
}

function $glVertexAttribPointer(this$static, indx, size, type, stride, ptr){
  this$static.useNioBuffer &= ~(1 << indx);
  if (this$static.boundArrayBuffer != this$static.requestedArrayBuffer) {
    $bindBuffer(this$static.gl, 34962, this$static.requestedArrayBuffer);
    this$static.boundArrayBuffer = this$static.requestedArrayBuffer;
  }
  $vertexAttribPointer(this$static.gl, indx, size, type, false, stride, ptr);
}

function $glViewport(this$static, w, h_0){
  $viewport(this$static.gl, 0, 0, w, h_0);
}

function $prepareDraw(this$static){
  var data, elementSize, enabled, i, mask, previousElementSize, previousNio;
  previousNio = null;
  previousElementSize = 0;
  if (this$static.useNioBuffer == 0 && this$static.enabledArrays == this$static.previouslyEnabledArrays) {
    return;
  }
  for (i = 0; i < 5; ++i) {
    mask = 1 << i;
    enabled = this$static.enabledArrays & mask;
    enabled != (this$static.previouslyEnabledArrays & mask) && (enabled != 0?$enableVertexAttribArray(this$static.gl, i):$disableVertexAttribArray(this$static.gl, i));
    if (enabled != 0 && (this$static.useNioBuffer & mask) != 0) {
      data = this$static.vertexAttribArrayState[i];
      if (!!previousNio && previousNio.nioBufferLimit >= data.nioBufferLimit) {
        if (this$static.boundArrayBuffer != previousNio.webGlBuffer) {
          $bindBuffer(this$static.gl, 34962, previousNio.webGlBuffer);
          this$static.boundArrayBuffer = data.webGlBuffer;
        }
        $vertexAttribPointer(this$static.gl, i, data.size, data.type_0, data.normalize, data.stride, data.nioBufferPosition * previousElementSize);
      }
       else {
        if (this$static.boundArrayBuffer != data.webGlBuffer) {
          $bindBuffer(this$static.gl, 34962, data.webGlBuffer);
          this$static.boundArrayBuffer = data.webGlBuffer;
        }
        elementSize = getElementSize_3();
        null.nullMethod();
        if (data.nioBufferPosition * elementSize < data.stride) {
          null.nullMethod();
          $bufferData(this$static.gl, 34962, $getTypedArray(data.nioBuffer, data.type_0, data.nioBufferLimit * elementSize), 35040);
          $vertexAttribPointer(this$static.gl, i, data.size, data.type_0, data.normalize, data.stride, data.nioBufferPosition * elementSize);
          previousNio = data;
          previousElementSize = elementSize;
        }
         else {
          null.nullMethod();
          $bufferData(this$static.gl, 34962, $getTypedArray(data.nioBuffer, data.type_0, (data.nioBufferLimit - data.nioBufferPosition) * elementSize), 35040);
          $vertexAttribPointer(this$static.gl, i, data.size, data.type_0, data.normalize, data.stride, 0);
        }
        null.nullMethod();
      }
    }
  }
  this$static.previouslyEnabledArrays = this$static.enabledArrays;
}

function HtmlGL20_0(gl){
  var data, i;
  this.vertexAttribArrayState = initDim(_3Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$HtmlGL20$VertexAttribArrayState, 5, 0);
  this.webGLObjects = [];
  this.webGLObjectTypes = [];
  this.gl = gl;
  $push(this.webGLObjects, null);
  $push_0(this.webGLObjectTypes, ($clinit_HtmlGL20$WebGLObjectType() , NULL).ordinal);
  gl.createBuffer();
  for (i = 0; i < 5; ++i) {
    data = new HtmlGL20$VertexAttribArrayState_0;
    data.webGlBuffer = gl.createBuffer();
    this.vertexAttribArrayState[i] = data;
  }
}

defineSeed(426, 1, {}, HtmlGL20_0);
_.boundArrayBuffer = null;
_.boundElementArrayBuffer = null;
_.enabledArrays = 0;
_.gl = null;
_.previouslyEnabledArrays = 0;
_.requestedArrayBuffer = null;
_.requestedElementArrayBuffer = null;
_.useNioBuffer = 0;
function HtmlGL20$VertexAttribArrayState_0(){
}

defineSeed(427, 1, makeCastMap([Q$HtmlGL20$VertexAttribArrayState]), HtmlGL20$VertexAttribArrayState_0);
_.nioBuffer = null;
_.nioBufferLimit = 0;
_.nioBufferPosition = 0;
_.normalize = false;
_.size = 0;
_.stride = 0;
_.type_0 = 0;
_.webGlBuffer = null;
function $clinit_HtmlGL20$WebGLObjectType(){
  $clinit_HtmlGL20$WebGLObjectType = nullMethod;
  NULL = new HtmlGL20$WebGLObjectType_0('NULL', 0);
  BUFFER = new HtmlGL20$WebGLObjectType_0('BUFFER', 1);
  FRAME_BUFFER = new HtmlGL20$WebGLObjectType_0('FRAME_BUFFER', 2);
  PROGRAM = new HtmlGL20$WebGLObjectType_0('PROGRAM', 3);
  RENDER_BUFFER = new HtmlGL20$WebGLObjectType_0('RENDER_BUFFER', 4);
  SHADER = new HtmlGL20$WebGLObjectType_0('SHADER', 5);
  TEXTURE = new HtmlGL20$WebGLObjectType_0('TEXTURE', 6);
  UNIFORM_LOCATION = new HtmlGL20$WebGLObjectType_0('UNIFORM_LOCATION', 7);
  $VALUES_15 = initValues(_3Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$HtmlGL20$WebGLObjectType, [NULL, BUFFER, FRAME_BUFFER, PROGRAM, RENDER_BUFFER, SHADER, TEXTURE, UNIFORM_LOCATION]);
}

function HtmlGL20$WebGLObjectType_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_15(){
  $clinit_HtmlGL20$WebGLObjectType();
  return $VALUES_15;
}

defineSeed(428, 11, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$HtmlGL20$WebGLObjectType]), HtmlGL20$WebGLObjectType_0);
var $VALUES_15, BUFFER, FRAME_BUFFER, NULL, PROGRAM, RENDER_BUFFER, SHADER, TEXTURE, UNIFORM_LOCATION;
function $tryBasicGLCalls(this$static){
  var err, pixelData, testFloat32Array, testInt32Array, testUint16Array, testUint8Array;
  testFloat32Array = createFloat32Array(toJsArray(initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [0, 1, 2])));
  if (testFloat32Array[0] != 0 || testFloat32Array[1] != 1 || testFloat32Array[2] != 2) {
    throw new RuntimeException_1('Typed Float32Array check failed');
  }
  testInt32Array = createInt32Array(toJsArray_0(initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [0, 1, 2])));
  if (testInt32Array[0] != 0 || testInt32Array[1] != 1 || testInt32Array[2] != 2) {
    throw new RuntimeException_1('Typed Int32Array check failed');
  }
  testUint16Array = createUint16Array(toJsArray_0(initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [0, 1, 2])));
  if (testUint16Array[0] != 0 || testUint16Array[1] != 1 || testUint16Array[2] != 2) {
    throw new RuntimeException_1('Typed Uint16Array check failed');
  }
  testUint8Array = createUint8Array(toJsArray_0(initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [0, 1, 2])));
  if (testUint8Array[0] != 0 || testUint8Array[1] != 1 || testUint8Array[2] != 2) {
    throw new RuntimeException_1('Typed Uint8Array check failed');
  }
  $bindFramebuffer_0(this$static, 0, this$static.defaultFbufWidth, this$static.defaultFbufHeight);
  $glClearColor(this$static.gl, 1, 1, 1, 1);
  $glClear(this$static.gl, 16384);
  err = this$static.glc.getError();
  if (err != 0) {
    throw new RuntimeException_1('Read back GL test failed to clear color (error ' + err + ')');
  }
  pixelData = new Uint8Array(4);
  $readPixels(this$static.glc, 0, 0, 1, 1, 6408, 5121, pixelData);
  if (pixelData[0] != 255 || pixelData[1] != 255 || pixelData[2] != 255) {
    throw new RuntimeException_1('Read back GL test failed to read back correct color');
  }
}

function $updateTexture(this$static, tex, img){
  $glBindTexture(this$static.gl, tex);
  $texImage2D_0(this$static.glc, 3553, 0, 6408, 6408, 5121, img);
}

function HtmlGLContext_0(platform, gl, canvas){
  GL20Context_0.call(this, platform, new HtmlGL20_0(gl), ($clinit_HtmlUrlParameters() , checkGLErrors));
  this.glc = gl;
  $tryBasicGLCalls(this);
  $setSize(this, iceil(canvas.width), iceil(canvas.height));
  this.gl.gl.disable(2884);
  this.gl.gl.enable(3042);
  this.gl.gl.blendFunc(1, 771);
  $glClearColor(this.gl, 0, 0, 0, 1);
  !!this.quadShader && $clearProgram(this.quadShader);
  !!this.trisShader && $clearProgram(this.trisShader);
  this.quadShader = $createQuadShader(this);
  this.trisShader = new IndexedTrisShader_0(this);
  $checkGLError(this, 'initGL');
  this.glc.pixelStorei(37441, 1);
}

defineSeed(429, 394, {}, HtmlGLContext_0);
_.createTransform = function createTransform_0(){
  return new HtmlInternalTransform_0;
}
;
_.glc = null;
function HtmlGame$1_0(){
}

defineSeed(431, 1, {}, HtmlGame$1_0);
function HtmlGame$2_0(){
}

defineSeed(432, 1, {}, HtmlGame$2_0);
_.execute = function execute_10(){
  var config, platform, platform_0;
  config = new HtmlPlatform$Config_0;
  platform = ($clinit_HtmlPlatform() , platform_0 = new HtmlPlatform_0(config) , platform_1 = platform_0 , $init_2(platform_0.analytics) , maybeCreateAudioContext() , $init_3(platform_0.keyboard) , platform_0);
  platform.assets.pathPrefix = 'crust/';
  run(new CrustGame_0);
}
;
--></script>
<script><!--
function $transformMouse(this$static, x, y){
  return $set_17(this$static.mousePoint, x / this$static.scale_3().factor, y / this$static.scale_3().factor);
}

function HtmlGraphics_0(){
  var doc;
  this.mousePoint = new Point_0;
  new HashMap_0;
  doc = $doc;
  this.dummyCanvas = doc.createElement('canvas');
  this.dummyCanvas.getContext('2d');
  this.rootElement = doc.getElementById('playn-root');
  if (!this.rootElement) {
    this.rootElement = doc.createElement('div');
    this.rootElement.setAttribute('style', 'width: 640px; height: 480px');
    $appendChild(doc.body, this.rootElement);
  }
   else {
    this.rootElement.innerHTML = '';
  }
  this.measureElement = doc.createElement('div');
  this.measureElement.style['visibility'] = ($clinit_Style$Visibility() , 'hidden');
  this.measureElement.style['position'] = ($clinit_Style$Position() , 'absolute');
  this.measureElement.style['top'] = -500 + ($clinit_Style$Unit() , 'px');
  this.measureElement.style['overflow'] = ($clinit_Style$Overflow() , 'visible');
  $appendChild(this.rootElement, this.measureElement);
}

function cssColorString(color){
  var a, b, g, r;
  a = (~~color >> 24 & 255) / 255;
  r = ~~color >> 16 & 255;
  g = ~~color >> 8 & 255;
  b = color & 255;
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

defineSeed(433, 1, {});
_.ctx_0 = function ctx_0(){
  return this.ctx_1();
}
;
_.ctx_1 = function ctx_1(){
  return null;
}
;
_.dummyCanvas = null;
_.measureElement = null;
_.rootElement = null;
function HtmlGraphicsCanvas_0(){
  HtmlGraphics_0.call(this);
  this.scale_0 = new Scale_0(1);
  this.rootLayer = new HtmlGroupLayerCanvas_0;
  this.canvas = $doc.createElement('canvas');
  $setWidth(this.canvas, this.rootElement.offsetWidth || 0);
  $setHeight(this.canvas, this.rootElement.offsetHeight || 0);
  $appendChild(this.rootElement, this.canvas);
  this.ctx = this.canvas.getContext('2d');
  this.ctx.scale(1, 1);
}

defineSeed(434, 433, {}, HtmlGraphicsCanvas_0);
_.createGroupLayer = function createGroupLayer(){
  return new HtmlGroupLayerCanvas_0;
}
;
_.createImageLayer = function createImageLayer(img){
  return new HtmlImageLayerCanvas_0(img);
}
;
_.createSurfaceLayer = function createSurfaceLayer(width, height){
  return new HtmlSurfaceLayerCanvas_0(width, height);
}
;
_.height_2 = function height_3(){
  return round_int($invScaled(this.scale_0, this.canvas.offsetHeight || 0));
}
;
_.paint_0 = function paint_2(){
  $clearRect(this.ctx, 0, 0, round_int($invScaled(this.scale_0, this.canvas.offsetWidth || 0)), round_int($invScaled(this.scale_0, this.canvas.offsetHeight || 0)));
  $paint_2(this.rootLayer, this.ctx, 1);
  this.ctx.globalAlpha = 1;
}
;
_.rootElement_0 = function rootElement_0(){
  return this.canvas;
}
;
_.rootLayer_0 = function rootLayer_0(){
  return this.rootLayer;
}
;
_.scale_3 = function scale_4(){
  return this.scale_0;
}
;
_.width_2 = function width_3(){
  return round_int($invScaled(this.scale_0, this.canvas.offsetWidth || 0));
}
;
_.canvas = null;
_.ctx = null;
_.rootLayer = null;
_.scale_0 = null;
function HtmlGraphicsDom_0(){
  var div;
  HtmlGraphics_0.call(this);
  div = $doc.createElement('div');
  div.style['overflow'] = ($clinit_Style$Overflow() , 'hidden');
  $appendChild(this.rootElement, div);
  this.rootLayer = new HtmlGroupLayerDom_1(div);
}

defineSeed(435, 433, {}, HtmlGraphicsDom_0);
_.createGroupLayer = function createGroupLayer_0(){
  return new HtmlGroupLayerDom_0;
}
;
_.createImageLayer = function createImageLayer_0(img){
  return new HtmlImageLayerDom_0(img);
}
;
_.createSurfaceLayer = function createSurfaceLayer_0(width, height){
  return new HtmlSurfaceLayerDom_0(width, height);
}
;
_.height_2 = function height_4(){
  return this.rootLayer.elem.offsetHeight || 0;
}
;
_.paint_0 = function paint_3(){
  $update_1(this.rootLayer);
}
;
_.rootElement_0 = function rootElement_1(){
  return this.rootLayer.elem;
}
;
_.rootLayer_0 = function rootLayer_1(){
  return this.rootLayer;
}
;
_.scale_3 = function scale_5(){
  return $clinit_Scale() , ONE;
}
;
_.width_2 = function width_4(){
  return this.rootLayer.elem.offsetWidth || 0;
}
;
_.rootLayer = null;
function HtmlGraphicsGL_0(platform){
  var $e0, attrs, gl, re;
  HtmlGraphics_0.call(this);
  this.canvas = $doc.createElement('canvas');
  $setWidth(this.canvas, this.rootElement.offsetWidth || 0);
  $setHeight(this.canvas, this.rootElement.offsetHeight || 0);
  $appendChild(this.rootElement, this.canvas);
  try {
    attrs = {premultipliedAlpha:false};
    attrs.alpha = false;
    attrs.antialias = true;
    gl = getContext(this.canvas, attrs);
    if (!gl || gl.getError() != 0) {
      throw new RuntimeException_1('GL context not created [err=' + (!gl?'null':valueOf(gl.getError())) + ']');
    }
    this.ctx = new HtmlGLContext_0(platform, gl, this.canvas);
    this.rootLayer = new GroupLayerGL_0;
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$RuntimeException)) {
      re = $e0;
      $removeChild(this.rootElement, this.canvas);
      throw re;
    }
     else 
      throw $e0;
  }
}

defineSeed(436, 433, {}, HtmlGraphicsGL_0);
_.createGroupLayer = function createGroupLayer_1(){
  return new GroupLayerGL_0;
}
;
_.createImageLayer = function createImageLayer_1(img){
  return new ImageLayerGL_0(img);
}
;
_.createSurfaceLayer = function createSurfaceLayer_1(width, height){
  return new SurfaceLayerGL_0(this.ctx, width, height);
}
;
_.ctx_0 = function ctx_2(){
  return this.ctx;
}
;
_.ctx_1 = function ctx_3(){
  return this.ctx;
}
;
_.height_2 = function height_5(){
  return this.ctx.viewHeight;
}
;
_.paint_0 = function paint_4(){
  $paint(this.ctx, this.rootLayer);
}
;
_.rootElement_0 = function rootElement_2(){
  return this.canvas;
}
;
_.rootLayer_0 = function rootLayer_2(){
  return this.rootLayer;
}
;
_.scale_3 = function scale_6(){
  return this.ctx.scale_0;
}
;
_.width_2 = function width_5(){
  return this.ctx.viewWidth;
}
;
_.canvas = null;
_.ctx = null;
_.rootLayer = null;
function $transform_4(this$static, ctx){
  var transform;
  $translate(ctx, this$static.originX, this$static.originY);
  transform = $transform_0(this$static);
  $transform(ctx, transform.m00_0(), transform.m01_0(), transform.m10_0(), transform.m11_0(), transform.tx_0() - this$static.originX, transform.ty_0() - this$static.originY);
  $translate(ctx, -this$static.originX, -this$static.originY);
}

function HtmlLayerCanvas_0(){
  AbstractLayer_0.call(this, ($clinit_HtmlPlatform() , hasTypedArraySupport)?new HtmlInternalTransform_0:new StockInternalTransform_0);
}

defineSeed(438, 343, {});
function $paint_2(this$static, ctx, parentAlpha){
  if (!$isSet(this$static, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  ctx.save();
  $transform_4(this$static, ctx);
  $render_0(this$static, ctx, parentAlpha);
  ctx.restore();
}

function $render_0(this$static, ctx, alpha){
  var child, child$iterator;
  for (child$iterator = new AbstractList$IteratorImpl_0(this$static.impl.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.paint_1(ctx, alpha);
  }
}

function HtmlGroupLayerCanvas_0(){
  HtmlLayerCanvas_0.call(this);
  this.impl = new GroupLayerImpl_0;
}

defineSeed(437, 438, {}, HtmlGroupLayerCanvas_0);
_.add_1 = function add_8(layer){
  $add_8(this.impl, this, layer);
}
;
_.hitTestDefault = function hitTestDefault_1(p){
  return $hitTest(this.impl, this, p);
}
;
_.onAdd = function onAdd_1(){
  $onAdd(this);
  $onAdd_0(this.impl);
}
;
_.onRemove = function onRemove_1(){
  $onRemove(this.impl);
}
;
_.paint_1 = function paint_5(ctx, parentAlpha){
  $paint_2(this, ctx, parentAlpha);
}
;
_.remove_4 = function remove_19(layer){
  $remove_10(this.impl, layer);
}
;
function $clinit_HtmlLayerDom(){
  $clinit_HtmlLayerDom = nullMethod;
  var i, prefix;
  PREFIXES = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Moz', 'webkit', 'ms', 'O']);
  i = 0;
  for (; i < PREFIXES.length; ++i) {
    prefix = PREFIXES[i];
    if (document.body.style[prefix + 'Transform'] !== undefined) {
      transformName = prefix + 'Transform';
      transformOriginName = prefix + 'TransformOrigin';
      break;
    }
  }
  if (i == PREFIXES.length) {
    transformName = 'transform';
    transformOriginName = 'transformOrigin';
  }
  supports3d = $equals('webkitTransform', transformName);
  translateSuffix = $equals('MozTransform', transformName)?'px':'';
}

function $css(x){
  return abs(x) < 0.0010000000474974513?'0':'' + x;
}

function $update_0(this$static){
  var m00, m01, m10, m11, m20, m21, matrix, transform;
  if (!$isSet(this$static, ($clinit_AbstractLayer$Flag() , SHOWN))) {
    $setFlag(this$static, SHOWN, true);
    this$static.elem.style['visibility'] = ($clinit_Style$Visibility() , 'visible');
  }
  transform = $transform_0(this$static);
  m00 = transform.m00_0();
  m01 = transform.m01_0();
  m10 = transform.m10_0();
  m11 = transform.m11_0();
  m20 = transform.tx_0();
  m21 = transform.ty_0();
  supports3d?(matrix = 'matrix3d(' + (abs(m00) < 0.0010000000474974513?'0':'' + m00) + ',' + (abs(m01) < 0.0010000000474974513?'0':'' + m01) + ',0,0,' + (abs(m10) < 0.0010000000474974513?'0':'' + m10) + ',' + (abs(m11) < 0.0010000000474974513?'0':'' + m11) + ',0,0,0,0,1,0,' + ((abs(m20) < 0.0010000000474974513?'0':'' + m20) + translateSuffix) + ',' + ((abs(m21) < 0.0010000000474974513?'0':'' + m21) + translateSuffix) + ',0,1)'):(matrix = 'matrix(' + (abs(m00) < 0.0010000000474974513?'0':'' + m00) + ',' + (abs(m01) < 0.0010000000474974513?'0':'' + m01) + ',' + (abs(m10) < 0.0010000000474974513?'0':'' + m10) + ',' + (abs(m11) < 0.0010000000474974513?'0':'' + m11) + ', ' + ((abs(m20) < 0.0010000000474974513?'0':'' + m20) + translateSuffix) + ',' + ((abs(m21) < 0.0010000000474974513?'0':'' + m21) + translateSuffix) + ')');
  matrix += ' translate(' + $css(-this$static.originX) + 'px,' + $css(-this$static.originY) + 'px)';
  this$static.elem.style[transformName] = matrix;
}

function HtmlLayerDom_0(elem){
  AbstractLayer_0.call(this, ($clinit_HtmlPlatform() , hasTypedArraySupport)?new HtmlInternalTransform_0:new StockInternalTransform_0);
  this.elem = elem;
  elem.style['position'] = ($clinit_Style$Position() , 'absolute');
  elem.style['visibility'] = ($clinit_Style$Visibility() , 'hidden');
  elem.style[transformOriginName] = '0 0';
}

defineSeed(440, 343, {});
_.update = function update(){
  $update_0(this);
}
;
_.elem = null;
var PREFIXES, supports3d = false, transformName = null, transformOriginName = null, translateSuffix = null;
function $$init_1(this$static){
  this$static.impl = new GroupLayerImpl_0;
}

function $update_1(this$static){
  var child, child$iterator;
  $update_0(this$static);
  for (child$iterator = new AbstractList$IteratorImpl_0(this$static.impl.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.update();
  }
}

function HtmlGroupLayerDom_0(){
  $clinit_HtmlLayerDom();
  HtmlLayerDom_0.call(this, $doc.createElement('div'));
  $$init_1(this);
}

function HtmlGroupLayerDom_1(elem){
  $clinit_HtmlLayerDom();
  HtmlLayerDom_0.call(this, elem);
  $$init_1(this);
}

defineSeed(439, 440, {}, HtmlGroupLayerDom_0, HtmlGroupLayerDom_1);
_.add_1 = function add_9(layer){
  var hlayer, index, refChild, size;
  hlayer = layer;
  size = this.impl.children.size;
  index = $add_8(this.impl, this, hlayer);
  if (index == size) {
    $appendChild(this.elem, hlayer.elem);
  }
   else {
    refChild = $getChild(this.elem, index);
    $insertBefore(this.elem, hlayer.elem, refChild);
  }
}
;
_.hitTestDefault = function hitTestDefault_2(p){
  return $hitTest(this.impl, this, p);
}
;
_.onAdd = function onAdd_2(){
  $onAdd(this);
  $onAdd_0(this.impl);
}
;
_.onRemove = function onRemove_2(){
  $onRemove(this.impl);
}
;
_.remove_4 = function remove_20(layer){
  var hlayer;
  hlayer = layer;
  $remove_10(this.impl, hlayer);
  $removeChild(this.elem, hlayer.elem);
}
;
_.update = function update_0(){
  $update_1(this);
}
;
function $addCallback_0(this$static, callback){
  if (this$static.img.complete) {
    callback.onSuccess(this$static);
  }
   else {
    addEventListener_0(this$static.img, 'load', new HtmlImage$1_0(this$static, callback), false);
    addEventListener_0(this$static.img, 'error', new HtmlImage$2_0(this$static, callback), false);
  }
}

function $draw_0(this$static, ctx, width, height){
  $draw_1(this$static, ctx, 0, 0, !this$static.img?0:$invScaled(this$static.scale_0, this$static.img.width), !this$static.img?0:$invScaled(this$static.scale_0, this$static.img.height), width, height);
}

function $draw_1(this$static, ctx, sx, sy, sw, sh, dw, dh){
  sx *= this$static.scale_0.factor;
  sy *= this$static.scale_0.factor;
  sw *= this$static.scale_0.factor;
  sh *= this$static.scale_0.factor;
  $drawImage_0(ctx, this$static.img, sx, sy, sw, sh, 0, 0, dw, dh);
}

function $height(this$static){
  return !this$static.img?0:$invScaled(this$static.scale_0, this$static.img.height);
}

function $toPattern(this$static){
  this$static.img.complete;
  return new HtmlPattern_1(this$static);
}

function $updateTexture_0(this$static, tex){
  $updateTexture(this$static.ctx, tex, this$static.img);
}

function $width(this$static){
  return !this$static.img?0:$invScaled(this$static.scale_0, this$static.img.width);
}

function HtmlImage_0(ctx, scale, img){
  this.ctx = ctx;
  this.scale_0 = scale;
  this.img = img;
}

defineSeed(441, 410, {}, HtmlImage_0);
_.img = null;
function HtmlImage$1_0(this$0, val$callback){
  this.this$0 = this$0;
  this.val$callback = val$callback;
}

defineSeed(442, 1, {}, HtmlImage$1_0);
_.handleEvent = function handleEvent(evt){
  this.val$callback.onSuccess(this.this$0);
}
;
_.this$0 = null;
_.val$callback = null;
function HtmlImage$2_0(this$0, val$callback){
  this.this$0 = this$0;
  this.val$callback = val$callback;
}

defineSeed(443, 1, {}, HtmlImage$2_0);
_.handleEvent = function handleEvent_0(evt){
  this.val$callback.onFailure(new RuntimeException_1('Error loading image ' + this.this$0.img.src));
}
;
_.this$0 = null;
_.val$callback = null;
function $updatePattern(this$static, ctx){
  if (this$static.repeatX == this$static.patternRepeatX && this$static.repeatY == this$static.patternRepeatY) {
    return;
  }
  this$static.pattern = $pattern($toPattern(this$static.img), ctx, this$static.repeatX, this$static.repeatY);
  this$static.patternRepeatX = this$static.repeatX;
  this$static.patternRepeatY = this$static.repeatY;
}

function HtmlImageLayerCanvas_0(img){
  HtmlLayerCanvas_0.call(this);
  this.img = img;
}

defineSeed(444, 438, {}, HtmlImageLayerCanvas_0);
_.height_1 = function height_6(){
  return this.heightSet?this.height_0:$height(this.img);
}
;
_.paint_1 = function paint_6(ctx, parentAlpha){
  var height, width;
  if (!$isSet(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1)) || !this.img || !this.img.img.complete)
    return;
  ctx.save();
  $transform_4(this, ctx);
  ctx.globalAlpha = parentAlpha;
  width = this.widthSet?this.width_0:$width(this.img);
  height = this.heightSet?this.height_0:$height(this.img);
  if (this.repeatX || this.repeatY) {
    $updatePattern(this, ctx);
    $setFillStyleWeb(ctx, this.pattern);
    ctx.beginPath();
    ctx.rect(0, 0, width, height);
    $scale(ctx, this.repeatX?1:width / $width(this.img), this.repeatY?1:height / $height(this.img));
    ctx.fill();
  }
   else {
    $draw_0(this.img, ctx, width, height);
  }
  ctx.restore();
}
;
_.width_1 = function width_6(){
  return this.widthSet?this.width_0:$width(this.img);
}
;
_.height_0 = 0;
_.heightSet = false;
_.img = null;
_.pattern = null;
_.patternRepeatX = false;
_.patternRepeatY = false;
_.repeatX = false;
_.repeatY = false;
_.width_0 = 0;
_.widthSet = false;
function $applyBackgroundSize(this$static){
  var backHeight, backWidth, hratio, repeat, size, style, wratio;
  style = this$static.elem.style;
  this$static.repeatX?this$static.repeatY?(repeat = 'repeat'):(repeat = 'repeat-x'):this$static.repeatY?(repeat = 'repeat-y'):(repeat = 'no-repeat');
  style['backgroundRepeat'] = repeat;
  if (this$static.sourceRectSet) {
    wratio = this$static.widthSet?this$static.width_0 / this$static.sw:$width(this$static.htmlImage) / this$static.sw;
    hratio = this$static.heightSet?this$static.height_0 / this$static.sh:$height(this$static.htmlImage) / this$static.sh;
    wratio == 0 && (wratio = 1);
    hratio == 0 && (hratio = 1);
    backWidth = $width(this$static.htmlImage) * wratio;
    backHeight = $height(this$static.htmlImage) * hratio;
    style['backgroundSize'] = backWidth + 'px ' + backHeight + 'px';
    style['backgroundPosition'] = -this$static.sx * wratio + 'px ' + -this$static.sy * hratio + 'px';
  }
   else {
    size = this$static.repeatX?$width(this$static.htmlImage) + 'px ':'100% ';
    size += this$static.repeatY?$height(this$static.htmlImage) + 'px':'100%';
    style['backgroundSize'] = size;
    style['backgroundPosition'] = '';
  }
}

function $applySize(this$static){
  var style;
  style = this$static.elem.style;
  style['width'] = (this$static.widthSet?this$static.width_0:this$static.htmlImage.img.width) + ($clinit_Style$Unit() , 'px');
  style['height'] = (this$static.heightSet?this$static.height_0:this$static.htmlImage.img.height) + 'px';
  this$static.sourceRectSet && $applyBackgroundSize(this$static);
}

function $setImage_0(this$static, img){
  var imgElem;
  if (this$static.htmlImage == img) {
    return;
  }
  this$static.htmlImage = img;
  imgElem = this$static.htmlImage.img;
  this$static.elem.style['backgroundImage'] = 'url(' + imgElem.src + ')';
  this$static.elem.style['overflow'] = ($clinit_Style$Overflow() , 'hidden');
  $addCallback_0(img, new HtmlImageLayerDom$1_0(this$static));
}

function HtmlImageLayerDom_0(img){
  $clinit_HtmlLayerDom();
  HtmlLayerDom_0.call(this, $doc.createElement('div'));
  this.repeatX = false;
  $applyBackgroundSize(this);
  this.repeatY = false;
  $applyBackgroundSize(this);
  $setImage_0(this, img);
}

defineSeed(445, 440, {}, HtmlImageLayerDom_0);
_.height_1 = function height_7(){
  return this.heightSet?this.height_0:$height(this.htmlImage);
}
;
_.width_1 = function width_7(){
  return this.widthSet?this.width_0:$width(this.htmlImage);
}
;
_.height_0 = 0;
_.heightSet = false;
_.htmlImage = null;
_.repeatX = false;
_.repeatY = false;
_.sh = 0;
_.sourceRectSet = false;
_.sw = 0;
_.sx = 0;
_.sy = 0;
_.width_0 = 0;
_.widthSet = false;
function $onSuccess(this$static){
  $applySize(this$static.this$0);
  $applyBackgroundSize(this$static.this$0);
}

function HtmlImageLayerDom$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(446, 1, {}, HtmlImageLayerDom$1_0);
_.onFailure = function onFailure_0(err){
}
;
_.onSuccess = function onSuccess_0(resource){
  $onSuccess(this, resource);
}
;
_.this$0 = null;
function getRelativeX(e, target){
  return (e.clientX || 0) - $getAbsoluteLeft(target) + $getScrollLeft(target) + $getScrollLeft(target.ownerDocument.body);
}

function getRelativeY(e, target){
  return (e.clientY || 0) - $getAbsoluteTop(target) + (target.scrollTop || 0) + (target.ownerDocument.body.scrollTop || 0);
}

function HtmlInput$1_0(val$handler){
  this.val$handler = val$handler;
}

defineSeed(448, 1, {}, HtmlInput$1_0);
_.handleEvent = function handleEvent_1(evt){
  this.val$handler.handleEvent(evt);
}
;
_.val$handler = null;
function $clinit_HtmlInternalTransform(){
  $clinit_HtmlInternalTransform = nullMethod;
  new HtmlInternalTransform_0;
}

function $concatenate(this$static, m00, m01, m10, m11, tx, ty, originX, originY){
  multiply(this$static.matrix[0], this$static.matrix[1], this$static.matrix[2], this$static.matrix[3], this$static.matrix[4], this$static.matrix[5], 1, 0, 0, 1, originX, originY, this$static);
  multiply(this$static.matrix[0], this$static.matrix[1], this$static.matrix[2], this$static.matrix[3], this$static.matrix[4], this$static.matrix[5], m00, m01, m10, m11, tx - originX, ty - originY, this$static);
  multiply(this$static.matrix[0], this$static.matrix[1], this$static.matrix[2], this$static.matrix[3], this$static.matrix[4], this$static.matrix[5], 1, 0, 0, 1, -originX, -originY, this$static);
  return this$static;
}

function $concatenate_0(this$static, other, originX, originY){
  var ot;
  ot = other;
  return $concatenate(this$static, ot.matrix[0], ot.matrix[1], ot.matrix[2], ot.matrix[3], ot.matrix[4], ot.matrix[5], originX, originY);
}

function $preConcatenate(this$static, other){
  multiply_0(other.m00_0(), other.m01_0(), other.m10_0(), other.m11_0(), other.tx_0(), other.ty_0(), this$static, this$static);
  return this$static;
}

function $set_16(this$static, other){
  $set_0(this$static.matrix, other.matrix);
  return this$static;
}

function $setM00(this$static, value){
  this$static.matrix[0] = value;
}

function $setM01(this$static, value){
  this$static.matrix[1] = value;
}

function $setM10(this$static, value){
  this$static.matrix[2] = value;
}

function $setM11(this$static, value){
  this$static.matrix[3] = value;
}

function $setRotation_0(this$static, angle){
  var cosa, sina, sx, sy;
  sx = sqrt(this$static.matrix[0] * this$static.matrix[0] + this$static.matrix[1] * this$static.matrix[1]);
  sy = sqrt(this$static.matrix[2] * this$static.matrix[2] + this$static.matrix[3] * this$static.matrix[3]);
  sina = Math.sin(angle);
  cosa = Math.cos(angle);
  this$static.matrix[0] = cosa * sx;
  this$static.matrix[1] = sina * sx;
  this$static.matrix[2] = -sina * sy;
  this$static.matrix[3] = cosa * sy;
  return this$static;
}

function $setTx(this$static, tx){
  this$static.matrix[4] = tx;
  return this$static;
}

function $setTy(this$static, ty){
  this$static.matrix[5] = ty;
  return this$static;
}

function HtmlInternalTransform_0(){
  $clinit_HtmlInternalTransform();
  HtmlInternalTransform_2.call(this, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [1, 0, 0, 1, 0, 0]));
}

function HtmlInternalTransform_1(matrix){
  this.matrix = matrix;
}

function HtmlInternalTransform_2(matrix){
  HtmlInternalTransform_1.call(this, createFloat32Array(toJsArray(matrix)));
}

function multiply(am00, am01, am10, am11, atx, aty, bm00, bm01, bm10, bm11, btx, bty, into){
  $set(into.matrix, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [am00 * bm00 + am10 * bm01, am01 * bm00 + am11 * bm01, am00 * bm10 + am10 * bm11, am01 * bm10 + am11 * bm11, am00 * btx + am10 * bty + atx, am01 * btx + am11 * bty + aty]), 0);
  return into;
}

function multiply_0(m00, m01, m10, m11, tx, ty, b, into){
  return multiply(m00, m01, m10, m11, tx, ty, b.matrix[0], b.matrix[1], b.matrix[2], b.matrix[3], b.matrix[4], b.matrix[5], into);
}

defineSeed(449, 381, {}, HtmlInternalTransform_0);
_.concatenate = function concatenate_0(m00, m01, m10, m11, tx, ty, originX, originY){
  return $concatenate(this, m00, m01, m10, m11, tx, ty, originX, originY);
}
;
_.inverseTransform_0 = function inverseTransform_0(p, into){
  var det, m00, m01, m10, m11, rdet, x, y;
  m00 = this.matrix[0];
  m01 = this.matrix[1];
  m10 = this.matrix[2];
  m11 = this.matrix[3];
  x = p.x - this.matrix[4];
  y = p.y - this.matrix[5];
  det = m00 * m11 - m01 * m10;
  if (abs(det) == 0) {
    throw new NoninvertibleTransformException_0('affine [' + toString_47(this.matrix[0]) + ' ' + toString_47(this.matrix[1]) + ' ' + toString_47(this.matrix[2]) + ' ' + toString_47(this.matrix[3]) + ' ' + new Vector_2(this.matrix[4], this.matrix[5]) + ']');
  }
  rdet = 1 / det;
  return into.x = (x * m11 - y * m10) * rdet , into.y = (y * m00 - x * m01) * rdet , into;
}
;
_.m00_0 = function m00_1(){
  return this.matrix[0];
}
;
_.m01_0 = function m01_1(){
  return this.matrix[1];
}
;
_.m10_0 = function m10_1(){
  return this.matrix[2];
}
;
_.m11_0 = function m11_1(){
  return this.matrix[3];
}
;
_.scaleX_0 = function scaleX_2(scaleX){
  $setM00(this, this.matrix[0] * scaleX);
  $setM01(this, this.matrix[1] * scaleX);
  $setTx(this, this.matrix[4] * scaleX);
  return this;
}
;
_.scaleY_0 = function scaleY_2(scaleY){
  $setM10(this, this.matrix[2] * scaleY);
  $setM11(this, this.matrix[3] * scaleY);
  $setTy(this, this.matrix[5] * scaleY);
  return this;
}
;
_.setTransform = function setTransform_1(m00, m01, m10, m11, tx, ty){
  return $set(this.matrix, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [m00, m01, m10, m11, tx, ty]), 0) , this;
}
;
_.toString$ = function toString_42(){
  return 'affine [' + toString_47(this.matrix[0]) + ' ' + toString_47(this.matrix[1]) + ' ' + toString_47(this.matrix[2]) + ' ' + toString_47(this.matrix[3]) + ' ' + new Vector_2(this.matrix[4], this.matrix[5]) + ']';
}
;
_.translate_1 = function translate_3(tx, ty){
  return multiply(this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], 1, 0, 0, 1, tx, ty, this);
}
;
_.translateX = function translateX_1(tx){
  return multiply(this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], 1, 0, 0, 1, tx, 0, this);
}
;
_.translateY = function translateY_1(ty){
  return multiply(this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], 1, 0, 0, 1, 0, ty, this);
}
;
_.tx_0 = function tx_1(){
  return this.matrix[4];
}
;
_.ty_0 = function ty_1(){
  return this.matrix[5];
}
;
_.uniformScale = function uniformScale_1(scale){
  return $scale_0(this, scale, scale);
}
;
_.matrix = null;
function $init_3(this$static){
  captureEvent_0('keydown', new HtmlKeyboard$1_0(this$static));
  captureEvent_0('keypress', new HtmlKeyboard$2_0(this$static));
  captureEvent_0('keyup', new HtmlKeyboard$3_0(this$static));
}

function $setListener_1(this$static, listener){
  this$static.listener = listener;
}

function HtmlKeyboard_0(){
}

--></script>
<script><!--
function keyForCode(keyCode){
  switch (keyCode) {
    case 18:
      return $clinit_Key() , ALT;
    case 8:
      return $clinit_Key() , BACKSPACE;
    case 17:
      return $clinit_Key() , CONTROL;
    case 46:
      return $clinit_Key() , DELETE;
    case 40:
      return $clinit_Key() , DOWN;
    case 35:
      return $clinit_Key() , END;
    case 13:
      return $clinit_Key() , ENTER;
    case 27:
      return $clinit_Key() , ESCAPE;
    case 36:
      return $clinit_Key() , HOME;
    case 37:
      return $clinit_Key() , LEFT;
    case 34:
      return $clinit_Key() , PAGE_DOWN;
    case 33:
      return $clinit_Key() , PAGE_UP;
    case 39:
      return $clinit_Key() , RIGHT;
    case 16:
      return $clinit_Key() , SHIFT;
    case 9:
      return $clinit_Key() , TAB;
    case 38:
      return $clinit_Key() , UP;
    case 19:
      return $clinit_Key() , PAUSE;
    case 20:
      return $clinit_Key() , CAPS_LOCK;
    case 32:
      return $clinit_Key() , SPACE;
    case 45:
      return $clinit_Key() , INSERT;
    case 48:
      return $clinit_Key() , K0;
    case 49:
      return $clinit_Key() , K1;
    case 50:
      return $clinit_Key() , K2;
    case 51:
      return $clinit_Key() , K3;
    case 52:
      return $clinit_Key() , K4;
    case 53:
      return $clinit_Key() , K5;
    case 54:
      return $clinit_Key() , K6;
    case 55:
      return $clinit_Key() , K7;
    case 56:
      return $clinit_Key() , K8;
    case 57:
      return $clinit_Key() , K9;
    case 65:
      return $clinit_Key() , A;
    case 66:
      return $clinit_Key() , B;
    case 67:
      return $clinit_Key() , C_0;
    case 68:
      return $clinit_Key() , D;
    case 69:
      return $clinit_Key() , E;
    case 70:
      return $clinit_Key() , F;
    case 71:
      return $clinit_Key() , G;
    case 72:
      return $clinit_Key() , H;
    case 73:
      return $clinit_Key() , I;
    case 74:
      return $clinit_Key() , J;
    case 75:
      return $clinit_Key() , K_0;
    case 76:
      return $clinit_Key() , L;
    case 77:
      return $clinit_Key() , M;
    case 78:
      return $clinit_Key() , N;
    case 79:
      return $clinit_Key() , O;
    case 80:
      return $clinit_Key() , P;
    case 81:
      return $clinit_Key() , Q;
    case 82:
      return $clinit_Key() , R_0;
    case 83:
      return $clinit_Key() , S;
    case 84:
      return $clinit_Key() , T_0;
    case 85:
      return $clinit_Key() , U;
    case 86:
      return $clinit_Key() , V;
    case 87:
      return $clinit_Key() , W;
    case 88:
      return $clinit_Key() , X;
    case 89:
      return $clinit_Key() , Y;
    case 90:
      return $clinit_Key() , Z;
    case 92:
    case 91:
      return $clinit_Key() , WINDOWS;
    case 96:
      return $clinit_Key() , NP0;
    case 97:
      return $clinit_Key() , NP1;
    case 98:
      return $clinit_Key() , NP2;
    case 99:
      return $clinit_Key() , NP3;
    case 100:
      return $clinit_Key() , NP4;
    case 101:
      return $clinit_Key() , NP5;
    case 102:
      return $clinit_Key() , NP6;
    case 103:
      return $clinit_Key() , NP7;
    case 104:
      return $clinit_Key() , NP8;
    case 105:
      return $clinit_Key() , NP9;
    case 106:
      return $clinit_Key() , NP_MULTIPLY;
    case 107:
      return $clinit_Key() , NP_ADD;
    case 109:
      return $clinit_Key() , NP_SUBTRACT;
    case 110:
      return $clinit_Key() , NP_DECIMAL;
    case 111:
      return $clinit_Key() , NP_DIVIDE;
    case 112:
      return $clinit_Key() , F1;
    case 113:
      return $clinit_Key() , F2;
    case 114:
      return $clinit_Key() , F3;
    case 115:
      return $clinit_Key() , F4;
    case 116:
      return $clinit_Key() , F5;
    case 117:
      return $clinit_Key() , F6;
    case 118:
      return $clinit_Key() , F7;
    case 119:
      return $clinit_Key() , F8;
    case 120:
      return $clinit_Key() , F9;
    case 121:
      return $clinit_Key() , F10;
    case 122:
      return $clinit_Key() , F11;
    case 123:
      return $clinit_Key() , F12;
    case 144:
      return $clinit_Key() , NP_NUM_LOCK;
    case 145:
      return $clinit_Key() , SCROLL_LOCK;
    case 186:
      return $clinit_Key() , SEMICOLON;
    case 187:
      return $clinit_Key() , EQUALS;
    case 188:
      return $clinit_Key() , COMMA;
    case 189:
      return $clinit_Key() , MINUS;
    case 190:
      return $clinit_Key() , PERIOD;
    case 191:
      return $clinit_Key() , SLASH;
    case 192:
      return $clinit_Key() , BACKQUOTE;
    case 219:
      return $clinit_Key() , LEFT_BRACKET;
    case 220:
      return $clinit_Key() , BACKSLASH;
    case 221:
      return $clinit_Key() , RIGHT_BRACKET;
    case 222:
      return $clinit_Key() , QUOTE;
    default:return $clinit_Key() , UNKNOWN_1;
  }
}

defineSeed(450, 1, {}, HtmlKeyboard_0);
_.listener = null;
function HtmlKeyboard$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(451, 1, {}, HtmlKeyboard$1_0);
_.handleEvent = function handleEvent_2(nativeEvent){
  var event_0;
  if (this.this$0.listener) {
    event_0 = new Keyboard$Event$Impl_0(new Events$Flags$Impl_0, now_0(), keyForCode(nativeEvent.keyCode || 0));
    $onKeyDown(this.this$0.listener, event_0);
    event_0.flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
function HtmlKeyboard$2_0(this$0){
  this.this$0 = this$0;
}

defineSeed(452, 1, {}, HtmlKeyboard$2_0);
_.handleEvent = function handleEvent_3(nativeEvent){
  var event_0;
  if (this.this$0.listener) {
    event_0 = new Keyboard$TypedEvent$Impl_0(new Events$Flags$Impl_0, now_0(), (nativeEvent.charCode || 0) & 65535);
    $onKeyTyped(this.this$0.listener, event_0);
    event_0.flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
function HtmlKeyboard$3_0(this$0){
  this.this$0 = this$0;
}

defineSeed(453, 1, {}, HtmlKeyboard$3_0);
_.handleEvent = function handleEvent_4(nativeEvent){
  var event_0;
  if (this.this$0.listener) {
    event_0 = new Keyboard$Event$Impl_0(new Events$Flags$Impl_0, now_0(), keyForCode(nativeEvent.keyCode || 0));
    $onKeyUp(this.this$0.listener, event_0);
    event_0.flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
defineSeed(454, 361, {});
function HtmlLogSimple_0(){
  this.minLevel = ($clinit_Log$Level() , DEBUG);
}

defineSeed(455, 454, {}, HtmlLogSimple_0);
function $handleRequestsInUserEventContext(this$static){
  this$static.isRequestingMouseLock && !$isLocked() && $requestMouseLock(this$static, this$static.rootElement);
}

function $isLocked(){
  var pointer = navigator.webkitPointer || navigator.mozPointer || navigator.pointer;
  return pointer && pointer.isLocked || false;
}

function $requestMouseLock(this$static, element){
  var pointer = navigator.pointer || navigator.mozPointer || navigator.webkitPointer;
  var self_0 = this$static;
  pointer && pointer.lock(element, function(){
  }
  , function(e){
  }
  );
}

function HtmlMouse_0(platform, rootElement){
  this.DOWN = new MouseImpl$1_0;
  this.UP = new MouseImpl$2_0;
  this.DRAG = new MouseImpl$3_0;
  this.MOVE = new MouseImpl$4_0;
  this.OVER = new MouseImpl$5_0;
  this.OUT = new MouseImpl$6_0;
  this.WHEEL_SCROLL = new MouseImpl$7_0;
  this.lastMousePt = new Point_0;
  this.rootElement = rootElement;
  addEventListener_0($doc, 'contextmenu', new HtmlMouse$1_0, false);
  captureEvent(rootElement, 'mousedown', new HtmlMouse$2_0(this, platform, rootElement));
  captureEvent_0('mouseup', new HtmlInput$1_0(new HtmlMouse$3_0(this, platform, rootElement)));
  captureEvent_0('mousemove', new HtmlInput$1_0(new HtmlMouse$4_0(this, platform, rootElement)));
  captureEvent(rootElement, 'mousemove', new HtmlMouse$5_0(this, platform, rootElement));
  captureEvent(rootElement, getMouseWheelEvent(), new HtmlMouse$6_0(this));
}

function getMouseButton(evt){
  switch ($eventGetButton(evt)) {
    case 1:
      return 0;
    case 4:
      return 1;
    case 2:
      return 2;
    default:return $eventGetButton(evt);
  }
}

function getMouseWheelEvent(){
  if (navigator.userAgent.toLowerCase().indexOf('firefox') != -1) {
    return 'DOMMouseScroll';
  }
   else {
    return 'mousewheel';
  }
}

function getMouseWheelVelocity(evt){
  var delta = 0;
  var agentInfo = ($clinit_HtmlPlatform() , agentInfo_0);
  if (agentInfo.isFirefox) {
    agentInfo.isMacOS?(delta = 1 * evt.detail):(delta = 1 * evt.detail / 3);
  }
   else if (agentInfo.isOpera) {
    agentInfo.isLinux?(delta = -1 * evt.wheelDelta / 80):(delta = -1 * evt.wheelDelta / 40);
  }
   else if (agentInfo.isChrome || agentInfo.isSafari) {
    delta = -1 * evt.wheelDelta / 120;
    Math.abs(delta) < 1 && (agentInfo.isWindows?(delta = -1 * evt.wheelDelta):agentInfo.isMacOS && (delta = -1 * evt.wheelDelta / 3));
  }
  return delta;
}

defineSeed(456, 365, {}, HtmlMouse_0);
_.inDragSequence = false;
_.isRequestingMouseLock = false;
_.rootElement = null;
function HtmlMouse$1_0(){
}

defineSeed(457, 1, {}, HtmlMouse$1_0);
_.handleEvent = function handleEvent_5(evt){
  evt.preventDefault();
  evt.stopPropagation();
}
;
function HtmlMouse$1XYEventHandler_0(val$platform, val$rootElement){
  this.val$platform = val$platform;
  this.val$rootElement = val$rootElement;
}

defineSeed(459, 1, {});
_.handleEvent = function handleEvent_6(ev){
  var xy;
  xy = $transformMouse(this.val$platform.graphics, getRelativeX(ev, this.val$rootElement), getRelativeY(ev, this.val$rootElement));
  this.handleEvent_0(ev, xy.x, xy.y);
}
;
_.val$platform = null;
_.val$rootElement = null;
function HtmlMouse$1MoveEventHandler_0(this$0, val$platform, val$rootElement){
  this.this$0 = this$0;
  HtmlMouse$1XYEventHandler_0.call(this, val$platform, val$rootElement);
}

defineSeed(458, 459, {});
_.handleEvent_0 = function handleEvent_7(ev, x, y){
  var dx, dy;
  if (this.lastX == -1) {
    this.lastX = x;
    this.lastY = y;
  }
  if (this.this$0.inDragSequence == this.wantDragSequence()) {
    if ($isLocked()) {
      dx = ev.webkitMovementX;
      dy = ev.webkitMovementY;
    }
     else {
      dx = x - this.lastX;
      dy = y - this.lastY;
    }
    $onMouseMove(this.this$0, new Mouse$MotionEvent$Impl_0(new Events$Flags$Impl_0, now_0(), x, y, dx, dy)) && (ev.preventDefault() , undefined);
  }
  this.lastX = x;
  this.lastY = y;
  $set_17(this.this$0.lastMousePt, x, y);
}
;
_.lastX = -1;
_.lastY = -1;
_.this$0 = null;
function HtmlMouse$2_0(this$0, val$platform, val$rootElement){
  this.this$0 = this$0;
  HtmlMouse$1XYEventHandler_0.call(this, val$platform, val$rootElement);
}

defineSeed(460, 459, {}, HtmlMouse$2_0);
_.handleEvent_0 = function handleEvent_8(ev, x, y){
  this.this$0.inDragSequence = true;
  $onMouseDown(this.this$0, new Mouse$ButtonEvent$Impl_0(new Events$Flags$Impl_0, now_0(), x, y, getMouseButton(ev))) && (ev.preventDefault() , undefined);
}
;
_.this$0 = null;
function HtmlMouse$3_0(this$0, val$platform, val$rootElement){
  this.this$0 = this$0;
  HtmlMouse$1XYEventHandler_0.call(this, val$platform, val$rootElement);
}

defineSeed(461, 459, {}, HtmlMouse$3_0);
_.handleEvent_0 = function handleEvent_9(ev, x, y){
  if (this.this$0.inDragSequence) {
    this.this$0.inDragSequence = false;
    $onMouseUp(this.this$0, new Mouse$ButtonEvent$Impl_0(new Events$Flags$Impl_0, now_0(), x, y, getMouseButton(ev))) && (ev.preventDefault() , undefined);
  }
  $handleRequestsInUserEventContext(this.this$0);
}
;
_.this$0 = null;
function HtmlMouse$4_0(this$0, val$platform, val$rootElement){
  HtmlMouse$1MoveEventHandler_0.call(this, this$0, val$platform, val$rootElement);
}

defineSeed(462, 458, {}, HtmlMouse$4_0);
_.wantDragSequence = function wantDragSequence(){
  return true;
}
;
function HtmlMouse$5_0(this$0, val$platform, val$rootElement){
  HtmlMouse$1MoveEventHandler_0.call(this, this$0, val$platform, val$rootElement);
}

defineSeed(463, 458, {}, HtmlMouse$5_0);
_.wantDragSequence = function wantDragSequence_0(){
  return false;
}
;
function HtmlMouse$6_0(this$0){
  this.this$0 = this$0;
}

defineSeed(464, 1, {}, HtmlMouse$6_0);
_.handleEvent = function handleEvent_10(ev){
  $onMouseWheelScroll(this.this$0, new Mouse$WheelEvent$Impl_0(new Events$Flags$Impl_0, now_0(), this.this$0.lastMousePt.x, this.this$0.lastMousePt.y, getMouseWheelVelocity(ev))) && (ev.preventDefault() , undefined);
}
;
_.this$0 = null;
function $lineTo_0(this$static, x, y){
  $push_1(this$static.list, 1);
  $push_1(this$static.list, x);
  $push_1(this$static.list, y);
}

function $replay(this$static, ctx){
  var c1x, c1y, c2x, c2y, cpx, cpy, i, len, x, y;
  ctx.beginPath();
  len = this$static.list.length;
  i = 0;
  while (i < len) {
    switch (round_int(this$static.list[i++])) {
      case 0:
        {
          x = this$static.list[i++];
          y = this$static.list[i++];
          ctx.moveTo(x, y);
          break;
        }

      case 1:
        {
          x = this$static.list[i++];
          y = this$static.list[i++];
          ctx.lineTo(x, y);
          break;
        }

      case 2:
        {
          cpx = this$static.list[i++];
          cpy = this$static.list[i++];
          x = this$static.list[i++];
          y = this$static.list[i++];
          ctx.quadraticCurveTo(cpx, cpy, x, y);
          break;
        }

      case 3:
        {
          c1x = this$static.list[i++];
          c1y = this$static.list[i++];
          c2x = this$static.list[i++];
          c2y = this$static.list[i++];
          x = this$static.list[i++];
          y = this$static.list[i++];
          ctx.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
          break;
        }

      case 4:
        {
          ctx.closePath();
          break;
        }

      default:throw new AssertionError_0('Corrupt command list');
    }
  }
}

function HtmlPath_0(){
  this.list = [];
}

defineSeed(465, 1, {}, HtmlPath_0);
function $pattern(this$static, ctx, repeatX, repeatY){
  var repeat;
  if (repeatX) {
    repeatY?(repeat = ($clinit_Context2d$Repetition() , REPEAT)):(repeat = ($clinit_Context2d$Repetition() , REPEAT_X));
  }
   else if (repeatY) {
    repeat = ($clinit_Context2d$Repetition() , REPEAT_Y);
  }
   else {
    return null;
  }
  return $createPattern(ctx, this$static.patimg, repeat.value_0);
}

function HtmlPattern_0(patimg){
  this.patimg = patimg;
}

function HtmlPattern_1(image){
  HtmlPattern_0.call(this, image.img);
}

defineSeed(466, 1, {}, HtmlPattern_1);
_.patimg = null;
function $clinit_HtmlPlatform(){
  var userAgent;
  $clinit_HtmlPlatform = nullMethod;
  hasTypedArraySupport = typeof Float32Array != 'undefined';
  log_0 = new HtmlLogSimple_0;
  agentInfo_0 = (userAgent = navigator.userAgent.toLowerCase() , {isFirefox:userAgent.indexOf('firefox') != -1, isChrome:userAgent.indexOf('chrome') != -1, isSafari:userAgent.indexOf('safari') != -1, isOpera:userAgent.indexOf('opera') != -1, isIE:userAgent.indexOf('msie') != -1, isMacOS:userAgent.indexOf('mac') != -1, isLinux:userAgent.indexOf('linux') != -1, isWindows:userAgent.indexOf('win') != -1});
}

function $createGraphics(this$static, config){
  var $e0, e, t;
  try {
    switch (config.mode) {
      case 1:
        return new HtmlGraphicsCanvas_0;
      case 2:
        return new HtmlGraphicsDom_0;
      case 0:
        return new HtmlGraphicsGL_0(this$static);
      default:case 3:
        return !!$wnd.WebGLRenderingContext && (!/Chrome/.test(navigator.userAgent) || !/OS X 10_5/.test(navigator.userAgent))?new HtmlGraphicsGL_0(this$static):new HtmlGraphicsCanvas_0;
    }
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$RuntimeException)) {
      e = $e0;
      $info(this$static.log_0, 'Failed to create GL context (' + e.getMessage() + '). Falling back.');
    }
     else if (instanceOf($e0, Q$Throwable)) {
      t = $e0;
      $info(this$static.log_0, 'GL context creation failed with an unknown error.' + t);
    }
     else 
      throw $e0;
  }
  return new HtmlGraphicsCanvas_0;
}

function $requestAnimationFrame(callback){
  var fn = function(){
    callback.fire();
  }
  ;
  $wnd.requestAnimationFrame?$wnd.requestAnimationFrame(fn):$wnd.mozRequestAnimationFrame?$wnd.mozRequestAnimationFrame(fn):$wnd.webkitRequestAnimationFrame?$wnd.webkitRequestAnimationFrame(fn):$wnd.setTimeout(fn, 20);
}

function $run(this$static, game){
  game.assets = new CachingAssets_0(platform_1.assets);
  !!platform_1.graphics.ctx_0() && $setTextureFilter(platform_1.graphics.ctx_0());
  $setListener_1(platform_1.keyboard, game);
  $setListener(platform_1.mouse, game);
  $setListener_0(platform_1.pointer_0, game);
  $setScreen(game, new SkeletonGraphEditorScreen_0(game));
  this$static.paintCallback = new HtmlPlatform$1_0(this$static, game);
  $requestAnimationFrame(this$static.paintCallback);
}

function $tick_0(this$static){
  return round_int(now_0() - this$static.start);
}

function HtmlPlatform_0(config){
  var $e0, e;
  AbstractPlatform_0.call(this, log_0);
  this.assets = new HtmlAssets_0(this);
  this.audio = new HtmlAudio_0;
  this.keyboard = new HtmlKeyboard_0;
  new HtmlStorage_0;
  this.analytics = new HtmlAnalytics_0;
  this.start = initNow();
  try {
    this.graphics = $createGraphics(this, config);
    this.pointer_0 = new HtmlPointer_0(this, this.graphics.rootElement_0());
    this.mouse = new HtmlMouse_0(this, this.graphics.rootElement_0());
    new HtmlTouch_0(this, this.graphics.rootElement_0());
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      e = $e0;
      $error_0(log_0, 'init()', e);
      alert_0('failed to init(): ' + e.getMessage());
      throw new RuntimeException_3(e);
    }
     else 
      throw $e0;
  }
}

function addEventListener_0(target, name_0, handler, capture){
  $clinit_HtmlPlatform();
  target.addEventListener(name_0, function(e){
    handler.handleEvent(e);
  }
  , capture);
}

function captureEvent(target, name_0, handler){
  $clinit_HtmlPlatform();
  addEventListener_0(!target?$doc:target, name_0, handler, true);
}

function captureEvent_0(name_0, handler){
  $clinit_HtmlPlatform();
  addEventListener_0($doc, name_0, handler, true);
}

function initNow(){
  function now(){
    return new Date;
  }

  !Date.now && (Date.now = now);
  return Date.now();
}

function now_0(){
  $clinit_HtmlPlatform();
  return Date.now();
}

defineSeed(467, 345, {}, HtmlPlatform_0);
_.graphics = null;
_.mouse = null;
_.paintCallback = null;
_.pointer_0 = null;
var agentInfo_0, hasTypedArraySupport, log_0;
function HtmlPlatform$1_0(this$0, val$game){
  this.this$0 = this$0;
  this.val$game = val$game;
}

defineSeed(468, 1, {}, HtmlPlatform$1_0);
_.fire = function fire_0(){
  $requestAnimationFrame(this.this$0.paintCallback);
  this.this$0.runQueue.head = null;
  $tick(this.val$game, $tick_0(this.this$0));
  this.this$0.graphics.paint_0();
}
;
_.this$0 = null;
_.val$game = null;
function HtmlPlatform$Config_0(){
  this.mode = requestedMode();
}

defineSeed(470, 1, {}, HtmlPlatform$Config_0);
function $eventFromMouse(this$static, rootElement, nativeEvent){
  var x, xy, y;
  x = (nativeEvent.clientX || 0) - $getAbsoluteLeft(rootElement) + $getScrollLeft(rootElement) + $getScrollLeft(rootElement.ownerDocument.body);
  y = (nativeEvent.clientY || 0) - $getAbsoluteTop(rootElement) + (rootElement.scrollTop || 0) + (rootElement.ownerDocument.body.scrollTop || 0);
  xy = $transformMouse(this$static.platform.graphics, x, y);
  return new Pointer$Event$Impl_0(new Events$Flags$Impl_0, now_0(), xy.x, xy.y, false);
}

function $eventFromTouch(this$static, rootElement, touch){
  var x, xy, y;
  x = touch.clientX - $getAbsoluteLeft(rootElement) + $getScrollLeft(rootElement) + $getScrollLeft(rootElement.ownerDocument.body);
  y = touch.clientY - $getAbsoluteTop(rootElement) + (rootElement.scrollTop || 0) + (rootElement.ownerDocument.body.scrollTop || 0);
  xy = $transformMouse(this$static.platform.graphics, x, y);
  return new Pointer$Event$Impl_0(new Events$Flags$Impl_0, now_0(), xy.x, xy.y, true);
}

function HtmlPointer_0(platform, rootElement){
  this.START = new PointerImpl$1_0;
  this.DRAG = new PointerImpl$2_0;
  this.END = new PointerImpl$3_0;
  this.platform = platform;
  captureEvent(rootElement, 'touchstart', new HtmlPointer$1_0(this, rootElement));
  captureEvent_0('touchend', new HtmlInput$1_0(new HtmlPointer$2_0(this, rootElement)));
  captureEvent_0('touchmove', new HtmlInput$1_0(new HtmlPointer$3_0(this, rootElement)));
  captureEvent(rootElement, 'mousedown', new HtmlPointer$4_0(this, rootElement));
  captureEvent_0('mouseup', new HtmlInput$1_0(new HtmlPointer$5_0(this, rootElement)));
  captureEvent_0('mousemove', new HtmlInput$1_0(new HtmlPointer$6_0(this, rootElement)));
}

defineSeed(471, 375, {}, HtmlPointer_0);
_.inDragSequence = false;
_.platform = null;
function HtmlPointer$1_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(472, 1, {}, HtmlPointer$1_0);
_.handleEvent = function handleEvent_11(nativeEvent){
  var touches;
  touches = nativeEvent.changedTouches;
  if (touches.length > 0) {
    this.this$0.inDragSequence = true;
    $onPointerStart(this.this$0, $eventFromTouch(this.this$0, this.val$rootElement, touches[0])) && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$2_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(473, 1, {}, HtmlPointer$2_0);
_.handleEvent = function handleEvent_12(nativeEvent){
  var touches;
  touches = nativeEvent.changedTouches;
  if (this.this$0.inDragSequence && touches.length > 0) {
    this.this$0.inDragSequence = false;
    $onPointerEnd(this.this$0, $eventFromTouch(this.this$0, this.val$rootElement, touches[0]), true) && (nativeEvent.preventDefault() , undefined);
  }
   else {
    nativeEvent.preventDefault();
  }
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$3_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(474, 1, {}, HtmlPointer$3_0);
_.handleEvent = function handleEvent_13(nativeEvent){
  var touches;
  touches = nativeEvent.changedTouches;
  this.this$0.inDragSequence && touches.length > 0?$onPointerDrag(this.this$0, $eventFromTouch(this.this$0, this.val$rootElement, touches[0]), true) && (nativeEvent.preventDefault() , undefined):(nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$4_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(475, 1, {}, HtmlPointer$4_0);
_.handleEvent = function handleEvent_14(nativeEvent){
  this.this$0.inDragSequence = true;
  $onPointerStart(this.this$0, $eventFromMouse(this.this$0, this.val$rootElement, nativeEvent)) && (nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$5_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(476, 1, {}, HtmlPointer$5_0);
_.handleEvent = function handleEvent_15(nativeEvent){
  if (this.this$0.inDragSequence) {
    this.this$0.inDragSequence = false;
    $onPointerEnd(this.this$0, $eventFromMouse(this.this$0, this.val$rootElement, nativeEvent), false) && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$6_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(477, 1, {}, HtmlPointer$6_0);
_.handleEvent = function handleEvent_16(nativeEvent){
  this.this$0.inDragSequence && $onPointerDrag(this.this$0, $eventFromMouse(this.this$0, this.val$rootElement, nativeEvent), false) && (nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
_.val$rootElement = null;
function $setLoopingImpl(this$static, looping){
  this$static.impl.setLooping_0(looping);
}

function HtmlSound_0(sound){
  $addEventHandler(sound, new HtmlSound$1_0(this, sound));
}

defineSeed(478, 346, {}, HtmlSound_0);
function $onSoundLoadStateChange(this$static, event_0){
  var loadState;
  loadState = event_0.loadState;
  switch (loadState.ordinal) {
    case 5:
    case 4:
      break;
    case 2:
    case 1:
    case 3:
      $onLoaded(this$static.this$0, this$static.val$sound);
      break;
    case 0:
      $onLoadError(this$static.this$0, new RuntimeException_1(loadState.name_0));
      break;
    default:throw new RuntimeException_1('Unrecognized sound load state ' + loadState.name_0);
  }
}

function HtmlSound$1_0(this$0, val$sound){
  this.this$0 = this$0;
  this.val$sound = val$sound;
}

defineSeed(479, 1, {}, HtmlSound$1_0);
_.this$0 = null;
_.val$sound = null;
function HtmlStorage_0(){
  var storage;
  storage = getLocalStorageIfSupported();
  storage?new StorageMap_0(storage):new HashMap_0;
}

defineSeed(480, 1, {}, HtmlStorage_0);
function HtmlSurfaceLayerCanvas_0(width, height){
  HtmlLayerCanvas_0.call(this);
  this.surface = new CanvasSurface_0(this.canvas = new HtmlCanvas_0(width, height));
}

defineSeed(481, 438, {}, HtmlSurfaceLayerCanvas_0);
_.height_1 = function height_8(){
  return this.surface.canvas.height_0;
}
;
_.paint_1 = function paint_7(ctx, parentAlpha){
  if (!$isSet(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  ctx.save();
  $transform_4(this, ctx);
  ctx.globalAlpha = parentAlpha;
  $drawImage(ctx, this.canvas.canvas, 0, 0);
  ctx.restore();
}
;
_.surface_0 = function surface_1(){
  return this.surface;
}
;
_.width_1 = function width_8(){
  return this.surface.canvas.width_0;
}
;
_.canvas = null;
_.surface = null;
function HtmlSurfaceLayerDom_0(width, height){
  $clinit_HtmlLayerDom();
  HtmlLayerDom_0.call(this, $doc.createElement('canvas'));
  $setWidth(this.elem, iceil(width));
  $setHeight(this.elem, iceil(height));
  this.surface = new CanvasSurface_0(new HtmlCanvas_1(this.elem, width, height));
}

defineSeed(482, 440, {}, HtmlSurfaceLayerDom_0);
_.height_1 = function height_9(){
  return this.surface.canvas.height_0;
}
;
_.surface_0 = function surface_2(){
  return this.surface;
}
;
_.width_1 = function width_9(){
  return this.surface.canvas.width_0;
}
;
_.surface = null;
function $toEvents(this$static, nativeEvent, flags){
  var id, nativeTouches, nativeTouchesLen, t, touch, touches, x, xy, y;
  nativeTouches = nativeEvent.changedTouches;
  nativeTouchesLen = nativeTouches.length;
  touches = initDim(_3Lplayn_core_Touch$Event$Impl_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Touch$Event$Impl, nativeTouchesLen, 0);
  for (t = 0; t < nativeTouchesLen; ++t) {
    touch = nativeTouches[t];
    x = $getRelativeX(touch, this$static.rootElement);
    y = $getRelativeY(touch, this$static.rootElement);
    xy = $transformMouse(this$static.platform.graphics, x, y);
    id = nativeEvent.changedTouches[t].identifier || 0;
    touches[t] = new Touch$Event$Impl_0(flags, now_0(), xy.x, xy.y, id);
  }
  return touches;
}

function HtmlTouch_0(platform, rootElement){
  $clinit_TouchImpl();
  this.activeLayers = new HashMap_0;
  this.platform = platform;
  this.rootElement = rootElement;
  captureEvent(rootElement, 'touchstart', new HtmlTouch$1_0(this));
  captureEvent_0('touchmove', new HtmlInput$1_0(new HtmlTouch$2_0(this)));
  captureEvent_0('touchend', new HtmlInput$1_0(new HtmlTouch$3_0(this)));
}

defineSeed(483, 384, {}, HtmlTouch_0);
_.inTouchSequence = false;
_.platform = null;
_.rootElement = null;
function HtmlTouch$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(484, 1, {}, HtmlTouch$1_0);
_.handleEvent = function handleEvent_17(nativeEvent){
  var flags;
  this.this$0.inTouchSequence = true;
  flags = new Events$Flags$Impl_0;
  $onTouchStart(this.this$0, $toEvents(this.this$0, nativeEvent, flags));
  flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
function HtmlTouch$2_0(this$0){
  this.this$0 = this$0;
}

defineSeed(485, 1, {}, HtmlTouch$2_0);
_.handleEvent = function handleEvent_18(nativeEvent){
  var flags;
  if (this.this$0.inTouchSequence) {
    flags = new Events$Flags$Impl_0;
    $onTouchMove(this.this$0, $toEvents(this.this$0, nativeEvent, flags));
    flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
function HtmlTouch$3_0(this$0){
  this.this$0 = this$0;
}

defineSeed(486, 1, {}, HtmlTouch$3_0);
_.handleEvent = function handleEvent_19(nativeEvent){
  var flags;
  if (this.this$0.inTouchSequence) {
    flags = new Events$Flags$Impl_0;
    $onTouchEnd(this.this$0, $toEvents(this.this$0, nativeEvent, flags));
    flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
    nativeEvent.touches.length == 0 && (this.this$0.inTouchSequence = false);
  }
}
;
_.this$0 = null;
function $clinit_HtmlUrlParameters(){
  $clinit_HtmlUrlParameters = nullMethod;
  checkGLErrors = $equals('check', (ensureParameterMap() , $get_6(paramMap, 'glerrors')));
  $equals('quad', (ensureParameterMap() , $get_6(paramMap, 'glshader')));
}

var checkGLErrors;
function getRandom(){
  var $e0, random, val;
  random = Math.random();
  val = (ensureParameterMap() , $get_6(paramMap, 'analytics'));
  if (val != null) {
    try {
      random = parseFloat_0(val);
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (!instanceOf($e0, Q$Exception))
        throw $e0;
    }
  }
  return random;
}

function requestedMode(){
  var renderer;
  renderer = (ensureParameterMap() , $get_6(paramMap, 'renderer'));
  if ($equals('canvas', renderer)) {
    return 1;
  }
   else if ($equals('gl', renderer)) {
    return 0;
  }
   else if ($equals('dom', renderer)) {
    return 2;
  }
  return 3;
}

defineSeed(489, 1, makeCastMap([Q$AbstractDimension]));
_.equals$ = function equals_15(obj){
  var d;
  if (obj === this) {
    return true;
  }
  if (instanceOf(obj, Q$AbstractDimension)) {
    d = obj;
    return d.width_0 == this.width_0 && d.height_0 == this.height_0;
  }
  return false;
}
;
--></script>
<script><!--
_.hashCode$ = function hashCode_16(){
  return round_int(this.width_0) ^ round_int(this.height_0);
}
;
_.toString$ = function toString_43(){
  return $clinit_Dimensions() , this.width_0 + 'x' + this.height_0;
}
;
defineSeed(490, 1, {});
function $direction(this$static, other){
  return atan2(other.y - this$static.y, other.x - this$static.x);
}

function $distance_0(this$static, p){
  return $clinit_Points() , sqrt(distanceSq(this$static.x, this$static.y, p.x, p.y));
}

function $distanceSq(this$static, p){
  return distanceSq(this$static.x, this$static.y, p.x, p.y);
}

defineSeed(491, 1, makeCastMap([Q$AbstractPoint]));
_.equals$ = function equals_16(obj){
  var p;
  if (obj === this) {
    return true;
  }
  if (instanceOf(obj, Q$AbstractPoint)) {
    p = obj;
    return this.x_0() == p.x && this.y_0() == p.y;
  }
  return false;
}
;
_.hashCode$ = function hashCode_17(){
  return round_int(this.x_0()) ^ round_int(this.y_0());
}
;
_.toString$ = function toString_44(){
  return pointToString(this.x_0(), this.y_0());
}
;
function $centerX(this$static){
  return this$static.x + this$static.width_0 / 2;
}

function $centerY(this$static){
  return this$static.y + this$static.height_0 / 2;
}

defineSeed(493, 1, {});
defineSeed(492, 493, makeCastMap([Q$AbstractRectangle]));
_.equals$ = function equals_17(obj){
  var r;
  if (obj === this) {
    return true;
  }
  if (instanceOf(obj, Q$AbstractRectangle)) {
    r = obj;
    return r.x == this.x && r.y == this.y && r.width_0 == this.width_0 && r.height_0 == this.height_0;
  }
  return false;
}
;
_.hashCode$ = function hashCode_18(){
  return round_int(this.x) ^ round_int(this.y) ^ round_int(this.width_0) ^ round_int(this.height_0);
}
;
_.toString$ = function toString_45(){
  return ($clinit_Dimensions() , this.width_0 + 'x' + this.height_0) + pointToString(this.x, this.y);
}
;
defineSeed(494, 1, makeCastMap([Q$AbstractVector]));
_.equals$ = function equals_18(obj){
  var p;
  if (obj === this) {
    return true;
  }
  if (instanceOf(obj, Q$AbstractVector)) {
    p = obj;
    return this.x_0() == p.x && this.y_0() == p.y;
  }
  return false;
}
;
_.hashCode$ = function hashCode_19(){
  return round_int(this.x_0()) ^ round_int(this.y_0());
}
;
_.toString$ = function toString_46(){
  return vectorToString(this.x_0(), this.y_0());
}
;
function Dimension_0(){
  this.width_0 = 0;
  this.height_0 = 0;
}

defineSeed(495, 489, makeCastMap([Q$Serializable, Q$AbstractDimension]), Dimension_0);
_.height_0 = 0;
_.width_0 = 0;
function $clinit_Dimensions(){
  $clinit_Dimensions = nullMethod;
  new Dimension_0;
}

function $setLine(this$static, x1, y1, x2, y2){
  this$static.x1 = x1;
  this$static.y1 = y1;
  this$static.x2 = x2;
  this$static.y2 = y2;
}

function Line_0(){
}

function Line_1(x1, y1, x2, y2){
  $setLine(this, x1, y1, x2, y2);
}

defineSeed(497, 490, makeCastMap([Q$Serializable]), Line_0, Line_1);
_.x1 = 0;
_.x2 = 0;
_.y1 = 0;
_.y2 = 0;
function pointSegDistSq(px, py, x1, y1, x2, y2){
  var dist;
  x2 -= x1;
  y2 -= y1;
  px -= x1;
  py -= y1;
  if (px * x2 + py * y2 <= 0) {
    dist = px * px + py * py;
  }
   else {
    px = x2 - px;
    py = y2 - py;
    if (px * x2 + py * y2 <= 0) {
      dist = px * px + py * py;
    }
     else {
      dist = px * y2 - py * x2;
      dist = dist * dist / (x2 * x2 + y2 * y2);
    }
  }
  dist < 0 && (dist = 0);
  return dist;
}

function iceil(v){
  var iv;
  iv = round_int(v);
  return v <= 0 || iv == v || iv == 2147483647?iv:iv + 1;
}

function toString_47(value){
  var buf, ii, ivalue;
  buf = new StringBuilder_0;
  if (value >= 0) {
    buf.impl.string += '+';
  }
   else {
    buf.impl.string += '-';
    value = -value;
  }
  ivalue = round_int(value);
  $append_1(buf.impl, ivalue);
  buf.impl.string += '.';
  for (ii = 0; ii < 3; ++ii) {
    value = (value - ivalue) * 10;
    ivalue = round_int(value);
    $append_1(buf.impl, ivalue);
  }
  for (ii = 0; ii < 2; ++ii) {
    $charAt_0(buf, buf.impl.string.length - 1) == 48 && $setLength(buf, buf.impl.string.length - 1);
  }
  return buf.impl.string;
}

function $set_17(this$static, x, y){
  this$static.x = x;
  this$static.y = y;
  return this$static;
}

function $set_18(this$static, p){
  return $set_17(this$static, p.x, p.y);
}

function Point_0(){
}

function Point_1(x, y){
  $set_17(this, x, y);
}

defineSeed(500, 491, makeCastMap([Q$Serializable, Q$AbstractPoint]), Point_0, Point_1);
_.x_0 = function x_0(){
  return this.x;
}
;
_.y_0 = function y_0(){
  return this.y;
}
;
_.x = 0;
_.y = 0;
function $clinit_Points(){
  $clinit_Points = nullMethod;
  new Point_1(0, 0);
}

function distanceSq(x1, y1, x2, y2){
  $clinit_Points();
  x2 -= x1;
  y2 -= y1;
  return x2 * x2 + y2 * y2;
}

function pointToString(x, y){
  $clinit_Points();
  return toString_47(x) + toString_47(y);
}

function $setBounds(this$static, width, height){
  this$static.x = 0;
  this$static.y = 0;
  this$static.height_0 = height;
  this$static.width_0 = width;
}

function Rectangle_0(){
}

defineSeed(502, 492, makeCastMap([Q$Serializable, Q$AbstractRectangle]), Rectangle_0);
_.height_0 = 0;
_.width_0 = 0;
_.x = 0;
_.y = 0;
function multiply_1(am00, am01, am10, am11, atx, aty, bm00, bm01, bm10, bm11, btx, bty, into){
  into.m00 = am00 * bm00 + am10 * bm01;
  into.m01 = am01 * bm00 + am11 * bm01;
  into.m10 = am00 * bm10 + am10 * bm11;
  into.m11 = am01 * bm10 + am11 * bm11;
  into.tx = am00 * btx + am10 * bty + atx;
  into.ty = am01 * btx + am11 * bty + aty;
  return into;
}

function multiply_2(a, b, into){
  return multiply_1(a.m00, a.m01, a.m10, a.m11, a.tx, a.ty, b.m00, b.m01, b.m10, b.m11, b.tx, b.ty, into);
}

function $set_19(this$static, x, y){
  this$static.x = x;
  this$static.y = y;
  return this$static;
}

function Vector_1(){
}

function Vector_2(x, y){
  $set_19(this, x, y);
}

defineSeed(504, 494, makeCastMap([Q$AbstractVector]), Vector_1, Vector_2);
_.x_0 = function x_1(){
  return this.x;
}
;
_.y_0 = function y_1(){
  return this.y;
}
;
_.x = 0;
_.y = 0;
function $clinit_Vectors(){
  $clinit_Vectors = nullMethod;
  new Vector_2(1, 0);
  new Vector_2(0, 1);
  new Vector_2(0, 0);
  new Vector_2(-3.4028234663852886E38, -3.4028234663852886E38);
  new Vector_2(3.4028234663852886E38, 3.4028234663852886E38);
}

function vectorToString(x, y){
  $clinit_Vectors();
  return toString_47(x) + toString_47(y);
}

function NoninvertibleTransformException_0(s){
  RuntimeException_1.call(this, s);
}

defineSeed(506, 45, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), NoninvertibleTransformException_0);
defineSeed(507, 1, {});
function $drawPose(this$static){
  var i, n, transform;
  n = this$static.pose.boneCount;
  for (i = 0; i < n; ++i) {
    transform = $getBoneTransform(this$static.pose, i);
    $set_17(this$static.p1, 0, 0);
    $set_17(this$static.p2, 1, 0);
    $transform_1(transform, this$static.p1, this$static.p1);
    $transform_1(transform, this$static.p2, this$static.p2);
    this$static.surface.drawLine(this$static.p1.x, this$static.p1.y, this$static.p2.x, this$static.p2.y, this$static.lineWidth_0);
  }
}

function $drawSkeleton(this$static, skeleton){
  $setSkeleton(this$static.pose, skeleton);
  $setType(this$static.pose);
  $drawPose(this$static);
}

function $drawSkeletonGraph(this$static, graph){
  var child, i, n, p1, p2, parent_0;
  n = graph.vertexCount;
  for (i = 0; i < n; ++i) {
    child = $get(graph.vertices, i);
    parent_0 = child.parent_0;
    if (parent_0) {
      p1 = child.position_0;
      p2 = parent_0.position_0;
      this$static.surface.drawLine(p1.x, p1.y, p2.x, p2.y, this$static.lineWidth_0);
    }
  }
}

function $setLineWidth_0(this$static, lineWidth){
  this$static.lineWidth_0 = lineWidth;
}

function AnimationDrawHandler_0(surface){
  this.pose = new Pose_0;
  this.p1 = new Point_0;
  this.p2 = new Point_0;
  this.surface = surface;
}

defineSeed(508, 1, {}, AnimationDrawHandler_0);
_.lineWidth_0 = 1;
_.surface = null;
function $setParent_0(this$static, parent_0){
  this$static.parent_0 = parent_0;
}

function Bone_0(index){
  this.transform_0 = new AffineTransform_0;
  this.index_0 = index;
}

defineSeed(509, 1, {}, Bone_0);
_.index_0 = 0;
_.parent_0 = null;
function $getInverseTransform(this$static){
  $updateTransforms(this$static);
  return this$static.inverseTransform;
}

function $getTransform_0(this$static){
  $updateTransforms(this$static);
  return this$static.transform_0;
}

function $setScale_0(this$static, scale){
  this$static.scale_0 = scale;
  this$static.dirty = true;
}

function $setViewport(this$static, width, height){
  $setBounds(this$static.viewport_0, width, height);
  this$static.dirty = true;
}

function $updateTransforms(this$static){
  var minSize;
  if (this$static.dirty) {
    minSize = min(this$static.viewport_0.width_0, this$static.viewport_0.height_0);
    $setTransform(this$static.transform_0, 1, 0, 0, 1, 0, 0);
    $translate_0(this$static.transform_0, $centerX(this$static.viewport_0), $centerY(this$static.viewport_0));
    $scale_1(this$static.transform_0, 1, -1);
    $uniformScale_0(this$static.transform_0, 0.5 * minSize / this$static.scale_0);
    $rotate(this$static.transform_0, -0.);
    $translate_0(this$static.transform_0, -this$static.position_0.x, -this$static.position_0.y);
    invert(this$static.transform_0, this$static.inverseTransform);
    this$static.dirty = false;
  }
}

function Camera_0(){
  this.position_0 = new Point_0;
  this.viewport_0 = new Rectangle_0;
  this.transform_0 = new AffineTransform_0;
  this.inverseTransform = new AffineTransform_0;
}

defineSeed(510, 1, {}, Camera_0);
_.dirty = true;
_.scale_0 = 1;
defineSeed(511, 1, {});
_.exit = function exit_0(){
}
;
_.init_0 = function init_4(){
}
;
_.onKeyDown = function onKeyDown(event_0){
}
;
_.onMouseDown = function onMouseDown(event_0){
}
;
_.onMouseMove = function onMouseMove(event_0){
}
;
_.onMouseUp = function onMouseUp(event_0){
}
;
_.onPointerDrag = function onPointerDrag(event_0){
}
;
_.onPointerEnd = function onPointerEnd(event_0){
}
;
_.onPointerStart = function onPointerStart(event_0){
}
;
function $onKeyDown(this$static, event_0){
  !!this$static.screen_0 && this$static.screen_0.onKeyDown(event_0);
}

function $onKeyTyped(this$static, event_0){
  !!this$static.screen_0 && this$static.screen_0.onKeyTyped(event_0);
}

function $onKeyUp(this$static, event_0){
  !!this$static.screen_0 && this$static.screen_0.onKeyUp(event_0);
}

function $onMouseDown_0(this$static, event_0){
  !!this$static.screen_0 && this$static.screen_0.onMouseDown(event_0);
}

function $onMouseMove_0(this$static, event_0){
  !!this$static.screen_0 && this$static.screen_0.onMouseMove(event_0);
}

function $onMouseUp_0(this$static, event_0){
  !!this$static.screen_0 && this$static.screen_0.onMouseUp(event_0);
}

function $onMouseWheelScroll_0(this$static, event_0){
  !!this$static.screen_0 && this$static.screen_0.onMouseWheelScroll(event_0);
}

function $onPointerDrag_0(this$static, event_0){
  !!this$static.screen_0 && this$static.screen_0.onPointerDrag(event_0);
}

function $onPointerEnd_0(this$static, event_0){
  !!this$static.screen_0 && this$static.screen_0.onPointerEnd(event_0);
}

function $onPointerStart_0(this$static, event_0){
  !!this$static.screen_0 && this$static.screen_0.onPointerStart(event_0);
}

function $setScreen(this$static, screen_0){
  !!this$static.screen_0 && this$static.screen_0.exit();
  this$static.screen_0 = screen_0;
  !!this$static.screen_0 && this$static.screen_0.init_0();
}

function CrustGame_0(){
  this.updateRate = 33;
}

defineSeed(512, 354, {}, CrustGame_0);
_.assets = null;
_.screen_0 = null;
function $drawCircle(this$static, x, y, radius, lineWidth){
  var angle1, angle2, i, j, x1, x2, y1, y2;
  for (i = 0; i < 16; ++i) {
    j = (i + 1) % 16;
    angle1 = 6.2831854820251465 * i / 16;
    angle2 = 6.2831854820251465 * j / 16;
    x1 = Math.cos(angle1);
    y1 = Math.sin(angle1);
    x2 = Math.cos(angle2);
    y2 = Math.sin(angle2);
    this$static.surface.drawLine(x + radius * x1, y + radius * y1, x + radius * x2, y + radius * y2, lineWidth);
  }
}

function DrawHandler_0(surface){
  this.surface = surface;
}

defineSeed(513, 1, {}, DrawHandler_0);
_.surface = null;
defineSeed(515, 1, {});
_.exit = function exit_1(){
}
;
_.init_0 = function init_5(){
}
;
_.onKeyDown = function onKeyDown_0(event_0){
}
;
_.onKeyTyped = function onKeyTyped(event_0){
}
;
_.onKeyUp = function onKeyUp(event_0){
}
;
_.onMouseDown = function onMouseDown_0(event_0){
}
;
_.onMouseMove = function onMouseMove_0(event_0){
}
;
_.onMouseUp = function onMouseUp_0(event_0){
}
;
_.onMouseWheelScroll = function onMouseWheelScroll(event_0){
}
;
_.onPointerDrag = function onPointerDrag_0(event_0){
}
;
_.onPointerEnd = function onPointerEnd_0(event_0){
}
;
_.onPointerStart = function onPointerStart_0(event_0){
}
;
_.paint_2 = function paint_8(alpha){
}
;
_.update_0 = function update_1(delta){
}
;
function $addActor(this$static, actor){
  var world, bodyDef, circleShape, fixtureDef;
  $add_0(this$static.actors, actor);
  world = actor.gameScreen.world;
  bodyDef = new BodyDef_0;
  bodyDef.type_0 = ($clinit_BodyType() , DYNAMIC);
  actor.body_0 = $createBody(world, bodyDef);
  circleShape = new CircleShape_0;
  circleShape.m_radius = 0.5;
  fixtureDef = new FixtureDef_0;
  fixtureDef.shape = circleShape;
  $createFixture(actor.body_0, fixtureDef);
}

function GameScreen_0(game){
  this.camera = new Camera_0;
  this.world = new World_0(new Vec2_1(0, -10));
  this.actors = new ArrayList_0;
  this.game = game;
}

defineSeed(514, 515, {}, GameScreen_0);
_.exit = function exit_2(){
  platform_1.graphics.rootLayer_0().remove_4(this.groupLayer);
}
;
_.init_0 = function init_6(){
  $setScale_0(this.camera, 5);
  $setViewport(this.camera, platform_1.graphics.width_2(), platform_1.graphics.height_2());
  this.groupLayer = platform_1.graphics.createGroupLayer();
  platform_1.graphics.rootLayer_0().add_1(this.groupLayer);
  this.debugLayer = platform_1.graphics.createSurfaceLayer(platform_1.graphics.width_2(), platform_1.graphics.height_2());
  this.debugSurface = this.debugLayer.surface_0();
  this.groupLayer.add_1(this.debugLayer);
  this.physicsDebugDrawHandler = new PhysicsDebugDrawHandler_0(this.debugSurface);
  this.physicsDebugDrawHandler.m_drawFlags = 1;
  $setDebugDraw(this.world, this.physicsDebugDrawHandler);
  $addActor(this, new MonsterActor_0(this));
}
;
_.onKeyDown = function onKeyDown_1(event_0){
  event_0.key_0.ordinal == 121 && $setScreen(this.game, new TitleScreen_0(this.game));
}
;
_.paint_2 = function paint_9(alpha){
  var actor$iterator, transform;
  this.debugSurface.clear_0();
  this.debugSurface.save_0();
  transform = $getTransform_0(this.camera);
  this.debugSurface.transform_2(transform.m00, transform.m01, transform.m10, transform.m11, transform.tx, transform.ty);
  this.debugSurface.setFillColor(-16711936);
  $drawDebugData(this.world);
  for (actor$iterator = new AbstractList$IteratorImpl_0(this.actors); actor$iterator.i < actor$iterator.this$0_0.size_0();) {
    $next_2(actor$iterator);
  }
  this.debugSurface.restore_0();
}
;
_.update_0 = function update_2(delta){
  var actor$iterator;
  for (actor$iterator = new AbstractList$IteratorImpl_0(this.actors); actor$iterator.i < actor$iterator.this$0_0.size_0();) {
    $next_2(actor$iterator);
  }
  $step(this.world, 0.0010000000474974513 * delta);
}
;
_.debugLayer = null;
_.debugSurface = null;
_.game = null;
_.groupLayer = null;
_.physicsDebugDrawHandler = null;
function MonsterActor_0(gameScreen){
  this.gameScreen = gameScreen;
}

defineSeed(516, 507, {}, MonsterActor_0);
_.body_0 = null;
_.gameScreen = null;
function $drawCircle_0(this$static, center, radius){
  this$static.surface.save_0();
  this$static.surface.translate_0(center.x, center.y);
  this$static.surface.scale_1(radius, radius);
  this$static.surface.fillTriangles(this$static.circleCoords, this$static.circleIndices);
  this$static.surface.restore_0();
}

function $drawSolidPolygon(this$static, vertices, vertexCount){
  var i;
  for (i = 0; i < this$static.maxPolygonVertexCount; ++i) {
    if (i < vertexCount) {
      this$static.polygonCoords[2 * i] = vertices[i].x;
      this$static.polygonCoords[2 * i + 1] = vertices[i].y;
    }
     else {
      this$static.polygonCoords[2 * i] = vertices[0].x;
      this$static.polygonCoords[2 * i + 1] = vertices[0].y;
    }
  }
  this$static.surface.fillTriangles(this$static.polygonCoords, this$static.polygonIndices);
}

function PhysicsDebugDrawHandler_0(surface){
  var angle, i;
  this.m_drawFlags = 0;
  this.viewportTransform = null;
  this.maxPolygonVertexCount = ($clinit_Settings() , 8);
  this.polygonCoords = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 2 * this.maxPolygonVertexCount, 1);
  this.polygonIndices = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 3 * (this.maxPolygonVertexCount - 2), 1);
  this.circleCoords = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 34, 1);
  this.circleIndices = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 48, 1);
  this.surface = surface;
  for (i = 0; i < 16; ++i) {
    angle = 6.2831854820251465 * i / 16;
    this.circleCoords[2 + 2 * i] = Math.cos(angle);
    this.circleCoords[2 + 2 * i + 1] = Math.sin(angle);
    this.circleIndices[3 * i + 1] = 1 + i;
    this.circleIndices[3 * i + 2] = 1 + (i + 1) % 16;
  }
}

defineSeed(517, 260, {}, PhysicsDebugDrawHandler_0);
_.surface = null;
function $$init_2(this$static){
  this$static.boneTransforms = new ArrayList_0;
}

function $getBoneTransform(this$static, boneIndex){
  return $get(this$static.boneTransforms, boneIndex);
}

function $setBoneCount(this$static, boneCount){
  this$static.boneCount = boneCount;
  while (this$static.boneTransforms.size < boneCount) {
    $add_0(this$static.boneTransforms, new AffineTransform_0);
  }
}

function $setSkeleton(this$static, skeleton){
  var i, bone;
  this$static.skeleton = skeleton;
  this$static.type_0 = 0;
  if (skeleton) {
    $setBoneCount(this$static, skeleton.boneCount);
    for (i = 0; i < this$static.boneCount; ++i) {
      copy_0((bone = $get(skeleton.bones, i) , bone.transform_0), $get(this$static.boneTransforms, i));
    }
  }
   else {
    $setBoneCount(this$static, 0);
  }
}

function $setType(this$static){
  var i, j;
  if (1 != this$static.type_0) {
    this$static.type_0 = 1;
    for (i = 0; i < this$static.boneCount; ++i) {
      j = $getParentBoneIndex(this$static.skeleton, i);
      j != -1 && multiply_2($get(this$static.boneTransforms, j), $get(this$static.boneTransforms, i), $get(this$static.boneTransforms, i));
    }
  }
}

function Pose_0(){
  $$init_2(this);
}

function Pose_1(skeleton){
  $$init_2(this);
  $setSkeleton(this, skeleton);
}

defineSeed(518, 1, {}, Pose_0, Pose_1);
_.boneCount = 0;
_.skeleton = null;
_.type_0 = 0;
function $getBone(this$static, boneIndex){
  return $get(this$static.bones, boneIndex);
}

function $getParentBoneIndex(this$static, boneIndex){
  var bone, parentBone;
  bone = $get(this$static.bones, boneIndex);
  parentBone = bone.parent_0;
  return parentBone?parentBone.index_0:-1;
}

function $setBoneCount_0(this$static, boneCount){
  var bone;
  this$static.boneCount = boneCount;
  while (this$static.bones.size < boneCount) {
    bone = new Bone_0(this$static.bones.size);
    $add_0(this$static.bones, bone);
  }
}

function Skeleton_0(){
  this.bones = new ArrayList_0;
}

defineSeed(519, 1, {}, Skeleton_0);
_.boneCount = 0;
function $updateBone(this$static){
  $setTransform(this$static.bone.transform_0, 1, 0, 0, 1, 0, 0);
  $translate_0(this$static.bone.transform_0, this$static.startPoint.x, this$static.startPoint.y);
  $rotate(this$static.bone.transform_0, $direction(this$static.startPoint, this$static.endPoint));
  $uniformScale_0(this$static.bone.transform_0, $distance_0(this$static.startPoint, this$static.endPoint));
}

function SkeletonEditorCreateBoneController_0(screen_0, position){
  this.startPoint = new Point_0;
  this.endPoint = new Point_0;
  this.screen_0 = screen_0;
  $set_18(this.startPoint, position);
  $set_18(this.endPoint, position);
}

defineSeed(520, 511, {}, SkeletonEditorCreateBoneController_0);
_.exit = function exit_3(){
}
;
_.init_0 = function init_7(){
  this.camera = this.screen_0.camera;
  this.skeleton = this.screen_0.skeleton;
  $setBoneCount_0(this.skeleton, this.skeleton.boneCount + 1);
  this.bone = $getBone(this.skeleton, this.skeleton.boneCount - 1);
  $updateBone(this);
}
;
_.onMouseMove = function onMouseMove_1(event_0){
  $set_17(this.startPoint, event_0.x, event_0.y);
  $transform_1($getInverseTransform(this.camera), this.startPoint, this.startPoint);
  $snap(this.startPoint, this.skeleton, this.bone.index_0, this.startPoint);
  $updateBone(this);
}
;
_.onMouseUp = function onMouseUp_1(event_0){
  var controller, featureIndex, parentBoneIndex, parentBoneTransform, pose;
  featureIndex = $getSkeletonFeatureIndex_0(this.screen_0, this.startPoint, this.skeleton.boneCount - 1);
  if (featureIndex != -1) {
    parentBoneIndex = ~~(featureIndex / 2);
    $setParent_0(this.bone, $getBone(this.skeleton, parentBoneIndex));
    pose = new Pose_1(this.skeleton);
    $setType(pose);
    parentBoneTransform = $get(pose.boneTransforms, parentBoneIndex);
    $inverseTransform(parentBoneTransform, this.startPoint, this.startPoint);
    $inverseTransform(parentBoneTransform, this.endPoint, this.endPoint);
    $updateBone(this);
  }
  controller = new SkeletonEditorDefaultController_0(this.screen_0);
  $setController(this.screen_0, controller);
}
;
_.bone = null;
_.camera = null;
_.screen_0 = null;
_.skeleton = null;
function SkeletonEditorDefaultController_0(screen_0){
  this.screen_0 = screen_0;
}

defineSeed(521, 511, {}, SkeletonEditorDefaultController_0);
_.init_0 = function init_8(){
  this.camera = this.screen_0.camera;
}
;
_.onKeyDown = function onKeyDown_2(event_0){
  event_0.key_0.ordinal == 121 && $setScreen(this.screen_0.game, new TitleScreen_0(this.screen_0.game));
}
;
_.onMouseDown = function onMouseDown_1(event_0){
  var boneIndex, controller, featureIndex, position;
  position = new Point_1(event_0.x, event_0.y);
  $transform_1($getInverseTransform(this.camera), position, position);
  featureIndex = $getSkeletonFeatureIndex(this.screen_0, position);
  if (featureIndex == -1) {
    controller = new SkeletonEditorCreateBoneController_0(this.screen_0, position);
    $setController(this.screen_0, controller);
  }
   else {
    if (featureIndex % 2 == 0) {
      boneIndex = ~~(featureIndex / 2);
      controller = new SkeletonEditorMoveBoneController_0(this.screen_0, boneIndex, position);
      $setController(this.screen_0, controller);
    }
     else {
      boneIndex = ~~(featureIndex / 2);
      controller = new SkeletonEditorRotateAndScaleBoneController_0(this.screen_0, boneIndex, position);
      $setController(this.screen_0, controller);
    }
  }
}
;
_.camera = null;
_.screen_0 = null;
function SkeletonEditorMoveBoneController_0(screen_0, boneIndex, position){
  this.position_0 = new Point_0;
  this.parentTransform = new AffineTransform_0;
  this.offset = new Vector_1;
  this.screen_0 = screen_0;
  this.boneIndex = boneIndex;
  $set_18(this.position_0, position);
}

defineSeed(522, 511, {}, SkeletonEditorMoveBoneController_0);
_.init_0 = function init_9(){
  var parentBoneIndex, pose;
  this.camera = this.screen_0.camera;
  this.skeleton = this.screen_0.skeleton;
  this.bone = $getBone(this.skeleton, this.boneIndex);
  parentBoneIndex = $getParentBoneIndex(this.skeleton, this.boneIndex);
  if (parentBoneIndex != -1) {
    pose = new Pose_1(this.skeleton);
    $setType(pose);
    copy_0($get(pose.boneTransforms, parentBoneIndex), this.parentTransform);
  }
   else {
    $setTransform(this.parentTransform, 1, 0, 0, 1, 0, 0);
  }
  $inverseTransform(this.parentTransform, this.position_0, this.position_0);
  this.offset.x = this.position_0.x - this.bone.transform_0.tx;
  this.offset.y = this.position_0.y - this.bone.transform_0.ty;
  $transform_2(this.parentTransform, this.offset, this.offset);
}
;
_.onMouseMove = function onMouseMove_2(event_0){
  $set_17(this.position_0, event_0.x, event_0.y);
  $transform_1($getInverseTransform(this.camera), this.position_0, this.position_0);
  this.position_0.x -= this.offset.x;
  this.position_0.y -= this.offset.y;
  $snap(this.position_0, this.skeleton, this.bone.index_0, this.position_0);
  $inverseTransform(this.parentTransform, this.position_0, this.position_0);
  $setTranslation(this.bone.transform_0, this.position_0.x, this.position_0.y);
}
;
_.onMouseUp = function onMouseUp_2(event_0){
  var controller;
  controller = new SkeletonEditorDefaultController_0(this.screen_0);
  $setController(this.screen_0, controller);
}
;
_.bone = null;
_.boneIndex = 0;
_.camera = null;
_.screen_0 = null;
_.skeleton = null;
function SkeletonEditorRotateAndScaleBoneController_0(screen_0, boneIndex, position){
  this.startPoint = new Point_0;
  this.endPoint = new Point_0;
  this.parentTransform = new AffineTransform_0;
  this.screen_0 = screen_0;
  this.boneIndex = boneIndex;
  $set_18(this.endPoint, position);
}

defineSeed(523, 511, {}, SkeletonEditorRotateAndScaleBoneController_0);
_.init_0 = function init_10(){
  var parentBoneIndex, pose, skeleton;
  this.camera = this.screen_0.camera;
  skeleton = this.screen_0.skeleton;
  this.bone = $getBone(skeleton, this.boneIndex);
  parentBoneIndex = $getParentBoneIndex(skeleton, this.boneIndex);
  if (parentBoneIndex != -1) {
    pose = new Pose_1(skeleton);
    $setType(pose);
    copy_0($get(pose.boneTransforms, parentBoneIndex), this.parentTransform);
  }
   else {
    $setTransform(this.parentTransform, 1, 0, 0, 1, 0, 0);
  }
  $set_17(this.startPoint, this.bone.transform_0.tx, this.bone.transform_0.ty);
}
;
_.onMouseMove = function onMouseMove_3(event_0){
  $set_17(this.endPoint, event_0.x, event_0.y);
  $transform_1($getInverseTransform(this.camera), this.endPoint, this.endPoint);
  $inverseTransform(this.parentTransform, this.endPoint, this.endPoint);
  $setTransform(this.bone.transform_0, 1, 0, 0, 1, 0, 0);
  $setTranslation(this.bone.transform_0, this.startPoint.x, this.startPoint.y);
  $setRotation(this.bone.transform_0, $direction(this.startPoint, this.endPoint));
  $setUniformScale(this.bone.transform_0, $distance_0(this.startPoint, this.endPoint));
}
;
_.onMouseUp = function onMouseUp_3(event_0){
  var controller;
  controller = new SkeletonEditorDefaultController_0(this.screen_0);
  $setController(this.screen_0, controller);
}
;
_.bone = null;
_.boneIndex = 0;
_.camera = null;
_.screen_0 = null;
function $getSkeletonFeatureIndex(this$static, position){
  return $getSkeletonFeatureIndex_0(this$static, position, this$static.skeleton.boneCount);
}

function $getSkeletonFeatureIndex_0(this$static, position, boneCount){
  var i, line, lines, p1, p2, pose, transform;
  pose = new Pose_1(this$static.skeleton);
  $setType(pose);
  lines = new ArrayList_0;
  for (i = 0; i < boneCount; ++i) {
    p1 = new Point_1(0, 0);
    p2 = new Point_1(1, 0);
    transform = $get(pose.boneTransforms, i);
    $transform_1(transform, p1, p1);
    $transform_1(transform, p2, p2);
    line = new Line_1(p1.x, p1.y, p2.x, p2.y);
    setCheck(lines.array, lines.size++, line);
  }
  for (i = 0; i < boneCount; ++i) {
    line = (checkIndex(i, lines.size) , lines.array[i]);
    if (distanceSq(position.x, position.y, line.x2, line.y2) < 0.010000000707805157) {
      return 2 * i + 1;
    }
  }
  for (i = 0; i < boneCount; ++i) {
    line = (checkIndex(i, lines.size) , lines.array[i]);
    if (pointSegDistSq(position.x, position.y, line.x1, line.y1, line.x2, line.y2) < 0.010000000707805157) {
      return 2 * i;
    }
  }
  return -1;
}

function $setController(this$static, controller){
  this$static.controller.exit();
  this$static.controller = controller;
  this$static.controller.init_0();
}

function $snap(point, skeleton, boneIndex, result){
  var i, j, line, lines, mask, p1, p2, parentIndex, parentTransform, pose, snapped, transform;
  mask = P0_longLit;
  mask = or(mask, fromInt(1 << boneIndex));
  for (i = 0; i < skeleton.boneCount; ++i) {
    j = $getParentBoneIndex(skeleton, i);
    j != -1 && neq(and(mask, fromInt(1 << j)), P0_longLit) && (mask = or(mask, fromInt(1 << i)));
  }
  pose = new Pose_1(skeleton);
  $setType(pose);
  lines = new ArrayList_0;
  for (i = 0; i < skeleton.boneCount; ++i) {
    if (eq(and(mask, fromInt(1 << i)), P0_longLit)) {
      p1 = new Point_1(0, 0);
      p2 = new Point_1(1, 0);
      transform = $get(pose.boneTransforms, i);
      $transform_1(transform, p1, p1);
      $transform_1(transform, p2, p2);
      line = new Line_1(p1.x, p1.y, p2.x, p2.y);
      setCheck(lines.array, lines.size++, line);
    }
  }
  $set_17(result, point.x, point.y);
  parentTransform = new AffineTransform_0;
  parentIndex = $getParentBoneIndex(skeleton, boneIndex);
  parentIndex != -1 && copy_0($get(pose.boneTransforms, parentIndex), parentTransform);
  snapped = false;
  for (i = 0; i < lines.size; ++i) {
    line = (checkIndex(i, lines.size) , lines.array[i]);
    if (distanceSq(result.x, result.y, line.x2, line.y2) < 0.010000000707805157) {
      $set_17(result, line.x2, line.y2);
      snapped = true;
      break;
    }
  }
  if (!snapped) {
    for (i = 0; i < lines.size; ++i) {
      line = (checkIndex(i, lines.size) , lines.array[i]);
      if (distanceSq(result.x, result.y, line.x1, line.y1) < 0.010000000707805157) {
        $set_17(result, line.x1, line.y1);
        snapped = true;
        break;
      }
    }
  }
  if (!snapped) {
    for (i = 0; i < lines.size; ++i) {
      line = (checkIndex(i, lines.size) , lines.array[i]);
      if (pointSegDistSq(result.x, result.y, line.x1, line.y1, line.x2, line.y2) < 0.010000000707805157) {
        snap(result, line, result);
        break;
      }
    }
  }
}

function SkeletonEditorScreen_0(game){
  this.camera = new Camera_0;
  this.skeleton = new Skeleton_0;
  this.game = game;
}

--></script>
<script><!--
defineSeed(524, 515, {}, SkeletonEditorScreen_0);
_.exit = function exit_4(){
  this.controller.exit();
  platform_1.graphics.rootLayer_0().remove_4(this.groupLayer);
}
;
_.init_0 = function init_11(){
  $setScale_0(this.camera, 2);
  $setViewport(this.camera, platform_1.graphics.width_2(), platform_1.graphics.height_2());
  this.groupLayer = platform_1.graphics.createGroupLayer();
  platform_1.graphics.rootLayer_0().add_1(this.groupLayer);
  this.debugLayer = platform_1.graphics.createSurfaceLayer(platform_1.graphics.width_2(), platform_1.graphics.height_2());
  this.debugSurface = this.debugLayer.surface_0();
  this.groupLayer.add_1(this.debugLayer);
  $setBoneCount_0(this.skeleton, 10);
  $setRotation($getBone(this.skeleton, 0).transform_0, 1.5707963705062866);
  $setUniformScale($getBone(this.skeleton, 0).transform_0, 0.550000011920929);
  $setParent_0($getBone(this.skeleton, 1), $getBone(this.skeleton, 0));
  $setTranslation($getBone(this.skeleton, 1).transform_0, 1, 0);
  $setUniformScale($getBone(this.skeleton, 1).transform_0, 0.6363636255264282);
  $setParent_0($getBone(this.skeleton, 2), $getBone(this.skeleton, 0));
  $setRotation($getBone(this.skeleton, 2).transform_0, -3.1415927410125732);
  $setUniformScale($getBone(this.skeleton, 2).transform_0, 0.8181817531585693);
  $setParent_0($getBone(this.skeleton, 3), $getBone(this.skeleton, 2));
  $setTranslation($getBone(this.skeleton, 3).transform_0, 1, 0);
  $setRotation($getBone(this.skeleton, 3).transform_0, -0.7853981852531433);
  $setParent_0($getBone(this.skeleton, 4), $getBone(this.skeleton, 0));
  $setRotation($getBone(this.skeleton, 4).transform_0, -2.356194496154785);
  $setUniformScale($getBone(this.skeleton, 4).transform_0, 0.8181817531585693);
  $setParent_0($getBone(this.skeleton, 5), $getBone(this.skeleton, 4));
  $setTranslation($getBone(this.skeleton, 5).transform_0, 1, 0);
  $setRotation($getBone(this.skeleton, 5).transform_0, -0.7853981852531433);
  $setParent_0($getBone(this.skeleton, 6), $getBone(this.skeleton, 0));
  $setTranslation($getBone(this.skeleton, 6).transform_0, 1, 0);
  $setRotation($getBone(this.skeleton, 6).transform_0, -2.356194496154785);
  $setUniformScale($getBone(this.skeleton, 6).transform_0, 0.6363636255264282);
  $setParent_0($getBone(this.skeleton, 7), $getBone(this.skeleton, 6));
  $setTranslation($getBone(this.skeleton, 7).transform_0, 1, 0);
  $setRotation($getBone(this.skeleton, 7).transform_0, 0.7853981852531433);
  $setParent_0($getBone(this.skeleton, 8), $getBone(this.skeleton, 0));
  $setTranslation($getBone(this.skeleton, 8).transform_0, 1, 0);
  $setRotation($getBone(this.skeleton, 8).transform_0, -1.5707963705062866);
  $setUniformScale($getBone(this.skeleton, 8).transform_0, 0.6363636255264282);
  $setParent_0($getBone(this.skeleton, 9), $getBone(this.skeleton, 8));
  $setTranslation($getBone(this.skeleton, 9).transform_0, 1, 0);
  $setRotation($getBone(this.skeleton, 9).transform_0, 0.7853981852531433);
  this.animationDrawHandler = new AnimationDrawHandler_0(this.debugSurface);
  this.controller = new SkeletonEditorDefaultController_0(this);
  this.controller.init_0();
}
;
_.onKeyDown = function onKeyDown_3(event_0){
  this.controller.onKeyDown(event_0);
}
;
_.onKeyTyped = function onKeyTyped_0(event_0){
}
;
_.onKeyUp = function onKeyUp_0(event_0){
}
;
_.onMouseDown = function onMouseDown_2(event_0){
  this.controller.onMouseDown(event_0);
}
;
_.onMouseMove = function onMouseMove_4(event_0){
  this.controller.onMouseMove(event_0);
}
;
_.onMouseUp = function onMouseUp_4(event_0){
  this.controller.onMouseUp(event_0);
}
;
_.onMouseWheelScroll = function onMouseWheelScroll_0(event_0){
}
;
_.paint_2 = function paint_10(alpha){
  var transform;
  this.debugSurface.clear_0();
  this.debugSurface.save_0();
  transform = $getTransform_0(this.camera);
  this.debugSurface.transform_2(transform.m00, transform.m01, transform.m10, transform.m11, transform.tx, transform.ty);
  this.debugSurface.setFillColor(-16711936);
  $setLineWidth_0(this.animationDrawHandler, 1 / $uniformScale(transform));
  $drawSkeleton(this.animationDrawHandler, this.skeleton);
  this.debugSurface.restore_0();
}
;
_.update_0 = function update_3(delta){
}
;
_.animationDrawHandler = null;
_.controller = null;
_.debugLayer = null;
_.debugSurface = null;
_.game = null;
_.groupLayer = null;
function $grab(this$static, graph, position, maxDistance){
  var vertex;
  vertex = null;
  vertex = $grabVertex(graph, position, maxDistance);
  !vertex && (vertex = $grabEdge(this$static, graph, position, maxDistance));
  return vertex;
}

function $grabEdge(this$static, graph, position, maxDistance){
  var currentPosition, currentVertex, i, minSquaredDistance, n, parentPosition, snapVertex, squaredDistance, vertex;
  vertex = null;
  minSquaredDistance = maxDistance * maxDistance;
  n = graph.vertexCount;
  for (i = 0; i < n; ++i) {
    currentVertex = $get(graph.vertices, i);
    if (currentVertex.parent_0) {
      currentPosition = currentVertex.position_0;
      parentPosition = currentVertex.parent_0.position_0;
      $setLine(this$static.line, currentPosition.x, currentPosition.y, parentPosition.x, parentPosition.y);
      snap(position, this$static.line, this$static.lineSnapPosition);
      squaredDistance = $distanceSq(position, this$static.lineSnapPosition);
      if (squaredDistance < minSquaredDistance) {
        vertex = currentVertex;
        $set_18(this$static.snapPosition, this$static.lineSnapPosition);
        minSquaredDistance = squaredDistance;
      }
    }
  }
  if (vertex) {
    $setVertexCount(graph, graph.vertexCount + 1);
    snapVertex = $getVertex_0(graph, graph.vertexCount - 1);
    $setPosition(snapVertex, this$static.snapPosition);
    $setParent_1(snapVertex, vertex.parent_0);
    vertex.parent_0 = snapVertex;
    vertex = snapVertex;
    $makeRoot(snapVertex);
  }
  return vertex;
}

function $grabVertex(graph, position, maxDistance){
  var currentPosition, currentVertex, i, minSquaredDistance, n, squaredDistance, vertex;
  vertex = null;
  minSquaredDistance = maxDistance * maxDistance;
  n = graph.vertexCount;
  for (i = 0; i < n; ++i) {
    currentVertex = $get(graph.vertices, i);
    currentPosition = currentVertex.position_0;
    squaredDistance = distanceSq(position.x, position.y, currentPosition.x, currentPosition.y);
    if (squaredDistance < minSquaredDistance) {
      vertex = currentVertex;
      minSquaredDistance = squaredDistance;
    }
  }
  if (vertex) {
    $set_18(vertex.position_0, position);
    $makeRoot(vertex);
  }
  return vertex;
}

function SkeletonGrabHandler_0(){
  this.line = new Line_0;
  this.snapPosition = new Point_0;
  this.lineSnapPosition = new Point_0;
}

defineSeed(525, 1, {}, SkeletonGrabHandler_0);
function $getVertex_0(this$static, index){
  return $get(this$static.vertices, index);
}

function $removeVertex(this$static, vertex){
  var currentVertex, i, parent_0;
  parent_0 = vertex.parent_0;
  $remove_0(this$static.vertices, vertex);
  --this$static.vertexCount;
  for (i = 0; i < this$static.vertexCount; ++i) {
    currentVertex = $get(this$static.vertices, i);
    currentVertex.parent_0 == vertex && (currentVertex.parent_0 = parent_0);
  }
}

function $setVertexCount(this$static, count){
  this$static.vertexCount = count;
  while (this$static.vertices.size < this$static.vertexCount) {
    $add_0(this$static.vertices, new SkeletonVertex_0(this$static));
  }
}

function SkeletonGraph_0(){
  this.vertices = new ArrayList_0;
}

defineSeed(526, 1, {}, SkeletonGraph_0);
_.vertexCount = 0;
function SkeletonGraphEditorDefaultController_0(screen_0){
  this.grabHandler = new SkeletonGrabHandler_0;
  this.screen_0 = screen_0;
}

defineSeed(527, 511, {}, SkeletonGraphEditorDefaultController_0);
_.init_0 = function init_12(){
  this.camera = this.screen_0.camera;
}
;
_.onKeyDown = function onKeyDown_4(event_0){
  event_0.key_0.ordinal == 121 && $setScreen(this.screen_0.game, new TitleScreen_0(this.screen_0.game));
}
;
_.onPointerStart = function onPointerStart_1(event_0){
  var childVertex, controller, graph, position, vertex;
  position = new Point_1(event_0.x, event_0.y);
  $transform_1($getInverseTransform(this.camera), position, position);
  graph = this.screen_0.graph;
  vertex = $grab(this.grabHandler, graph, position, this.screen_0.snapDistance);
  if (!vertex) {
    $setVertexCount(graph, graph.vertexCount + 2);
    childVertex = $getVertex_0(graph, graph.vertexCount - 1);
    vertex = $getVertex_0(graph, graph.vertexCount - 2);
    childVertex.parent_0 = vertex;
    $set_18(childVertex.position_0, position);
    $set_18(vertex.position_0, position);
  }
  controller = new SkeletonGraphEditorDragVertexController_0(this.screen_0, vertex);
  $setController_0(this.screen_0, controller);
}
;
_.camera = null;
_.screen_0 = null;
function $snap_0(this$static){
  this$static.snapType = 0;
  if (this$static.snapType == 0) {
    this$static.snapVertex = $snapToVertex(this$static.vertex, this$static.screen_0.snapDistance);
    !!this$static.snapVertex && (this$static.snapType = 1);
  }
  if (this$static.snapType == 0) {
    this$static.snapVertex = $snapToEdge(this$static.snapHandler, this$static.vertex, this$static.screen_0.snapDistance);
    !!this$static.snapVertex && (this$static.snapType = 2);
  }
}

function SkeletonGraphEditorDragVertexController_0(screen_0, vertex){
  this.mousePosition = new Point_0;
  this.snapHandler = new SkeletonSnapHandler_0;
  this.screen_0 = screen_0;
  this.vertex = vertex;
}

defineSeed(528, 511, {}, SkeletonGraphEditorDragVertexController_0);
_.exit = function exit_5(){
}
;
_.init_0 = function init_13(){
  this.camera = this.screen_0.camera;
  this.graph = this.screen_0.graph;
  $snap_0(this);
}
;
_.onPointerDrag = function onPointerDrag_1(event_0){
  $set_17(this.mousePosition, event_0.x, event_0.y);
  $transform_1($getInverseTransform(this.camera), this.mousePosition, this.mousePosition);
  $setPosition(this.vertex, this.mousePosition);
  $snap_0(this);
}
;
_.onPointerEnd = function onPointerEnd_1(event_0){
  var controller;
  $snap_0(this);
  if (this.snapType == 1) {
    $makeRoot(this.snapVertex);
    $setParent_1(this.vertex, this.snapVertex);
    $removeVertex(this.graph, this.vertex);
  }
   else if (this.snapType == 2) {
    $setParent_1(this.vertex, this.snapVertex.parent_0);
    $setParent_1(this.snapVertex, this.vertex);
    $makeRoot(this.vertex);
  }
  controller = new SkeletonGraphEditorDefaultController_0(this.screen_0);
  $setController_0(this.screen_0, controller);
}
;
_.camera = null;
_.graph = null;
_.screen_0 = null;
_.snapType = 0;
_.snapVertex = null;
_.vertex = null;
function $setController_0(this$static, controller){
  this$static.controller.exit();
  this$static.controller = controller;
  this$static.controller.init_0();
}

function SkeletonGraphEditorScreen_0(game){
  this.camera = new Camera_0;
  this.graph = new SkeletonGraph_0;
  this.game = game;
}

defineSeed(529, 515, {}, SkeletonGraphEditorScreen_0);
_.exit = function exit_6(){
  this.controller.exit();
  platform_1.graphics.rootLayer_0().remove_4(this.groupLayer);
}
;
_.init_0 = function init_14(){
  $setScale_0(this.camera, 2);
  $setViewport(this.camera, platform_1.graphics.width_2(), platform_1.graphics.height_2());
  this.groupLayer = platform_1.graphics.createGroupLayer();
  platform_1.graphics.rootLayer_0().add_1(this.groupLayer);
  this.surfaceLayer = platform_1.graphics.createSurfaceLayer(platform_1.graphics.width_2(), platform_1.graphics.height_2());
  this.surface = this.surfaceLayer.surface_0();
  this.groupLayer.add_1(this.surfaceLayer);
  this.drawHandler = new DrawHandler_0(this.surface);
  this.animationDrawHandler = new AnimationDrawHandler_0(this.surface);
  $setVertexCount(this.graph, 1);
  this.controller = new SkeletonGraphEditorDefaultController_0(this);
  this.controller.init_0();
}
;
_.onKeyDown = function onKeyDown_5(event_0){
  this.controller.onKeyDown(event_0);
}
;
_.onKeyTyped = function onKeyTyped_1(event_0){
}
;
_.onKeyUp = function onKeyUp_1(event_0){
}
;
_.onMouseDown = function onMouseDown_3(event_0){
  this.controller.onMouseDown(event_0);
}
;
_.onMouseMove = function onMouseMove_5(event_0){
  this.controller.onMouseMove(event_0);
}
;
_.onMouseUp = function onMouseUp_5(event_0){
  this.controller.onMouseUp(event_0);
}
;
_.onMouseWheelScroll = function onMouseWheelScroll_1(event_0){
}
;
_.onPointerDrag = function onPointerDrag_2(event_0){
  this.controller.onPointerDrag(event_0);
}
;
_.onPointerEnd = function onPointerEnd_2(event_0){
  this.controller.onPointerEnd(event_0);
}
;
_.onPointerStart = function onPointerStart_2(event_0){
  this.controller.onPointerStart(event_0);
}
;
_.paint_2 = function paint_11(alpha){
  var i, lineWidth, n, position, scale, transform, vertex;
  this.surface.clear_0();
  this.surface.save_0();
  transform = $getTransform_0(this.camera);
  this.surface.transform_2(transform.m00, transform.m01, transform.m10, transform.m11, transform.tx, transform.ty);
  this.surface.setFillColor(-1);
  scale = $uniformScale(transform);
  this.snapDistance = 10 / scale;
  lineWidth = 1 / scale;
  $setLineWidth_0(this.animationDrawHandler, lineWidth);
  $drawSkeletonGraph(this.animationDrawHandler, this.graph);
  n = this.graph.vertexCount;
  for (i = 0; i < n; ++i) {
    vertex = $getVertex_0(this.graph, i);
    if (!vertex.parent_0) {
      position = vertex.position_0;
      $drawCircle(this.drawHandler, position.x, position.y, this.snapDistance, lineWidth);
      $drawCircle(this.drawHandler, position.x, position.y, 0.5 * this.snapDistance, lineWidth);
    }
     else {
      position = vertex.position_0;
      $drawCircle(this.drawHandler, position.x, position.y, this.snapDistance, lineWidth);
    }
  }
  this.surface.restore_0();
}
;
_.update_0 = function update_4(delta){
}
;
_.animationDrawHandler = null;
_.controller = null;
_.drawHandler = null;
_.game = null;
_.groupLayer = null;
_.snapDistance = 0.10000000149011612;
_.surface = null;
_.surfaceLayer = null;
function $snapToEdge(this$static, vertex, maxDistance){
  var currentPosition, currentVertex, graph, i, minSquaredDistance, n, parentPosition, snapVertex, squaredDistance, vertexPosition;
  graph = vertex.graph;
  vertexPosition = vertex.position_0;
  snapVertex = null;
  minSquaredDistance = maxDistance * maxDistance;
  n = graph.vertexCount;
  for (i = 0; i < n; ++i) {
    currentVertex = $get(graph.vertices, i);
    if (currentVertex != vertex && !!currentVertex.parent_0 && currentVertex.parent_0 != vertex) {
      currentPosition = currentVertex.position_0;
      parentPosition = currentVertex.parent_0.position_0;
      $setLine(this$static.line, currentPosition.x, currentPosition.y, parentPosition.x, parentPosition.y);
      snap(vertexPosition, this$static.line, this$static.lineSnapPosition);
      squaredDistance = $distanceSq(vertexPosition, this$static.lineSnapPosition);
      if (squaredDistance < minSquaredDistance) {
        snapVertex = currentVertex;
        $set_18(this$static.snapPosition, this$static.lineSnapPosition);
        minSquaredDistance = squaredDistance;
      }
    }
  }
  !!snapVertex && $setPosition(vertex, this$static.snapPosition);
  return snapVertex;
}

function $snapToVertex(vertex, maxDistance){
  var currentPosition, currentVertex, graph, i, minSquaredDistance, n, snapVertex, squaredDistance, vertexPosition;
  graph = vertex.graph;
  vertexPosition = vertex.position_0;
  snapVertex = null;
  minSquaredDistance = maxDistance * maxDistance;
  n = graph.vertexCount;
  for (i = 0; i < n; ++i) {
    currentVertex = $get(graph.vertices, i);
    if (currentVertex != vertex) {
      currentPosition = currentVertex.position_0;
      squaredDistance = distanceSq(vertexPosition.x, vertexPosition.y, currentPosition.x, currentPosition.y);
      if (squaredDistance < minSquaredDistance) {
        snapVertex = currentVertex;
        minSquaredDistance = squaredDistance;
      }
    }
  }
  !!snapVertex && $setPosition(vertex, snapVertex.position_0);
  return snapVertex;
}

function SkeletonSnapHandler_0(){
  this.line = new Line_0;
  this.snapPosition = new Point_0;
  this.lineSnapPosition = new Point_0;
}

defineSeed(530, 1, {}, SkeletonSnapHandler_0);
function $makeRoot(this$static){
  var newParent, oldParent, vertex;
  vertex = this$static;
  newParent = null;
  do {
    oldParent = vertex.parent_0;
    vertex.parent_0 = newParent;
    newParent = vertex;
    vertex = oldParent;
  }
   while (oldParent);
}

function $setParent_1(this$static, parent_0){
  this$static.parent_0 = parent_0;
}

function $setPosition(this$static, position){
  $set_18(this$static.position_0, position);
}

function SkeletonVertex_0(graph){
  this.position_0 = new Point_0;
  this.graph = graph;
}

defineSeed(531, 1, {}, SkeletonVertex_0);
_.graph = null;
_.parent_0 = null;
function $getPercentage(current, total){
  return 100 * current / total < 0?round_int(100 * current / total - 0.5):round_int(100 * current / total + 0.5);
}

function TitleScreen_0(game){
  this.game = game;
}

defineSeed(532, 515, {}, TitleScreen_0);
_.exit = function exit_7(){
  platform_1.graphics.rootLayer_0().remove_4(this.groupLayer);
}
;
_.init_0 = function init_15(){
  var backgroundImage, backgroundImageLayer;
  this.assets = this.game.assets;
  this.watchedAssets = new WatchedAssets_0(this.assets);
  this.groupLayer = platform_1.graphics.createGroupLayer();
  platform_1.graphics.rootLayer_0().add_1(this.groupLayer);
  backgroundImage = $getImage(this.assets, 'images/bg.png');
  backgroundImageLayer = platform_1.graphics.createImageLayer(backgroundImage);
  backgroundImageLayer.setScale(4);
  this.groupLayer.add_1(backgroundImageLayer);
  $getImage_0(this.watchedAssets, 'images/background.png');
  $getImage_0(this.watchedAssets, 'images/bean.png');
  $getImage_0(this.watchedAssets, 'images/beanPod.png');
  $getImage_0(this.watchedAssets, 'images/beanstalk.png');
  $getImage_0(this.watchedAssets, 'images/blueSky.png');
  $getImage_0(this.watchedAssets, 'images/boulder.png');
  $getImage_0(this.watchedAssets, 'images/david.png');
  $getImage_0(this.watchedAssets, 'images/gameOver.png');
  $getImage_0(this.watchedAssets, 'images/giant.png');
  $getImage_0(this.watchedAssets, 'images/jack.png');
  $getImage_0(this.watchedAssets, 'images/mark.png');
  $getImage_0(this.watchedAssets, 'images/title.png');
  $getImage_0(this.watchedAssets, 'images/win.png');
  $getSound_0(this.watchedAssets, 'sounds/beanHitsMark');
  $getSound_0(this.watchedAssets, 'sounds/hitBoulder');
  $getSound_0(this.watchedAssets, 'sounds/playerTakesBeanPod');
  $getSound_0(this.watchedAssets, 'sounds/playerHasNoBeans');
  $getSound_0(this.watchedAssets, 'sounds/shootBean');
  $getSound_0(this.watchedAssets, 'sounds/shootBoulder');
  this.pendingRequestCount = $getPendingRequestCount(this.watchedAssets);
}
;
_.onKeyDown = function onKeyDown_6(event_0){
  switch (event_0.key_0.ordinal) {
    case 27:
      $setScreen(this.game, new SkeletonEditorScreen_0(this.game));
      break;
    case 28:
      $setScreen(this.game, new SkeletonGraphEditorScreen_0(this.game));
      break;
    case 98:
      $setScreen(this.game, new GameScreen_0(this.game));
  }
}
;
_.update_0 = function update_5(delta){
  var percentage;
  if (this.pendingRequestCount != $getPendingRequestCount(this.watchedAssets)) {
    this.pendingRequestCount = $getPendingRequestCount(this.watchedAssets);
    percentage = $getPercentage(this.totalRequestCount - this.pendingRequestCount, this.totalRequestCount);
    $debug(platform_1.log_0, 'Loading... ' + percentage + '%');
  }
}
;
_.assets = null;
_.game = null;
_.groupLayer = null;
_.pendingRequestCount = 0;
_.totalRequestCount = 0;
_.watchedAssets = null;
function copy_0(source, target){
  $setTransform(target, source.m00, source.m01, source.m10, source.m11, source.tx, source.ty);
}

function invert(source, target){
  var det, rdet;
  det = source.m00 * source.m11 - source.m10 * source.m01;
  if (abs(det) == 0) {
    throw new NoninvertibleTransformException_0('affine [' + toString_47(source.m00) + ' ' + toString_47(source.m01) + ' ' + toString_47(source.m10) + ' ' + toString_47(source.m11) + ' ' + new Vector_2(source.tx, source.ty) + ']');
  }
  rdet = 1 / det;
  $setTransform(target, source.m11 * rdet, -source.m10 * rdet, -source.m01 * rdet, source.m00 * rdet, (source.m10 * source.ty - source.m11 * source.tx) * rdet, (source.m01 * source.tx - source.m00 * source.ty) * rdet);
}

function snap(point, line, result){
  var a, invLength, x3, x4, x5, y3, y4, y5;
  x3 = point.x - line.x1;
  y3 = point.y - line.y1;
  x4 = point.x - line.x2;
  y4 = point.y - line.y2;
  x5 = line.x2 - line.x1;
  y5 = line.y2 - line.y1;
  if (x3 * x5 + y3 * y5 <= 0) {
    $set_17(result, line.x1, line.y1);
  }
   else if (x4 * x5 + y4 * y5 >= 0) {
    $set_17(result, line.x2, line.y2);
  }
   else {
    invLength = 1 / Math.sqrt(x5 * x5 + y5 * y5);
    x5 *= invLength;
    y5 *= invLength;
    a = x3 * x5 + y3 * y5;
    $set_17(result, line.x1 + a * x5, line.y1 + a * y5);
  }
}

var $entry = entry_0;
function gwtOnLoad(errFn, modName, modBase, softPermutationId){
  $moduleName = modName;
  $moduleBase = modBase;
  if (errFn)
    try {
      $entry(init)();
    }
     catch (e) {
      errFn(modName);
    }
   else {
    $entry(init)();
  }
}

--></script>
<script><!--
var Ljava_lang_Object_2_classLit = createForClass(1), Lcom_google_gwt_core_client_JavaScriptObject_2_classLit = createForClass(38), Ljava_lang_Throwable_2_classLit = createForClass(47), Ljava_lang_Exception_2_classLit = createForClass(46), Ljava_lang_RuntimeException_2_classLit = createForClass(45), Ljava_lang_StackTraceElement_2_classLit = createForClass(222), _3Ljava_lang_StackTraceElement_2_classLit = createForArray(541, Ljava_lang_StackTraceElement_2_classLit), Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit = createForClass(134), _3Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit = createForArray(542, Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit), I_classLit = createForPrimitive(' I'), _3I_classLit = createForArray(543, I_classLit), Lcom_google_gwt_lang_SeedUtil_2_classLit = createForClass(135), Ljava_lang_Enum_2_classLit = createForClass(11), Ljava_lang_Error_2_classLit = createForClass(209), Ljava_lang_AssertionError_2_classLit = createForClass(208), Ljava_lang_Number_2_classLit = createForClass(213), C_classLit = createForPrimitive(' C'), _3C_classLit = createForArray(544, C_classLit), Ljava_lang_Class_2_classLit = createForClass(211), F_classLit = createForPrimitive(' F'), Ljava_lang_Float_2_classLit = createForClass(212), Ljava_lang_Integer_2_classLit = createForClass(216), _3Ljava_lang_Integer_2_classLit = createForArray(545, Ljava_lang_Integer_2_classLit), Ljava_lang_String_2_classLit = createForClass(2), _3Ljava_lang_String_2_classLit = createForArray(539, Ljava_lang_String_2_classLit), Lplayn_html_HtmlGame$1_2_classLit = createForClass(431), Lplayn_html_HtmlGame$2_2_classLit = createForClass(432), Lcom_google_gwt_core_client_Scheduler_2_classLit = createForClass(53), Ljava_lang_StringBuilder_2_classLit = createForClass(225), Ljava_lang_ArrayStoreException_2_classLit = createForClass(207), Lcom_google_gwt_core_client_JavaScriptException_2_classLit = createForClass(44), Lcom_google_gwt_core_client_impl_StringBufferImpl_2_classLit = createForClass(64), Lcom_google_gwt_core_client_impl_SchedulerImpl_2_classLit = createForClass(55), Lcom_google_gwt_core_client_impl_SchedulerImpl$Flusher_2_classLit = createForClass(56), Lcom_google_gwt_core_client_impl_SchedulerImpl$Rescuer_2_classLit = createForClass(57), Lcom_google_gwt_core_client_impl_StackTraceCreator$Collector_2_classLit = createForClass(60), Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorMoz_2_classLit = createForClass(62), Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorChrome_2_classLit = createForClass(61), Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorChromeNoSourceMap_2_classLit = createForClass(63), Lcom_google_gwt_core_client_impl_StringBufferImplAppend_2_classLit = createForClass(65), Lplayn_core_LogImpl_2_classLit = createForClass(361), Lplayn_core_Log$Level_2_classLit = createForEnum(360, values_14), _3Lplayn_core_Log$Level_2_classLit = createForArray(546, Lplayn_core_Log$Level_2_classLit), Lplayn_core_AbstractPlatform_2_classLit = createForClass(345), Lplayn_html_HtmlPlatform_2_classLit = createForClass(467), Lplayn_html_HtmlPlatform$Config_2_classLit = createForClass(470), Lplayn_html_HtmlPlatform$1_2_classLit = createForClass(468), Lplayn_html_HtmlLog_2_classLit = createForClass(454), Ljava_lang_NullPointerException_2_classLit = createForClass(219), Ljava_lang_IllegalArgumentException_2_classLit = createForClass(214), Lplayn_html_HtmlLogSimple_2_classLit = createForClass(455), Ljava_lang_StringBuffer_2_classLit = createForClass(224), Lplayn_core_AbstractAssets_2_classLit = createForClass(342), Lplayn_html_HtmlAssets_2_classLit = createForClass(423), Lplayn_core_Game$Default_2_classLit = createForClass(354), Lse_elemel_crust_core_CrustGame_2_classLit = createForClass(512), Lplayn_core_Events$Input$Impl_2_classLit = createForClass(352), Lplayn_core_Keyboard$Event$Impl_2_classLit = createForClass(357), Lplayn_core_Keyboard$TypedEvent$Impl_2_classLit = createForClass(358), Lplayn_core_Events$Flags$Impl_2_classLit = createForClass(351), Lplayn_core_Events$Position$Impl_2_classLit = createForClass(353), Lplayn_core_Mouse$ButtonEvent$Impl_2_classLit = createForClass(362), Lplayn_core_Mouse$MotionEvent$Impl_2_classLit = createForClass(363), Lplayn_core_Mouse$WheelEvent$Impl_2_classLit = createForClass(364), Lplayn_core_Pointer$Event$Impl_2_classLit = createForClass(374), Lplayn_html_HtmlGraphics_2_classLit = createForClass(433), Lplayn_core_PointerImpl_2_classLit = createForClass(375), Lplayn_html_HtmlPointer_2_classLit = createForClass(471), Lplayn_html_HtmlPointer$1_2_classLit = createForClass(472), Lplayn_html_HtmlPointer$2_2_classLit = createForClass(473), Lplayn_html_HtmlPointer$3_2_classLit = createForClass(474), Lplayn_html_HtmlPointer$4_2_classLit = createForClass(475), Lplayn_html_HtmlPointer$5_2_classLit = createForClass(476), Lplayn_html_HtmlPointer$6_2_classLit = createForClass(477), Lplayn_core_Pointer$Listener_2_classLit = createForInterface(), Lplayn_core_PointerImpl$1_2_classLit = createForClass(376), Lplayn_core_PointerImpl$2_2_classLit = createForClass(377), Lplayn_core_PointerImpl$3_2_classLit = createForClass(378), Lplayn_core_AbstractLayer_2_classLit = createForClass(343), _3Ljava_lang_Object_2_classLit = createForArray(538, Ljava_lang_Object_2_classLit), Lplayn_core_AbstractLayer$Flag_2_classLit = createForEnum(344, values_12), _3Lplayn_core_AbstractLayer$Flag_2_classLit = createForArray(547, Lplayn_core_AbstractLayer$Flag_2_classLit), Lplayn_core_MouseImpl_2_classLit = createForClass(365), Lplayn_html_HtmlMouse_2_classLit = createForClass(456), Lplayn_html_HtmlMouse$1_2_classLit = createForClass(457), Lplayn_html_HtmlMouse$1XYEventHandler_2_classLit = createForClass(459), Lplayn_html_HtmlMouse$1MoveEventHandler_2_classLit = createForClass(458), Lplayn_html_HtmlMouse$2_2_classLit = createForClass(460), Lplayn_html_HtmlMouse$3_2_classLit = createForClass(461), Lplayn_html_HtmlMouse$4_2_classLit = createForClass(462), Lplayn_html_HtmlMouse$5_2_classLit = createForClass(463), Lplayn_html_HtmlMouse$6_2_classLit = createForClass(464), Lplayn_core_MouseImpl$1_2_classLit = createForClass(366), Lplayn_core_MouseImpl$2_2_classLit = createForClass(367), Lplayn_core_MouseImpl$3_2_classLit = createForClass(368), Lplayn_core_MouseImpl$4_2_classLit = createForClass(369), Lplayn_core_MouseImpl$5_2_classLit = createForClass(370), Lplayn_core_MouseImpl$6_2_classLit = createForClass(371), Lplayn_core_MouseImpl$7_2_classLit = createForClass(372), Lplayn_core_TouchImpl_2_classLit = createForClass(384), Lplayn_html_HtmlTouch_2_classLit = createForClass(483), Lplayn_core_Touch$Event$Impl_2_classLit = createForClass(383), _3Lplayn_core_Touch$Event$Impl_2_classLit = createForArray(548, Lplayn_core_Touch$Event$Impl_2_classLit), Lplayn_html_HtmlTouch$1_2_classLit = createForClass(484), Lplayn_html_HtmlTouch$2_2_classLit = createForClass(485), Lplayn_html_HtmlTouch$3_2_classLit = createForClass(486), Lplayn_core_TouchImpl$1_2_classLit = createForClass(385), Lplayn_core_TouchImpl$2_2_classLit = createForClass(386), Lplayn_core_TouchImpl$3_2_classLit = createForClass(387), Lcom_google_web_bindery_event_shared_Event_2_classLit = createForClass(109), Lcom_google_gwt_event_shared_GwtEvent_2_classLit = createForClass(108), Lcom_google_gwt_user_client_Window$ClosingEvent_2_classLit = createForClass(171), Lcom_google_gwt_event_shared_HandlerManager_2_classLit = createForClass(117), Lcom_google_gwt_user_client_Window$WindowHandlers_2_classLit = createForClass(174), Lcom_google_web_bindery_event_shared_Event$Type_2_classLit = createForClass(112), Lcom_google_gwt_event_shared_GwtEvent$Type_2_classLit = createForClass(111), Lcom_google_web_bindery_event_shared_EventBus_2_classLit = createForClass(120), Lcom_google_web_bindery_event_shared_SimpleEventBus_2_classLit = createForClass(119), Lcom_google_gwt_event_shared_HandlerManager$Bus_2_classLit = createForClass(118), Lcom_google_web_bindery_event_shared_SimpleEventBus$1_2_classLit = createForClass(202), Lcom_google_web_bindery_event_shared_SimpleEventBus$2_2_classLit = createForClass(203), Lcom_google_web_bindery_event_shared_SimpleEventBus$3_2_classLit = createForClass(204), Lplayn_html_HtmlAnalytics_2_classLit = createForClass(422), Lplayn_html_HtmlAudio_2_classLit = createForClass(424), Lplayn_html_HtmlKeyboard_2_classLit = createForClass(450), Lplayn_html_HtmlKeyboard$1_2_classLit = createForClass(451), Lplayn_html_HtmlKeyboard$2_2_classLit = createForClass(452), Lplayn_html_HtmlKeyboard$3_2_classLit = createForClass(453), Lplayn_core_CachingAssets_2_classLit = createForClass(347), Lplayn_core_gl_GLContext_2_classLit = createForClass(395), Lplayn_core_gl_GLContext$Stats_2_classLit = createForClass(401), Lse_elemel_crust_core_Screen_2_classLit = createForClass(515), Lse_elemel_crust_core_SkeletonGraphEditorScreen_2_classLit = createForClass(529), Lplayn_core_util_RunQueue_2_classLit = createForClass(421), Lplayn_html_HtmlStorage_2_classLit = createForClass(480), Lplayn_html_HtmlGraphicsCanvas_2_classLit = createForClass(434), Lplayn_html_HtmlGraphicsDom_2_classLit = createForClass(435), Lplayn_html_HtmlGraphicsGL_2_classLit = createForClass(436), Lplayn_html_HtmlInput$1_2_classLit = createForClass(448), Lcom_google_gwt_storage_client_Storage_2_classLit = createForClass(147), Lcom_google_gwt_storage_client_Storage$StorageSupportDetector_2_classLit = createForClass(148), Ljava_util_AbstractMap_2_classLit = createForClass(152), Lcom_google_gwt_storage_client_StorageMap_2_classLit = createForClass(151), Lcom_google_gwt_storage_client_StorageMap$StorageEntry_2_classLit = createForClass(153), Lcom_google_gwt_storage_client_StorageMap$StorageEntryIterator_2_classLit = createForClass(154), Ljava_util_AbstractCollection_2_classLit = createForClass(21), Ljava_util_AbstractSet_2_classLit = createForClass(156), Lcom_google_gwt_storage_client_StorageMap$StorageEntrySet_2_classLit = createForClass(155), Ljava_util_AbstractMap$1_2_classLit = createForClass(243), Ljava_util_AbstractMap$1$1_2_classLit = createForClass(244), Ljava_util_AbstractHashMap_2_classLit = createForClass(235), Ljava_util_HashMap_2_classLit = createForClass(251), Ljava_util_AbstractHashMap$EntrySet_2_classLit = createForClass(236), Ljava_util_AbstractHashMap$EntrySetIterator_2_classLit = createForClass(237), Ljava_util_AbstractMapEntry_2_classLit = createForClass(239), Ljava_util_AbstractHashMap$MapEntryNull_2_classLit = createForClass(238), Ljava_util_AbstractHashMap$MapEntryString_2_classLit = createForClass(240), Lplayn_core_gl_Scale_2_classLit = createForClass(416), Lplayn_html_HtmlLayerCanvas_2_classLit = createForClass(438), Lplayn_html_HtmlGroupLayerCanvas_2_classLit = createForClass(437), Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit = createForEnum(40, values_2), _3Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit = createForArray(549, Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit), Lcom_google_gwt_dom_client_Style$Unit_2_classLit = createForEnum(93, values_5), _3Lcom_google_gwt_dom_client_Style$Unit_2_classLit = createForArray(550, Lcom_google_gwt_dom_client_Style$Unit_2_classLit), Lcom_google_gwt_dom_client_Style$Overflow_2_classLit = createForEnum(83, values_3), _3Lcom_google_gwt_dom_client_Style$Overflow_2_classLit = createForArray(551, Lcom_google_gwt_dom_client_Style$Overflow_2_classLit), Lcom_google_gwt_dom_client_Style$Position_2_classLit = createForEnum(88, values_4), _3Lcom_google_gwt_dom_client_Style$Position_2_classLit = createForArray(552, Lcom_google_gwt_dom_client_Style$Position_2_classLit), Lcom_google_gwt_dom_client_Style$Visibility_2_classLit = createForEnum(103, values_6), _3Lcom_google_gwt_dom_client_Style$Visibility_2_classLit = createForArray(553, Lcom_google_gwt_dom_client_Style$Visibility_2_classLit), Lcom_google_gwt_dom_client_Style$Unit$1_2_classLit = createForEnum(94, null), Lcom_google_gwt_dom_client_Style$Unit$2_2_classLit = createForEnum(95, null), Lcom_google_gwt_dom_client_Style$Unit$3_2_classLit = createForEnum(96, null), Lcom_google_gwt_dom_client_Style$Unit$4_2_classLit = createForEnum(97, null), Lcom_google_gwt_dom_client_Style$Unit$5_2_classLit = createForEnum(98, null), Lcom_google_gwt_dom_client_Style$Unit$6_2_classLit = createForEnum(99, null), Lcom_google_gwt_dom_client_Style$Unit$7_2_classLit = createForEnum(100, null), Lcom_google_gwt_dom_client_Style$Unit$8_2_classLit = createForEnum(101, null), Lcom_google_gwt_dom_client_Style$Unit$9_2_classLit = createForEnum(102, null), Lcom_google_gwt_dom_client_Style$Overflow$1_2_classLit = createForEnum(84, null), Lcom_google_gwt_dom_client_Style$Overflow$2_2_classLit = createForEnum(85, null), Lcom_google_gwt_dom_client_Style$Overflow$3_2_classLit = createForEnum(86, null), Lcom_google_gwt_dom_client_Style$Overflow$4_2_classLit = createForEnum(87, null), Lcom_google_gwt_dom_client_Style$Position$1_2_classLit = createForEnum(89, null), Lcom_google_gwt_dom_client_Style$Position$2_2_classLit = createForEnum(90, null), Lcom_google_gwt_dom_client_Style$Position$3_2_classLit = createForEnum(91, null), Lcom_google_gwt_dom_client_Style$Position$4_2_classLit = createForEnum(92, null), Lcom_google_gwt_dom_client_Style$Visibility$1_2_classLit = createForEnum(104, null), Lcom_google_gwt_dom_client_Style$Visibility$2_2_classLit = createForEnum(105, null), Lplayn_html_HtmlLayerDom_2_classLit = createForClass(440), Lplayn_html_HtmlGroupLayerDom_2_classLit = createForClass(439), Lplayn_core_gl_GL20Context_2_classLit = createForClass(394), Lplayn_html_HtmlGLContext_2_classLit = createForClass(429), _3F_classLit = createForArray(554, F_classLit), Lplayn_core_gl_LayerGL_2_classLit = createForClass(409), Lplayn_core_gl_GroupLayerGL_2_classLit = createForClass(408), Lpythagoras_f_AbstractPoint_2_classLit = createForClass(491), Lpythagoras_f_Point_2_classLit = createForClass(500), Ljava_lang_NumberFormatException_2_classLit = createForClass(221), Lse_elemel_crust_core_Camera_2_classLit = createForClass(510), Lse_elemel_crust_core_SkeletonGraph_2_classLit = createForClass(526), Lse_elemel_crust_core_DrawHandler_2_classLit = createForClass(513), Lse_elemel_crust_core_AnimationDrawHandler_2_classLit = createForClass(508), Lse_elemel_crust_core_Controller_2_classLit = createForClass(511), Lse_elemel_crust_core_SkeletonGraphEditorDefaultController_2_classLit = createForClass(527), Lcom_allen_1sauer_gwt_voices_client_SoundController_2_classLit = createForClass(12), Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit = createForEnum(14, values_1), _3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit = createForArray(555, Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit), Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit = createForEnum(13, values_0), _3Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit = createForArray(556, Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit), Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit = createForClass(427), _3Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit = createForArray(557, Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit), Lplayn_html_HtmlGL20_2_classLit = createForClass(426), Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit = createForEnum(428, values_15), _3Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit = createForArray(558, Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit), Lplayn_core_Key_2_classLit = createForEnum(356, values_13), _3Lplayn_core_Key_2_classLit = createForArray(559, Lplayn_core_Key_2_classLit), Lpythagoras_f_RectangularShape_2_classLit = createForClass(493), Lpythagoras_f_AbstractRectangle_2_classLit = createForClass(492), Lpythagoras_f_Rectangle_2_classLit = createForClass(502), Lplayn_html_HtmlSurfaceLayerCanvas_2_classLit = createForClass(481), Lplayn_html_HtmlSurfaceLayerDom_2_classLit = createForClass(482), Lplayn_core_gl_SurfaceLayerGL_2_classLit = createForClass(418), Ljava_util_AbstractList_2_classLit = createForClass(20), Ljava_util_ArrayList_2_classLit = createForClass(19), Ljava_util_AbstractList$IteratorImpl_2_classLit = createForClass(241), Ljava_util_AbstractList$ListIteratorImpl_2_classLit = createForClass(242), Lse_elemel_crust_core_SkeletonVertex_2_classLit = createForClass(531), Ljava_lang_UnsupportedOperationException_2_classLit = createForClass(228), Lpythagoras_f_AbstractTransform_2_classLit = createForClass(381), Lplayn_html_HtmlInternalTransform_2_classLit = createForClass(449), Lpythagoras_f_AffineTransform_2_classLit = createForClass(380), Lplayn_core_StockInternalTransform_2_classLit = createForClass(379), Lplayn_core_GroupLayerImpl_2_classLit = createForClass(355), Lplayn_core_gl_GLShader_2_classLit = createForClass(402), Lplayn_core_gl_GLShader$Core_2_classLit = createForClass(405), Lplayn_core_gl_GLShader$Extras_2_classLit = createForClass(404), Lplayn_core_gl_GLShader$TextureExtras_2_classLit = createForClass(406), Lplayn_core_gl_GLShader$ColorExtras_2_classLit = createForClass(403), Lplayn_core_gl_IndexedTrisShader_2_classLit = createForClass(412), Lplayn_core_gl_IndexedTrisShader$ITCore_2_classLit = createForClass(413), Lplayn_core_CanvasSurface_2_classLit = createForClass(348), Lplayn_html_HtmlCanvas_2_classLit = createForClass(425), Lplayn_core_gl_AbstractSurfaceGL_2_classLit = createForClass(390), Lplayn_core_gl_SurfaceGL_2_classLit = createForClass(417), Lse_elemel_crust_core_Pose_2_classLit = createForClass(518), Lse_elemel_crust_core_SkeletonGrabHandler_2_classLit = createForClass(525), Lse_elemel_crust_core_TitleScreen_2_classLit = createForClass(532), Lcom_google_gwt_user_client_ui_UIObject_2_classLit = createForClass(142), Lcom_google_gwt_user_client_ui_Widget_2_classLit = createForClass(141), Lcom_google_gwt_user_client_ui_Panel_2_classLit = createForClass(180), Lcom_google_gwt_user_client_ui_ComplexPanel_2_classLit = createForClass(179), Lcom_google_gwt_user_client_ui_AbsolutePanel_2_classLit = createForClass(178), Lcom_google_gwt_user_client_ui_RootPanel_2_classLit = createForClass(185), Lcom_google_gwt_user_client_ui_RootPanel$DefaultRootPanel_2_classLit = createForClass(188), Lcom_google_gwt_user_client_ui_RootPanel$1_2_classLit = createForClass(186), Lcom_google_gwt_user_client_ui_RootPanel$2_2_classLit = createForClass(187), Lcom_google_web_bindery_event_shared_UmbrellaException_2_classLit = createForClass(123), Lcom_google_gwt_event_shared_UmbrellaException_2_classLit = createForClass(122), Lcom_google_gwt_user_client_ui_AttachDetachException_2_classLit = createForClass(181), Lcom_google_gwt_user_client_ui_AttachDetachException$1_2_classLit = createForClass(182), Lcom_google_gwt_user_client_ui_AttachDetachException$2_2_classLit = createForClass(183), Ljava_util_MapEntryImpl_2_classLit = createForClass(253), Lplayn_core_gl_QuadShader_2_classLit = createForClass(414), Lplayn_core_gl_QuadShader$QuadCore_2_classLit = createForClass(415), Lse_elemel_crust_core_SkeletonGraphEditorDragVertexController_2_classLit = createForClass(528), Ljava_util_HashSet_2_classLit = createForClass(252), Lcom_google_gwt_event_shared_LegacyHandlerWrapper_2_classLit = createForClass(121), Lpythagoras_util_NoninvertibleTransformException_2_classLit = createForClass(506), Lpythagoras_f_AbstractVector_2_classLit = createForClass(494), Lpythagoras_f_Vector_2_classLit = createForClass(504), Ljava_lang_IllegalStateException_2_classLit = createForClass(215), Lplayn_core_gl_ImageGL_2_classLit = createForClass(410), Lpythagoras_f_AbstractLine_2_classLit = createForClass(490), Lpythagoras_f_Line_2_classLit = createForClass(497), Lplayn_core_WatchedAssets_2_classLit = createForClass(388), Lplayn_core_WatchedAssets$1_2_classLit = createForClass(389), Lse_elemel_crust_core_SkeletonEditorScreen_2_classLit = createForClass(524), Lse_elemel_crust_core_GameScreen_2_classLit = createForClass(514), Lcom_google_gwt_event_logical_shared_CloseEvent_2_classLit = createForClass(116), Lse_elemel_crust_core_SkeletonSnapHandler_2_classLit = createForClass(530), Lpythagoras_f_AbstractDimension_2_classLit = createForClass(489), Lpythagoras_f_Dimension_2_classLit = createForClass(495), Ljava_lang_IndexOutOfBoundsException_2_classLit = createForClass(206), Ljava_nio_Buffer_2_classLit = createForClass(229), Ljava_nio_ByteBuffer_2_classLit = createForClass(230), Lplayn_html_HtmlImage_2_classLit = createForClass(441), Lplayn_html_HtmlImage$1_2_classLit = createForClass(442), Lplayn_html_HtmlImage$2_2_classLit = createForClass(443), Lplayn_html_HtmlImageLayerCanvas_2_classLit = createForClass(444), Lplayn_html_HtmlImageLayerDom_2_classLit = createForClass(445), Lplayn_html_HtmlImageLayerDom$1_2_classLit = createForClass(446), Lplayn_core_gl_ImageLayerGL_2_classLit = createForClass(411), Ljava_util_NoSuchElementException_2_classLit = createForClass(254), Lplayn_core_AbstractSound_2_classLit = createForClass(346), Lplayn_html_HtmlSound_2_classLit = createForClass(478), Lplayn_html_HtmlSound$1_2_classLit = createForClass(479), Lse_elemel_crust_core_Skeleton_2_classLit = createForClass(519), Lse_elemel_crust_core_SkeletonEditorDefaultController_2_classLit = createForClass(521), Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit = createForClass(320), _3Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit = createForArray(560, Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit), _3_3Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit = createForArray(561, _3Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit), Lorg_jbox2d_dynamics_Body_2_classLit = createForClass(302), _3Lorg_jbox2d_dynamics_Body_2_classLit = createForArray(562, Lorg_jbox2d_dynamics_Body_2_classLit), Lorg_jbox2d_dynamics_contacts_Contact_2_classLit = createForClass(316), _3Lorg_jbox2d_dynamics_contacts_Contact_2_classLit = createForArray(563, Lorg_jbox2d_dynamics_contacts_Contact_2_classLit), Lorg_jbox2d_dynamics_World_2_classLit = createForClass(313), Lorg_jbox2d_dynamics_WorldRayCastWrapper_2_classLit = createForClass(314), Lorg_jbox2d_common_Vec2_2_classLit = createForClass(300), Lorg_jbox2d_callbacks_DebugDraw_2_classLit = createForClass(260), Lse_elemel_crust_core_PhysicsDebugDrawHandler_2_classLit = createForClass(517), Lse_elemel_crust_core_Actor_2_classLit = createForClass(507), Lse_elemel_crust_core_MonsterActor_2_classLit = createForClass(516), Lplayn_core_gl_GL20Buffer_2_classLit = createForClass(391), Lplayn_core_gl_GL20Buffer$FloatImpl_2_classLit = createForClass(392), Lplayn_core_gl_GL20Buffer$ShortImpl_2_classLit = createForClass(393), Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit = createForEnum(10, values), _3Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit = createForArray(564, Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit), Lse_elemel_crust_core_Bone_2_classLit = createForClass(509), Lorg_jbox2d_pooling_WorldPool_2_classLit = createForClass(338), Lorg_jbox2d_dynamics_ContactManager_2_classLit = createForClass(305), Lorg_jbox2d_dynamics_TimeStep_2_classLit = createForClass(311), Lorg_jbox2d_dynamics_Fixture_2_classLit = createForClass(307), Lorg_jbox2d_collision_AABB_2_classLit = createForClass(261), Lorg_jbox2d_common_Transform_2_classLit = createForClass(299), Lorg_jbox2d_dynamics_BodyType_2_classLit = createForEnum(304, values_11), _3Lorg_jbox2d_dynamics_BodyType_2_classLit = createForArray(565, Lorg_jbox2d_dynamics_BodyType_2_classLit), Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit = createForClass(288), Lorg_jbox2d_pooling_arrays_DynamicTLArray_2_classLit = createForClass(339), Ljava_lang_ThreadLocal_2_classLit = createForClass(227), Lorg_jbox2d_pooling_arrays_DynamicTLArray$TLHashMap_2_classLit = createForClass(340), Lorg_jbox2d_pooling_arrays_Vec2Array_2_classLit = createForClass(341), _3Lorg_jbox2d_common_Vec2_2_classLit = createForArray(566, Lorg_jbox2d_common_Vec2_2_classLit), Lorg_jbox2d_collision_broadphase_BroadPhase_2_classLit = createForClass(286), Lorg_jbox2d_collision_broadphase_Pair_2_classLit = createForClass(289), _3Lorg_jbox2d_collision_broadphase_Pair_2_classLit = createForArray(567, Lorg_jbox2d_collision_broadphase_Pair_2_classLit), _3Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit = createForArray(568, Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit), Lplayn_core_gl_GL20Program_2_classLit = createForClass(396), Lplayn_core_gl_GL20Program$2_2_classLit = createForClass(398), Lplayn_core_gl_GL20Program$5_2_classLit = createForClass(399), Lplayn_core_gl_GL20Program$8_2_classLit = createForClass(400), Lplayn_core_gl_GL20Program$10_2_classLit = createForClass(397), Lplayn_html_HtmlPattern_2_classLit = createForClass(466), Lse_elemel_crust_core_SkeletonEditorCreateBoneController_2_classLit = createForClass(520), Lse_elemel_crust_core_SkeletonEditorMoveBoneController_2_classLit = createForClass(522), Lse_elemel_crust_core_SkeletonEditorRotateAndScaleBoneController_2_classLit = createForClass(523), Lorg_jbox2d_pooling_OrderedStack_2_classLit = createForClass(330), Lorg_jbox2d_pooling_OrderedStackVec2_2_classLit = createForClass(333), Lorg_jbox2d_pooling_OrderedStackVec3_2_classLit = createForClass(334), Lorg_jbox2d_common_Vec3_2_classLit = createForClass(301), _3Lorg_jbox2d_common_Vec3_2_classLit = createForArray(569, Lorg_jbox2d_common_Vec3_2_classLit), Lorg_jbox2d_pooling_OrderedStackMat22_2_classLit = createForClass(332), Lorg_jbox2d_common_Mat22_2_classLit = createForClass(295), _3Lorg_jbox2d_common_Mat22_2_classLit = createForArray(570, Lorg_jbox2d_common_Mat22_2_classLit), Lorg_jbox2d_pooling_OrderedStackAABB_2_classLit = createForClass(331), _3Lorg_jbox2d_collision_AABB_2_classLit = createForArray(571, Lorg_jbox2d_collision_AABB_2_classLit), Lorg_jbox2d_collision_Distance_2_classLit = createForClass(267), Lorg_jbox2d_collision_Distance$SimplexVertex_2_classLit = createForClass(271), Lorg_jbox2d_collision_Distance$SimplexCache_2_classLit = createForClass(270), _3Lorg_jbox2d_collision_Distance$SimplexVertex_2_classLit = createForArray(572, Lorg_jbox2d_collision_Distance$SimplexVertex_2_classLit), Lorg_jbox2d_collision_Distance$Simplex_2_classLit = createForClass(269), Lorg_jbox2d_collision_Distance$DistanceProxy_2_classLit = createForClass(268), Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit = createForClass(263), _3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit = createForArray(573, Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit), Lorg_jbox2d_collision_Collision_2_classLit = createForClass(262), Lorg_jbox2d_collision_Collision$EdgeResults_2_classLit = createForClass(264), Lorg_jbox2d_collision_TimeOfImpact_2_classLit = createForClass(280), Lorg_jbox2d_collision_TimeOfImpact$TOIInput_2_classLit = createForClass(281), Lorg_jbox2d_collision_TimeOfImpact$TOIOutputState_2_classLit = createForEnum(283, values_8), _3Lorg_jbox2d_collision_TimeOfImpact$TOIOutputState_2_classLit = createForArray(574, Lorg_jbox2d_collision_TimeOfImpact$TOIOutputState_2_classLit), Lorg_jbox2d_collision_TimeOfImpact$TOIOutput_2_classLit = createForClass(282), Lorg_jbox2d_collision_Type_2_classLit = createForEnum(284, values_9), _3Lorg_jbox2d_collision_Type_2_classLit = createForArray(575, Lorg_jbox2d_collision_Type_2_classLit), Lorg_jbox2d_collision_SeparationFunction_2_classLit = createForClass(279), Lorg_jbox2d_dynamics_BodyDef_2_classLit = createForClass(303), Lorg_jbox2d_collision_shapes_Shape_2_classLit = createForClass(292), Lorg_jbox2d_collision_shapes_CircleShape_2_classLit = createForClass(291), Lorg_jbox2d_dynamics_FixtureDef_2_classLit = createForClass(308), Lorg_jbox2d_callbacks_ContactFilter_2_classLit = createForClass(258), Lorg_jbox2d_dynamics_contacts_ContactEdge_2_classLit = createForClass(319), Lorg_jbox2d_dynamics_Island_2_classLit = createForClass(309), Lorg_jbox2d_dynamics_joints_Joint_2_classLit = createForClass(null), _3Lorg_jbox2d_dynamics_joints_Joint_2_classLit = createForArray(576, Lorg_jbox2d_dynamics_joints_Joint_2_classLit), Lorg_jbox2d_dynamics_Velocity_2_classLit = createForClass(312), _3Lorg_jbox2d_dynamics_Velocity_2_classLit = createForArray(577, Lorg_jbox2d_dynamics_Velocity_2_classLit), Lorg_jbox2d_dynamics_Position_2_classLit = createForClass(310), _3Lorg_jbox2d_dynamics_Position_2_classLit = createForArray(578, Lorg_jbox2d_dynamics_Position_2_classLit), Lorg_jbox2d_collision_shapes_ShapeType_2_classLit = createForEnum(294, values_10), _3Lorg_jbox2d_collision_shapes_ShapeType_2_classLit = createForArray(579, Lorg_jbox2d_collision_shapes_ShapeType_2_classLit), Lorg_jbox2d_common_Sweep_2_classLit = createForClass(298), Lorg_jbox2d_collision_broadphase_DynamicTree_2_classLit = createForClass(287), Ljava_nio_FloatBuffer_2_classLit = createForClass(232), Ljava_nio_ByteOrder_2_classLit = createForClass(231), Ljava_nio_IntBuffer_2_classLit = createForClass(233), Ljava_nio_ShortBuffer_2_classLit = createForClass(234), Lorg_jbox2d_pooling_MutableStack_2_classLit = createForClass(329), Lorg_jbox2d_pooling_PolygonContactStack_2_classLit = createForClass(336), Lorg_jbox2d_dynamics_contacts_PolygonContact_2_classLit = createForClass(323), _3Lorg_jbox2d_dynamics_contacts_PolygonContact_2_classLit = createForArray(580, Lorg_jbox2d_dynamics_contacts_PolygonContact_2_classLit), Lorg_jbox2d_pooling_CircleContactStack_2_classLit = createForClass(328), Lorg_jbox2d_dynamics_contacts_CircleContact_2_classLit = createForClass(315), _3Lorg_jbox2d_dynamics_contacts_CircleContact_2_classLit = createForArray(581, Lorg_jbox2d_dynamics_contacts_CircleContact_2_classLit), Lorg_jbox2d_pooling_PolygonAndCircleContactStack_2_classLit = createForClass(335), Lorg_jbox2d_dynamics_contacts_PolygonAndCircleContact_2_classLit = createForClass(322), _3Lorg_jbox2d_dynamics_contacts_PolygonAndCircleContact_2_classLit = createForArray(582, Lorg_jbox2d_dynamics_contacts_PolygonAndCircleContact_2_classLit), Lorg_jbox2d_collision_RayCastInput_2_classLit = createForClass(277), Lorg_jbox2d_dynamics_contacts_TOIConstraint_2_classLit = createForClass(325), _3Lorg_jbox2d_dynamics_contacts_TOIConstraint_2_classLit = createForArray(583, Lorg_jbox2d_dynamics_contacts_TOIConstraint_2_classLit), Lorg_jbox2d_dynamics_contacts_TOISolver_2_classLit = createForClass(326), Lorg_jbox2d_dynamics_contacts_TOISolverManifold_2_classLit = createForClass(327), Lorg_jbox2d_dynamics_Filter_2_classLit = createForClass(306), Lorg_jbox2d_collision_broadphase_Pair$StableComparator_2_classLit = createForClass(290), Lorg_jbox2d_collision_Manifold_2_classLit = createForClass(274), Lorg_jbox2d_collision_ManifoldPoint_2_classLit = createForClass(276), _3Lorg_jbox2d_collision_ManifoldPoint_2_classLit = createForArray(584, Lorg_jbox2d_collision_ManifoldPoint_2_classLit), Lorg_jbox2d_collision_Manifold$ManifoldType_2_classLit = createForEnum(275, values_7), _3Lorg_jbox2d_collision_Manifold$ManifoldType_2_classLit = createForArray(585, Lorg_jbox2d_collision_Manifold$ManifoldType_2_classLit), Lorg_jbox2d_collision_ContactID_2_classLit = createForClass(265), Lorg_jbox2d_collision_ContactID$Features_2_classLit = createForClass(266), Lorg_jbox2d_pooling_TLManifold_2_classLit = createForClass(337), Lorg_jbox2d_dynamics_contacts_ContactSolver_2_classLit = createForClass(321), Lorg_jbox2d_dynamics_contacts_ContactConstraint_2_classLit = createForClass(317), _3Lorg_jbox2d_dynamics_contacts_ContactConstraint_2_classLit = createForArray(586, Lorg_jbox2d_dynamics_contacts_ContactConstraint_2_classLit), Lorg_jbox2d_dynamics_contacts_PositionSolverManifold_2_classLit = createForClass(324), Lorg_jbox2d_dynamics_contacts_ContactConstraintPoint_2_classLit = createForClass(318), _3Lorg_jbox2d_dynamics_contacts_ContactConstraintPoint_2_classLit = createForArray(587, Lorg_jbox2d_dynamics_contacts_ContactConstraintPoint_2_classLit), Lcom_allen_1sauer_gwt_voices_client_AbstractSound_2_classLit = createForClass(3), Lcom_allen_1sauer_gwt_voices_client_FlashSound_2_classLit = createForClass(4), Lcom_allen_1sauer_gwt_voices_client_FlashSound$1_2_classLit = createForClass(5), Lcom_allen_1sauer_gwt_voices_client_FlashSound$2_2_classLit = createForClass(6), Lcom_allen_1sauer_gwt_voices_client_NativeSound_2_classLit = createForClass(9), Lorg_jbox2d_collision_DistanceInput_2_classLit = createForClass(272), Lorg_jbox2d_collision_DistanceOutput_2_classLit = createForClass(273), Lorg_jbox2d_collision_shapes_MassData_2_classLit = createForClass(293), Ljava_util_Comparators$1_2_classLit = createForClass(249), Lorg_jbox2d_collision_WorldManifold_2_classLit = createForClass(285), Lorg_jbox2d_callbacks_ContactImpulse_2_classLit = createForClass(259), Ljava_util_Collections$EmptyList_2_classLit = createForClass(247), Lcom_allen_1sauer_gwt_voices_client_Html5Sound_2_classLit = createForClass(7), Lcom_allen_1sauer_gwt_voices_client_Html5Sound$1_2_classLit = createForClass(8), Lcom_allen_1sauer_gwt_voices_client_ui_FlashMovie_2_classLit = createForClass(23), Lcom_allen_1sauer_gwt_voices_client_ui_VoicesMovie_2_classLit = createForClass(24), Lcom_allen_1sauer_gwt_voices_client_ui_VoicesMovie$1_2_classLit = createForClass(25), Lcom_allen_1sauer_gwt_voices_client_WebAudioSound_2_classLit = createForClass(15), Lorg_jbox2d_collision_RayCastOutput_2_classLit = createForClass(278), Ljava_lang_ArrayIndexOutOfBoundsException_2_classLit = createForClass(205), Lplayn_html_HtmlPath_2_classLit = createForClass(465), Lcom_google_gwt_user_client_ui_FocusWidget_2_classLit = createForClass(140), Lcom_google_gwt_media_client_MediaBase_2_classLit = createForClass(139), Lcom_google_gwt_media_client_Audio_2_classLit = createForClass(138), Lcom_google_gwt_media_client_Audio$AudioElementSupportDetector_2_classLit = createForClass(144), Lcom_google_gwt_media_client_Audio$AudioElementSupportDetectedMaybe_2_classLit = createForClass(143), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImpl_2_classLit = createForClass(26), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplPlayN_2_classLit = createForClass(28), Lcom_allen_1sauer_gwt_voices_client_handler_SoundHandlerCollection_2_classLit = createForClass(18), Ljava_util_EventObject_2_classLit = createForClass(17), Lcom_allen_1sauer_gwt_voices_client_handler_SoundLoadStateChangeEvent_2_classLit = createForClass(22), Ljava_util_Vector_2_classLit = createForClass(256), Ljava_util_Stack_2_classLit = createForClass(255), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplIE6_2_classLit = createForClass(27), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplStandard_2_classLit = createForClass(30), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplSafari_2_classLit = createForClass(29), Ljava_util_EmptyStackException_2_classLit = createForClass(250), Lcom_google_gwt_event_dom_client_DomEvent_2_classLit = createForClass(107), Lcom_google_gwt_event_dom_client_EndedEvent_2_classLit = createForClass(113), Lcom_google_gwt_event_dom_client_DomEvent$Type_2_classLit = createForClass(110), Lcom_google_gwt_user_client_ui_WidgetCollection_2_classLit = createForClass(189), _3Lcom_google_gwt_user_client_ui_Widget_2_classLit = createForArray(588, Lcom_google_gwt_user_client_ui_Widget_2_classLit), Lcom_google_gwt_user_client_ui_WidgetCollection$WidgetIterator_2_classLit = createForClass(190), Lcom_google_gwt_event_dom_client_PrivateMap_2_classLit = createForClass(114), Lcom_allen_1sauer_gwt_voices_client_handler_PlaybackCompleteEvent_2_classLit = createForClass(16);
$stats && $stats({moduleName:'crust',sessionId:$sessionId,subSystem:'startup',evtGroup:'moduleStartup',millis:(new Date()).getTime(),type:'moduleEvalEnd'});
if ($wnd.crust) $wnd.crust.onScriptLoad();
--></script></body></html>
